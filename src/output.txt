[
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Context.h",
        "content": "#ifndef CONTEXT_H\n#define CONTEXT_H\n\n#include \"Config/IConfigs.h\"\n#include \"Security/ISecurity.h\"\n#include \"Database/Controllers/IController.h\"\n#include \"Logging/ILog.h\"\n#include \"ErrorHandler/IErrorHandler.h\"\n#include \"Validation/IValidation.h\"\n#include \"Clock/IClock.h\"\n#include \"FileManager/IEBPFile.h\"\n#include \"NetworkManager/INetwork.h\"\n#include \"ModuleManager/IModules.h\"\n#include \"SystemMonitor/ISystemMonitor.h\"\n\n\nstatic StorageType storageType;\nstatic bool _https_enabled = false;\nclass Context {\npublic:\n    Context() {}\n    IConfigs* getConfig() { return _config; }\n    void setConfig(IConfigs* config) { _config = config; }\n    \n    ILog* getLogger() { return logger; }\n    void setLogger(ILog* log) { logger = log; }\n\n    IErrorHandler* getErrorHandler() { return errorHandler; }\n    void setErrorHandler(IErrorHandler* handler) { errorHandler = handler; }\n\n    IValidation* getValidation() { return validation; }\n    void setValidation(IValidation* val) { validation = val; }\n\n    IClock* getClock() { return _clock; }\n    void setClock(IClock* clk) { _clock = clk; }\n\n    IEBPFile* getLittleFS() { return ebpLittleFS; }\n    void setLittleFS(IEBPFile* ebpsp) { ebpLittleFS = ebpsp; }\n    \n    IEBPFile* getSD() { return ebpSD; }\n    void setSD(IEBPFile* ebpsd) { ebpSD = ebpsd; }\n\n    INetwork* getNetwork(){ return _network; }\n    void setNetwork(INetwork* network) { _network = network; }\n\n    IModules* getModules(){ return _modules; }\n    void setModules(IModules* modules) { _modules = modules; }\n\n    ISystemMonitor* getSystemMonitor(){ return _systemMonitor; }\n    void setSystemMonitor(ISystemMonitor* systemMonitor) { _systemMonitor = systemMonitor; }\n\n    ISecurity* getSecurity(){ return _security; }\n    void setSecurity(ISecurity* security) { _security = security; }\n\nprivate:\n    IConfigs* _config;\n    ILog* logger;\n    IErrorHandler* errorHandler;\n    IValidation* validation;\n    IClock* _clock;\n    IEBPFile* ebpLittleFS;\n    IEBPFile* ebpSD;\n    INetwork* _network;\n    IModules* _modules;\n    ISecurity* _security;\n    ISystemMonitor* _systemMonitor;\n};\n\n#endif // CONTEXT_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\DatabaseSeeder.h",
        "content": "#ifndef DATABASESEEDER_H\n#define DATABASESEEDER_H\n\n#include \"Context.h\"\n#include \"Database/Controllers/Security/PermissionController.h\"\n#include \"Database/Controllers/Security/RoleController.h\"\n#include \"Database/Controllers/Security/RolePermissionController.h\"\n#include \"Database/Controllers/Security/UserController.h\"\n\n#include \"Security/AuthorizationPermissions.h\"\n\nclass DatabaseSeeder\n{\nprivate:\n    Context* context;\npublic:\n    DatabaseSeeder(Context* context);\n    ~DatabaseSeeder();\n    void seed();\n};\n\nDatabaseSeeder::DatabaseSeeder(Context* context): context(context)\n{\n\n}\n\nDatabaseSeeder::~DatabaseSeeder()\n{\n}\n\nvoid DatabaseSeeder::seed()\n{\n    long start_millis = millis();\n\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::USER_CREATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::USER_UPDATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::USER_DELETE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::USER_GET, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ROLE_CREATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ROLE_UPDATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ROLE_DELETE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ROLE_GET, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::PERMISSION_CREATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::PERMISSION_UPDATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::PERMISSION_DELETE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::PERMISSION_GET, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ROLEPERMISSION_CREATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ROLEPERMISSION_UPDATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ROLEPERMISSION_DELETE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ROLEPERMISSION_GET, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::USERRESETPASS_CREATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::USERRESETPASS_UPDATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::USERRESETPASS_DELETE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::USERRESETPASS_GET, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::SECURITYQUESTION_CREATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::SECURITYQUESTION_UPDATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::SECURITYQUESTION_DELETE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::SECURITYQUESTION_GET, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::SECURITYQUESTIONTITLE_CREATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::SECURITYQUESTIONTITLE_UPDATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::SECURITYQUESTIONTITLE_DELETE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::SECURITYQUESTIONTITLE_GET, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::LOGINATTEMPT_CREATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::LOGINATTEMPT_UPDATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::LOGINATTEMPT_DELETE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::LOGINATTEMPT_GET, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ACCOUNTLOCKOUT_CREATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ACCOUNTLOCKOUT_UPDATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ACCOUNTLOCKOUT_DELETE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ACCOUNTLOCKOUT_GET, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::TWOFACTORAUTH_CREATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::TWOFACTORAUTH_UPDATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::TWOFACTORAUTH_DELETE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::TWOFACTORAUTH_GET, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ACCOUNTACTIVITYLOG_CREATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ACCOUNTACTIVITYLOG_UPDATE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ACCOUNTACTIVITYLOG_DELETE, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::ACCOUNTACTIVITYLOG_GET, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::AUTHENTICATION_LOGIN, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::AUTHENTICATION_PASSWORDRESET, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::AUTHENTICATION_PASSWORDRESETCONFIRM, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::AUTHENTICATION_TWOFACTORAUTH, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::AUTHENTICATION_TWOFACTORAUTHCONFIRM, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::AUTHENTICATION_ACCOUNTLOCK, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::AUTHENTICATION_ACCOUNTUNLOCK, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::AUTHENTICATION_SECURITYQUESTIONANSWER, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::TESTREQUESTS_ADDDATA, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::TESTREQUESTS_GETDATA, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::TESTREQUESTS_PUBLICREQUEST, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::GetData, \"Security Permissions\");\n    context->getSecurity()->addPermissionForAdmin(AuthorizationPermissions::AddData, \"Security Permissions\");\n\n    long passed_millis = millis() - start_millis;\n    Serial.print(\"Seeding System Database finished in \");Serial.print(passed_millis);Serial.println(\" miliseconds.\");\n}\n\n#endif //DATABASESEEDER_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\EBPInterfaces.h",
        "content": "#ifndef EBPINTERFACES_H\n#define EBPINTERFACES_H\n\n#include \"Clock/IClock.h\"\n#include \"Config/IConfig.h\"\n#include \"Database/Controllers/IController.h\"\n#include \"ErrorHandler/IErrorHandler.h\"\n#include \"FileManager/IEBPFile.h\"\n#include \"Logging/ILog.h\"\n#include \"ModuleManager/IModules.h\"\n#include \"NetworkManager/INetwork.h\"\n#include \"SystemMonitor/ISystemMonitor.h\"\n#include \"Database/Entities/Entity.h\"\n\n#endif //EBPINTERFACES_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ESPBoilerplate.h",
        "content": "#ifndef ESPBOILERPLATE_H\n#define ESPBOILERPLATE_H\n\n#include <Arduino.h>\n#include <PCF8574.h>\n#include \"Context.h\"\n#include \"Config/Configs.h\"\n#include \"Logging/Log.h\"\n#include \"ErrorHandler/ErrorHandler.h\"\n#include \"Validation/Validation.h\"\n#include \"NetworkManager/Network.h\"\n#include \"Clock/Clock.h\"\n#include \"FileManager/EBPFile.h\"\n#include \"ModuleManager/Modules.h\"\n#include \"SystemMonitor/SystemMonitor.h\"\n#include \"Security/Security.h\"\n#include \"DatabaseSeeder.h\"\n\nclass ESPBoilerplate\n{\nprivate:\n    Context* context;\n    SystemLog* logger;\n    Configs* configs;\n    ErrorHandler* errorHandler;\n    Validation* validation;\n    Clock* _clock;\n    EBPFile* ebpLittleFS;\n    EBPFile* ebpSD;\n    Network* network;\n    Modules* modules;\n    SystemMonitor* systemMonitor;\n    Security* security;\n    CertificateData _certificateData;\n    void initialize();\n\n\npublic:\n    ESPBoilerplate(StorageType storageType);\n    ESPBoilerplate(StorageType storageType, CertificateData certificateDate);\n    ~ESPBoilerplate();\n\n    void update();\n    void begin();\n    Context* getContext();\n    DatabaseSeeder* dbSeeder;\n};\n\nESPBoilerplate::ESPBoilerplate(StorageType _storageType ,CertificateData certificateData) :  _certificateData(certificateData)\n{\n    _https_enabled = true;\n    storageType = _storageType;\n    initialize();\n}\n\nESPBoilerplate::ESPBoilerplate(StorageType _storageType)\n{\n    storageType = _storageType;\n    initialize();\n}\n\nESPBoilerplate::~ESPBoilerplate()\n{\n}\n\nContext* ESPBoilerplate::getContext()\n{\n    return context;\n}\n\nvoid ESPBoilerplate::initialize() {\n    context = new Context();\n    errorHandler = new ErrorHandler();\n    validation = new Validation();\n    configs = new Configs(context);\n    logger = new SystemLog(context);\n    _clock = new Clock(*context);\n    ebpLittleFS = new EBPFile(context, StorageType::SPIFFS_TYPE);\n    ebpSD = new EBPFile(context, StorageType::SD_TYPE);\n    if (_https_enabled)\n    {\n        network = new Network(context, _certificateData);\n    }\n    else\n    {\n        network = new Network(context);\n    }\n    \n    modules = new Modules(context);\n    systemMonitor = new SystemMonitor();\n    security = new Security(context);\n    \n\n    context->setConfig(configs);\n    context->setLogger(logger);\n    context->setErrorHandler(errorHandler);\n    context->setValidation(validation);\n    context->setClock(_clock);\n    context->setLittleFS(ebpLittleFS);\n    context->setSD(ebpSD);\n    context->setNetwork(network);\n    context->setModules(modules);\n    context->setSystemMonitor(systemMonitor);\n    context->setSecurity(security);\n    \n    configs->initialize();\n    _clock->initialize();\n    modules->initialize();\n    \n    \n    network->initialize();\n    Serial.println(\"network initialized\");\n    security->initialize();\n\n    // dbSeeder = new DatabaseSeeder(context);\n    // dbSeeder->seed();\n\n}    \n\nvoid ESPBoilerplate::begin()\n{\n    network->begin();\n}\n\nvoid ESPBoilerplate::update() {\n    network->update();\n\n}\n\n#endif // RUNTIME_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\AccountManager\\AccountManager.h",
        "content": ""
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\BatteryManager\\BatteryManager.h",
        "content": ""
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\BluetoothManager\\BluetoothManager.h",
        "content": ""
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\CallManager\\CallManager.h",
        "content": ""
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\CameraManager\\CameraManager.h",
        "content": ""
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Clock\\Clock.h",
        "content": "#ifndef CLOCK_H\n#define CLOCK_H\n\n#include \"JalaliDateTime.h\"\n#include \"IClock.h\"\n\n#include \"../Config/System/SystemConfigKeys.h\"\n#include \"../Context.h\"\n\nenum class ClockType { DS3231, DS1307 };\n\nclass Clock : public IClock {\nprivate:\n    RTC_DS3231 ds3231;\n    RTC_DS1307 ds1307;\n    ClockType clockType;\n    Context context;\n    bool _isinitialized;\n\npublic:\n    Clock(Context context) : context(context), _isinitialized(false) {\n        \n    }\n\n    void initialize() override {\n        // String clockTypeStr = context.getConfig()->get(SystemConfigKey::CLOCK_TYPE);\n        String clockTypeStr = \"DS3231\";\n        // Initialize the correct clock based on the type\n        if (clockTypeStr == \"DS3231\") {\n            if (!ds3231.begin()) {\n                // context.getErrorHandler()->handleError(ErrorType::CustomError, \"DS3231 initialization failed\");\n                return;\n            }\n            clockType = ClockType::DS3231;\n        }\n        else if(clockTypeStr == \"DS1307\"){\n            if (!ds1307.begin()) {\n                context.getErrorHandler()->handleError(ErrorType::CustomError, \"DS1307 initialization failed\");\n                return;\n            }\n            clockType = ClockType::DS1307;\n        }\n        _isinitialized = true;\n    }\n\n    EBPDateTime now() override {\n        // Return the current date and time based on the clock type\n        if (!_isinitialized)\n        {\n\n            EBPDateTime espDateTime = EBPDateTime(2000,1,1,0,0,0);    \n            return espDateTime;\n        }\n        \n        switch (clockType) {\n        case ClockType::DS3231:\n            return EBPDateTime(ds3231.now());\n        case ClockType::DS1307:\n            return EBPDateTime(ds1307.now());\n        }\n    }\n\n    JalaliDateTime nowJalali() override {\n        // Return the current date and time based on the clock type in Jalali Calendar\n        if (!_isinitialized)\n        {\n            return JalaliDateTime(DateTime(2000,1,1,0,0,0));\n        }\n        JalaliDateTime jalaliDateTime = JalaliDateTime();\n        switch (clockType) {\n        case ClockType::DS3231:\n            jalaliDateTime.ConvertToJalali(ds3231.now());\n            return jalaliDateTime;\n        case ClockType::DS1307:\n            jalaliDateTime.ConvertToJalali(ds1307.now());\n            return jalaliDateTime;\n        }\n    }\n\n    void adjust(const EBPDateTime& dt) override {\n        // Set the current date and time based on the clock type\n        \n        switch (clockType) {\n        case ClockType::DS3231:\n            ds3231.adjust(dt);\n            break;\n        case ClockType::DS1307:\n            ds1307.adjust(dt);\n            break;\n        }\n    }\n\n    void syncTimeWithServer() override {\n        \n        configTime(0, 0, \"pool.ntp.org\"); // UTC\n\n        time_t now = 0;\n        struct tm timeinfo = {0};\n        int retry = 0;\n        const int retry_count = 10;\n        while(timeinfo.tm_year < (2016 - 2000) && ++retry < retry_count) {\n            delay(1000);\n            time(&now);\n            localtime_r(&now, &timeinfo);\n        }\n\n        if (retry < retry_count) {\n            DateTime dt(timeinfo.tm_year + 2000, timeinfo.tm_mon + 1, timeinfo.tm_mday, timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);\n            adjust(dt);\n            context.getLogger()->info(\"Time Sync\", \"Time synchronized with NTP server\");\n        } else {\n            context.getErrorHandler()->handleError(ErrorType::CustomError, \"Failed to get time from NTP server\");\n        }\n    }\n\n};\n\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Clock\\EBPDateTime.h",
        "content": "#ifndef EBPDATETIME_H\n#define EBPDATETIME_H\n\n#include <RTClib.h>\n#include \"JalaliDateTime.h\"\n\nclass EBPDateTime : public DateTime {\npublic:\n    EBPDateTime();\n    EBPDateTime(uint16_t year, uint8_t month, uint8_t day, uint8_t hour = 0, uint8_t min = 0, uint8_t sec = 0);\n    EBPDateTime(const DateTime& dt);\n    EBPDateTime(String datestring);\n\n    bool isNull(); \n    bool isDateTimeStringValid(String strDateTime); \n    void fromString(String strDateTime);\n    String toDateTimeString();\n    String toDateString();\n    String toTimeString();\n    TimeSpan getTimeSpan(EBPDateTime _dateTime); \n    bool isInSameDate(EBPDateTime _dateTime);\n    bool isInSameDateTime(EBPDateTime _dateTime);\n    JalaliDateTime getJalaliDateTime();\n    void fromJalaliDateTime(JalaliDateTime jalaliDateTime);\n    void fromJalaliDateTime(int year, int month, int day, int hour = 0, int minute = 0, int second = 0);\n    void addToDateTime(int add_year, int add_month, int add_day, int add_hour, int add_minute, int add_second);\n    static const EBPDateTime nullDateTime();\n};\n\nEBPDateTime::EBPDateTime() : DateTime(2000, 1, 1, 0, 0, 0) {}\n\nEBPDateTime::EBPDateTime(uint16_t year, uint8_t month, uint8_t day, uint8_t hour, uint8_t min, uint8_t sec)\n    : DateTime(year, month, day, hour, min, sec) {}\n\nEBPDateTime::EBPDateTime(const DateTime& dt) : DateTime(dt) {}\n\nEBPDateTime::EBPDateTime(String datestring) \n{\n    fromString(datestring);\n}\n\nbool EBPDateTime::isNull() {\n    return (year() == 2000 && month() == 1 && day() == 1 && hour() == 0 && minute() == 0 && second() == 0);\n}\n\nbool EBPDateTime::isDateTimeStringValid(String strDateTime) {\n    // Check string length to match \"YY/MM/DD - HH:MM:SS\" format\n    if (strDateTime.length() != 17) return false;\n\n    // Validate date separators\n    if (strDateTime.charAt(2) != '/' || strDateTime.charAt(5) != '/' || strDateTime.charAt(8) != ' ' || strDateTime.charAt(11) != ':' || strDateTime.charAt(14) != ':')\n        return false;\n\n    // Validate year, month and day\n    int _year = strDateTime.substring(0, 2).toInt();\n    int _month = strDateTime.substring(3, 5).toInt();\n    int _day = strDateTime.substring(6, 8).toInt();\n    if (_year < 1300 || _year > 2000) return false;\n    if (_month < 1 || _month > 12) return false;\n    if (_day < 1 || _day > 31) return false;\n\n    // Validate hour, minute and second\n    int _hour = strDateTime.substring(10, 12).toInt();\n    int _minute = strDateTime.substring(13, 15).toInt();\n    int _second = strDateTime.substring(16, 18).toInt();\n    if (_hour < 0 || _hour > 23) return false;\n    if (_minute < 0 || _minute > 59) return false;\n    if (_second < 0 || _second > 59) return false;\n\n    // If all checks passed, the string is valid\n    return true;\n}\n\nvoid EBPDateTime::fromString(String strDateTime) {\n    // Extract and convert year, month, and day from the string\n    int year = strDateTime.substring(0, 4).toInt();\n    int month = strDateTime.substring(5, 7).toInt();\n    int day = strDateTime.substring(8, 10).toInt();\n\n    // Extract and convert hour, minute, and second from the string\n    int hour = strDateTime.substring(13, 15).toInt();\n    int minute = strDateTime.substring(16, 18).toInt();\n    int second = strDateTime.substring(19, 20).toInt();\n\n    // Assign the newly created DateTime object to this\n    *this = EBPDateTime(year, month, day, hour, minute, second);\n}\n\nString EBPDateTime::toDateTimeString() {\n    String strDateAndTime = String(year()) + \"/\" +\n        (month() < 10 ? \"0\" : \"\") + String(month()) + \"/\" +\n        (day() < 10 ? \"0\" : \"\") + String(day()) + \" - \" +\n        (hour() < 10 ? \"0\" : \"\") + String(hour()) + \":\" +\n        (minute() < 10 ? \"0\" : \"\") + String(minute()) + \":\" +\n        (second() < 10 ? \"0\" : \"\") + String(second());\n  return strDateAndTime;\n}\n\nString EBPDateTime::toDateString() {\n    char buf[11];\n    sprintf(buf, \"%04d/%02d/%02d\", year(), month(), day());\n    return String(buf);\n}\n\nString EBPDateTime::toTimeString() {\n    char buf[9];\n    sprintf(buf, \"%02d:%02d:%02d\", hour(), minute(), second());\n    return String(buf);\n}\n\nTimeSpan EBPDateTime::getTimeSpan(EBPDateTime _dateTime) {\n    return TimeSpan(DateTime::unixtime() - _dateTime.unixtime());\n}\n\nbool EBPDateTime::isInSameDate(EBPDateTime _dateTime) {\n    return (year() == _dateTime.year() && month() == _dateTime.month() && day() == _dateTime.day());\n}\n\nbool EBPDateTime::isInSameDateTime(EBPDateTime _dateTime) {\n    return (year() == _dateTime.year() && month() == _dateTime.month() && day() == _dateTime.day() && hour() == _dateTime.hour() && minute() == _dateTime.minute() && second() == _dateTime.second());\n}\n\nJalaliDateTime EBPDateTime::getJalaliDateTime() {\n    JalaliDateTime jd;\n    jd.ConvertToJalali(*this);\n    return jd;\n}\n\nvoid EBPDateTime::fromJalaliDateTime(JalaliDateTime jalaliDateTime) {\n    DateTime dt = jalaliDateTime.ConvertToGregorian();\n    *this = EBPDateTime(dt.year(), dt.month(), dt.day(), dt.hour(), dt.minute(), dt.second());\n}\n\nvoid EBPDateTime::fromJalaliDateTime(int year, int month, int day, int hour, int minute, int second) {\n    JalaliDateTime jd(year, month, day, hour, minute, second);\n    fromJalaliDateTime(jd);\n}\n\nvoid EBPDateTime::addToDateTime(int add_year, int add_month, int add_day, int add_hour, int add_minute, int add_second)\n{\n    int new_second = second() + add_second;\n    int new_minute = minute() + add_minute + new_second / 60;\n    new_second %= 60;\n    \n    int new_hour = hour() + add_hour + new_minute / 60;\n    new_minute %= 60;\n\n    int new_day = day() + add_day + new_hour / 24;\n    new_hour %= 24;\n\n    int new_month = month() + add_month;\n    int new_year = year() + add_year;\n    \n    while (new_day > 30) {  // assuming all months have 30 days\n        new_day -= 30;\n        new_month++;\n    }\n\n    while (new_month > 12) {\n        new_month -= 12;\n        new_year++;\n    }\n\n    *this = EBPDateTime(new_year, new_month, new_day, new_hour, new_minute, new_second);\n}\n\nconst EBPDateTime EBPDateTime::nullDateTime()\n{\n    return EBPDateTime(2000, 1, 1, 0, 0, 0);\n}\n#endif // EBPDATETIME_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Clock\\IClock.h",
        "content": "#ifndef ICLOCK_H\n#define ICLOCK_H\n\n#include \"RTClib.h\"\n#include \"JalaliDateTime.h\"\n#include \"EBPDateTime.h\"\n#include <time.h>\n\nclass IClock {\npublic:\n    virtual ~IClock() {}\n\n    virtual EBPDateTime now() = 0;\n    virtual JalaliDateTime nowJalali() = 0;\n    virtual void adjust(const EBPDateTime& dt) = 0;\n    virtual void syncTimeWithServer() = 0;\n    virtual void initialize() = 0;\n};\n\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Clock\\JalaliDateTime.h",
        "content": "#ifndef JALALIDATETIME_H\n#define JALALIDATETIME_H\n\n#include <RTClib.h>\n\nclass JalaliDateTime {\nprivate:\n    int year;\n    int month;\n    int day;\n    int hour;\n    int minute;\n    int second;\n    long* gregorian_to_jalali(long gy, long gm, long gd, long out[]);\n    long *jalali_to_gregorian(long jy, long jm, long jd, long out[]);\n    bool _isNull;\n\npublic:\n    // Existing constructors and conversion methods.\n\n    // New methods:\n    JalaliDateTime();  // sets to the Jalali date corresponding to 2000/1/1 12:00:00\n    JalaliDateTime(DateTime gregorian_dateTime);  // sets to the Jalali date corresponding to 2000/1/1 12:00:00\n    JalaliDateTime(int year, int month, int day, int hour, int minute, int second);\n    JalaliDateTime(int year, int month, int day);\n    bool isNull();  // check if the date is the Jalali date corresponding to 2000/1/1 12:00:00\n    bool isDateTimeStringValid(String strDateTime);  // Check if string is in format YY/MM/DD - HH:MM:SS\n    void fromString(String strDateTime);  // Fill JalaliDateTime from string in format YY/MM/DD - HH:MM:SS\n    String toDateTimeString();  // return JalaliDateTime in string in format YY/MM/DD - HH:MM:SS \n    String toDateString();  // return JalaliDateTime in string in format YY/MM/DD\n    String toTimeString();  // return JalaliDateTime in string in format HH:MM:SS\n    TimeSpan getTimeSpan(JalaliDateTime _dateTime);  // Return time span between current time and passed time in _dateTime\n    bool isInSameDate(JalaliDateTime _dateTime);  // Return true if _dateTime and current JalaliDateTime are in the same date.\n    bool isInSameDateTime(JalaliDateTime _dateTime);  // Return true if _dateTime and current JalaliDateTime are exactly the same.\n    void ConvertToJalali(DateTime dateTime);\n    DateTime ConvertToGregorian();\n};\n\nJalaliDateTime::JalaliDateTime(): JalaliDateTime(DateTime(2000, 1, 1, 0, 0, 0))\n{\n    \n}\n\nJalaliDateTime::JalaliDateTime(DateTime dateTime): _isNull(true)\n{\n    ConvertToJalali(dateTime);\n}\n\nJalaliDateTime::JalaliDateTime(int year, int month, int day, int hour, int minute, int second)\n    : year(year), month(month), day(day), hour(hour), minute(minute), second(second), _isNull(false) \n{\n\n}\n\nJalaliDateTime::JalaliDateTime(int year, int month, int day)\n    : year(year), month(month), day(day), hour(0), minute(0), second(0), _isNull(false)\n{\n\n}\n\nbool JalaliDateTime::isNull()\n{\n    return _isNull;\n}\n\nbool JalaliDateTime::isDateTimeStringValid(String strDateTime) {\n    // Check string length to match \"YY/MM/DD - HH:MM:SS\" format\n    if (strDateTime.length() != 17) return false;\n\n    // Validate date separators\n    if (strDateTime.charAt(2) != '/' || strDateTime.charAt(5) != '/' || strDateTime.charAt(8) != ' ' || strDateTime.charAt(11) != ':' || strDateTime.charAt(14) != ':')\n        return false;\n\n    // Validate year, month and day\n    int _year = strDateTime.substring(0, 2).toInt();\n    int _month = strDateTime.substring(3, 5).toInt();\n    int _day = strDateTime.substring(6, 8).toInt();\n    if (_year < 1300 || _year > 2000) return false;\n    if (_month < 1 || _month > 12) return false;\n    if (_day < 1 || _day > 31) return false;\n\n    // Validate hour, minute and second\n    int _hour = strDateTime.substring(10, 12).toInt();\n    int _minute = strDateTime.substring(13, 15).toInt();\n    int _second = strDateTime.substring(16, 18).toInt();\n    if (_hour < 0 || _hour > 23) return false;\n    if (_minute < 0 || _minute > 59) return false;\n    if (_second < 0 || _second > 59) return false;\n\n    // If all checks passed, the string is valid\n    return true;\n}\n\nvoid JalaliDateTime::fromString(String strDateTime) {\n    // Extract and convert year, month, and day from the string\n    year = strDateTime.substring(0, 2).toInt();\n    month = strDateTime.substring(3, 5).toInt();\n    day = strDateTime.substring(6, 8).toInt();\n\n    // Extract and convert hour, minute, and second from the string\n    hour = strDateTime.substring(10, 12).toInt();\n    minute = strDateTime.substring(13, 15).toInt();\n    second = strDateTime.substring(16, 18).toInt();\n}\n\nString JalaliDateTime::toDateTimeString() {\n    String strDateTime = \"\";\n\n    // Formatted YY/MM/DD - HH:MM:SS\n    strDateTime += String(year) + \"/\" + String(month) + \"/\" + String(day);\n    strDateTime += \" - \";\n    strDateTime += String(hour) + \":\" + String(minute) + \":\" + String(second);\n\n    return strDateTime;\n}\n\nString JalaliDateTime::toDateString() {\n    String strDate = \"\";\n\n    // Formatted YY/MM/DD\n    strDate += String(year) + \"/\" + String(month) + \"/\" + String(day);\n\n    return strDate;\n}\n\nString JalaliDateTime::toTimeString() {\n    String strTime = \"\";\n\n    // Formatted HH:MM:SS\n    strTime += String(hour) + \":\" + String(minute) + \":\" + String(second);\n\n    return strTime;\n}\n\nTimeSpan JalaliDateTime::getTimeSpan(JalaliDateTime _dateTime) {\n    // First, convert both Jalali dates to Gregorian DateTime\n    DateTime thisDateTime = ConvertToGregorian();\n    DateTime otherDateTime = _dateTime.ConvertToGregorian();\n\n    // Calculate difference in seconds between the two DateTime objects\n    long timeSpanSeconds = thisDateTime.unixtime() - otherDateTime.unixtime();\n\n    // Create TimeSpan object from difference and return\n    TimeSpan timeSpan(timeSpanSeconds);\n    return timeSpan;\n}\n\nbool JalaliDateTime::isInSameDate(JalaliDateTime _dateTime) {\n    // Returns true if year, month, and day are the same\n    return (year == _dateTime.year && month == _dateTime.month && day == _dateTime.day);\n}\n\nbool JalaliDateTime::isInSameDateTime(JalaliDateTime _dateTime) {\n    // Returns true if year, month, day, hour, minute, and second are the same\n    return (year == _dateTime.year && month == _dateTime.month && day == _dateTime.day &&\n            hour == _dateTime.hour && minute == _dateTime.minute && second == _dateTime.second);\n}\n\nvoid JalaliDateTime::ConvertToJalali(DateTime dateTime) {\n    long out[3];\n    gregorian_to_jalali(dateTime.year(), dateTime.month(), dateTime.day(), out);\n    year = out[0];\n    month = out[1];\n    day = out[2];\n    hour = dateTime.hour();\n    minute = dateTime.minute();\n    second = dateTime.second();\n}\n\nDateTime JalaliDateTime::ConvertToGregorian() {\n    long out[3];\n    jalali_to_gregorian(year, month, day, out);\n    return DateTime(out[0], out[1], out[2], hour, minute, second);\n}\n\nlong *JalaliDateTime::gregorian_to_jalali(long gy, long gm, long gd, long out[]) {\n    long days;\n    {\n        long gy2 = (gm > 2) ? (gy + 1) : gy;\n        long g_d_m[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\n        days = 355666 + (365 * gy) + ((int)((gy2 + 3) / 4)) - ((int)((gy2 + 99) / 100)) + ((int)((gy2 + 399) / 400)) + gd + g_d_m[gm - 1];\n    }\n    long jy = -1595 + (33 * ((int)(days / 12053)));\n    days %= 12053;\n    jy += 4 * ((int)(days / 1461));\n    days %= 1461;\n    if (days > 365) {\n        jy += (int)((days - 1) / 365);\n        days = (days - 1) % 365;\n    }\n    out[0] = jy;\n    if (days < 186) {\n        out[1]/*jm*/ = 1 + (int)(days / 31);\n        out[2]/*jd*/ = 1 + (days % 31);\n    } else {\n        out[1]/*jm*/ = 7 + (int)((days - 186) / 30);\n        out[2]/*jd*/ = 1 + ((days - 186) % 30);\n    }\n    return out;\n}\n\nlong *JalaliDateTime::jalali_to_gregorian(long jy, long jm, long jd, long out[]) {\n    jy += 1595;\n    long days = -355668 + (365 * jy) + (((int)(jy / 33)) * 8) + ((int)(((jy % 33) + 3) / 4)) + jd + ((jm < 7) ? (jm - 1) * 31 : ((jm - 7) * 30) + 186);\n    long gy = 400 * ((int)(days / 146097));\n    days %= 146097;\n    if (days > 36524) {\n        gy += 100 * ((int)(--days / 36524));\n        days %= 36524;\n        if (days >= 365) days++;\n    }\n    gy += 4 * ((int)(days / 1461));\n    days %= 1461;\n    if (days > 365) {\n        gy += (int)((days - 1) / 365);\n        days = (days - 1) % 365;\n    }\n    long gd = days + 1;\n    long gm;\n    {\n        long sal_a[13] = {0, 31, ((gy % 4 == 0 && gy % 100 != 0) || (gy % 400 == 0)) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n        for (gm = 0; gm < 13 && gd > sal_a[gm]; gm++) gd -= sal_a[gm];\n    }\n    out[0] = gy;\n    out[1] = gm;\n    out[2] = gd;\n    return out;\n}\n\n#endif  // JALALIDATETIME_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Config\\Configs.h",
        "content": "#ifndef CONFIGS_H\n#define CONFIGS_H\n\n#include \"IConfigs.h\"\n#include \"System/SystemConfig.h\"\n#include \"Security/SecurityConfig.h\"\n#include \"../Context.h\"\n\nclass Configs : public IConfigs\n{\nprivate:\n    Context* context;\n    SystemConfig* systemConfig;\n    SecurityConfig* securityConfig;\n    \npublic:\n    Configs(Context* cntxt);\n    void initialize();\n    IConfig* getSystemConfig() override;\n    IConfig* getSecurityConfig() override;\n};\n\nConfigs::Configs(Context* cntxt) : context(cntxt)\n{\n\n}\n\nvoid Configs::initialize()\n{\n    securityConfig = new SecurityConfig(context);\n    systemConfig = new SystemConfig(context);\n\n    securityConfig->initialize();\n    systemConfig->initialize();\n}\n\nIConfig* Configs::getSystemConfig()\n{\n    return systemConfig;\n}\n\nIConfig* Configs::getSecurityConfig()\n{\n    return securityConfig;\n}\n\n\n\n\n#endif //CONFIGS_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Config\\IConfig.h",
        "content": "#ifndef ISYSTEMCONFIG_H\n#define ISYSTEMCONFIG_H\n\n#include <Arduino.h>\n\nclass IConfig {\npublic:\n    virtual void initialize() = 0;\n    virtual String get(const String& key) = 0;\n    virtual void set(const String& key, const String& value) = 0;\n};\n\n#endif // ISYSTEMCONFIG_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Config\\IConfigs.h",
        "content": "#ifndef ICONFIG_H\n#define ICONFIG_H\n\n#include \"IConfig.h\"\n\nclass IConfigs\n{\npublic:\n    virtual void initialize() = 0;\n    virtual IConfig* getSystemConfig() = 0;\n    virtual IConfig* getSecurityConfig() = 0;\n};\n\n\n#endif //ICONFIG_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Config\\StaticConfigs.h",
        "content": "#ifndef STATICCONFIGS_H\n#define STATICCONFIGS_H\n\n#include <Arduino.h>\n\nclass StaticConfigs {\npublic:\n    // Database configuration\n    static constexpr const char* DATABASE_PATH = \"/\";\n\n    // Serial communication configuration\n    static constexpr long SERIAL_BAUD_RATE = 115200;\n\n    // Wi-Fi configuration\n    static constexpr const char* AP_SSID = \"your_ssid\";\n    static constexpr const char* AP_PASSWORD = \"your_password\";\n\n    // Web server configuration\n    static constexpr uint16_t WEB_SERVER_PORT = 80;\n\n    // Other configurations can be added as needed\n};\n\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Config\\Security\\DefaultSecurityConfigs.h",
        "content": "\n#ifndef DEFAULTAUTHENTICATION_H\n#define DEFAULTAUTHENTICATION_H\n\n#include <Arduino.h>\n#include <ArduinoJson.h>\n\nclass DefaultSecurityConfigs {\n\npublic:\n    static const String jsonString;\n    static String get(String key);\n};\n\nString DefaultSecurityConfigs::get(String key) {\n    StaticJsonDocument<1024> doc;\n    DeserializationError error = deserializeJson(doc, jsonString);\n\n    if (error) {\n        Serial.println(F(\"Failed to parse jsonString\"));\n        Serial.println(jsonString);\n        return \"\";\n    }\n\n    if (doc.containsKey(key)) {\n        return String(doc[key].as<const char *>());\n    } else {\n        Serial.print(F(\"Key not found in Security Config: \"));\n        Serial.println(key);\n        return \"\";\n    }\n}\n\nconst String DefaultSecurityConfigs::jsonString = R\"(\n{\n    \"authentication_enable\" : \"false\",\n    \"2fa_enable\" : \"false\",\n    \"2fa_email_enable\" : \"false\",\n    \"2fa_sms_enable\" : \"false\",\n    \"access_with_api_key\" : \"true\",\n    \"rst_pswd_with_sms\" : \"false\",\n    \"rst_pswd_with_email\" : \"false\",\n    \"rst_pswd_with_button\" : \"true\",\n    \"rst_pswd_by_sec_qustn\" : \"true\",\n    \"rst_pswd_expire_hour\" : \"24\",\n    \"login_attempt_count\" : \"10\",\n    \"lock_user_login_attempt\" : \"false\",\n    \"lock_user_minute\" : \"30\",\n    \"two_factor_auth_expire_hour\" : \"24\",\n    \"log_account_activity\" : \"true\",\n    \"token_active_day\" : \"5\"\n}\n)\";\n\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Config\\Security\\SecurityConfig.h",
        "content": "\n#ifndef AUTHENTICATIONCONFIGS_H\n#define AUTHENTICATIONCONFIGS_H\n\n#include <string>\n#include \"DefaultSecurityConfigs.h\"\n#include \"../../Context.h\"\n#include \"../../Database/Controllers/Security/AuthenticationConfigController.h\"\n#include \"SecurityConfigKeys.h\"\n\nclass SecurityConfig : public IConfig {\n\nprivate:\n    AuthenticationConfigController* authenticationConfigController;\n\npublic:\n    Context* context;\n    SecurityConfig(Context* cntxt):context (cntxt) {\n    }\n    \n    void initialize() {\n        authenticationConfigController = new AuthenticationConfigController(context, storageType);\n    }\n\n    String get(const String& key) {\n        std::vector<KeyValueEntity> authenticationConfigEntities  = authenticationConfigController->Get(KeyValueEntity::COLUMN_KEY + \"=\" + key);\n        \n        if (authenticationConfigEntities.size() > 0)\n        {\n            KeyValueEntity configEntity = authenticationConfigEntities.at(0);\n            configEntity.fromString(configEntity.toString());\n            if (configEntity.id == -1) {\n                return \"\";\n            } else {\n                return configEntity.getValue();\n            }\n        }\n        else\n        {\n            KeyValueEntity* keyValueEntity = new KeyValueEntity(key,DefaultSecurityConfigs::get(key));\n            authenticationConfigController->Add(*keyValueEntity);\n            return DefaultSecurityConfigs::get(key);\n        }\n    }\n\n    void set(const String& key, const String& value) {\n        KeyValueEntity configEntity = authenticationConfigController->Get(KeyValueEntity::COLUMN_KEY + \"=\" + key).at(0);\n        if (configEntity.id == -1) { // Key does not exist\n            configEntity.setKey(key);\n            configEntity.setValue(value);\n            authenticationConfigController->Add(configEntity);\n        } else { // Key exists\n            configEntity.setValue(value);\n            authenticationConfigController->Update(configEntity);\n        }\n    }\n\n};\n\n#endif // AUTHENTICATION_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Config\\Security\\SecurityConfigKeys.h",
        "content": "\n#ifndef AUTHENTICATIONCONFIGKEYS_H\n#define AUTHENTICATIONCONFIGKEYS_H\n\nclass SecurityConfigKey\n{\nprivate:\n\npublic:\n    static const String AUTHENTICATION_ENABLE;\n    static const String TWO_FACTOR_AUTHENTICATION_ENABLE;\n    static const String TWO_FACTOR_AUTHENTICATION_EMAIL_ENABLE;\n    static const String TWO_FACTOR_AUTHENTICATION_SMS_ENABLE;\n    static const String ACCESS_WITH_API_KEY;\n    static const String RESET_PASSWORD_WITH_SMS;\n    static const String RESET_PASSWORD_WITH_EMAIL;\n    static const String RESET_PASSWORD_WITH_BUTTON;\n    static const String RESET_PASSWORD_WITH_SECURITY_QUESTION;\n    static const String RESET_PASSWORD_EXPIRE_HOUR;\n    static const String LOGIN_ATTEMPT_COUNT;\n    static const String LOCK_USER_LOGIN_ATTEMPT;\n    static const String LOCK_USER_MINUTE;\n    static const String TOKEN_ACTIVE_DAY;\n    static const String TWO_FACTOR_AUTH_EXPIRE_HOUR;\n    static const String LOG_ACCOUNT_ACTIVITY;\n};\n\nconst String SecurityConfigKey::AUTHENTICATION_ENABLE = \"authentication_enable\";\nconst String SecurityConfigKey::TWO_FACTOR_AUTHENTICATION_ENABLE = \"2fa_enable\";\nconst String SecurityConfigKey::TWO_FACTOR_AUTHENTICATION_EMAIL_ENABLE = \"2fa_email_enable\";\nconst String SecurityConfigKey::TWO_FACTOR_AUTHENTICATION_SMS_ENABLE = \"2fa_sms_enable\";\nconst String SecurityConfigKey::ACCESS_WITH_API_KEY = \"access_with_api_key\";\nconst String SecurityConfigKey::RESET_PASSWORD_WITH_SMS = \"rst_pswd_with_sms\";\nconst String SecurityConfigKey::RESET_PASSWORD_WITH_EMAIL = \"rst_pswd_with_email\";\nconst String SecurityConfigKey::RESET_PASSWORD_WITH_BUTTON = \"rst_pswd_with_button\";\nconst String SecurityConfigKey::RESET_PASSWORD_WITH_SECURITY_QUESTION = \"rst_pswd_by_sec_qustn\";\nconst String SecurityConfigKey::RESET_PASSWORD_EXPIRE_HOUR = \"rst_pswd_expire_hour\";\nconst String SecurityConfigKey::LOGIN_ATTEMPT_COUNT = \"login_attempt_count\";\nconst String SecurityConfigKey::LOCK_USER_LOGIN_ATTEMPT = \"lock_user_login_attempt\";\nconst String SecurityConfigKey::LOCK_USER_MINUTE = \"lock_user_minute\";\nconst String SecurityConfigKey::TWO_FACTOR_AUTH_EXPIRE_HOUR = \"two_factor_auth_expire_hour\";\nconst String SecurityConfigKey::LOG_ACCOUNT_ACTIVITY = \"log_account_activity\";\nconst String SecurityConfigKey::TOKEN_ACTIVE_DAY = \"token_active_day\";\n\n#endif // AUTHENTICATIONCONFIGKEYS_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Config\\System\\DefaultSystemConfigs.h",
        "content": "#ifndef DEFAULTCONFIGS_H\n#define DEFAULTCONFIGS_H\n\n#include <Arduino.h>\n#include <ArduinoJson.h>\n\nclass DefaultSystemConfigs {\n  public:\n    static const String jsonString;\n\n    static String get(String key);\n};\n\nString DefaultSystemConfigs::get(String key) {\n    StaticJsonDocument<1024> doc;\n    DeserializationError error = deserializeJson(doc, jsonString);\n\n    if (error) {\n    Serial.println(F(\"Failed to parse jsonString\"));Serial.println(key);\n    return \"\";\n    }\n\n    if (doc.containsKey(key)) {\n    return String(doc[key].as<const char *>());\n    } else {\n    return \"\";\n    }\n}\nconst String DefaultSystemConfigs::jsonString = R\"(\n{\n    \"db_change_info_save\" : \"false\",\n    \"system_boot_info_save\" : \"true\",\n    \"relay_state_changed_info_save\" : \"true\",\n    \"wifi_mode_mesh\" : \"false\",\n    \"wifi_mode_ap\" : \"true\",\n    \"wifi_mode_wifi\" : \"false\",\n    \"ap_ssid\" : \"LevinBoard\",\n    \"ap_password\" : \"12345678\",\n    \"channel\" : \"1\",\n    \"ssid_hidden\" : \"false\",\n    \"max_connection\" : \"6\",\n    \"mesh_root\" : \"false\",\n    \"clock_type\" : \"DS3231\",\n    \"storage_type\" : \"SPIFFS_TYPE\",\n    \"sd_pin\" : \"26\",\n    \"https_enable\" : \"true\",\n    \"default_username\" : \"admin\",\n    \"default_password\" : \"admin\"\n}\n)\";\n\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Config\\System\\SystemConfig.h",
        "content": "#ifndef SYSTEMCONFIG_H\n#define SYSTEMCONFIG_H\n\n#include <string>\n#include \"../../Database/Controllers/SystemConfigController.h\"\n#include \"../../Database/Entities/KeyValueEntity.h\"\n#include \"../IConfig.h\"\n#include \"DefaultSystemConfigs.h\"\n#include \"SystemConfigKeys.h\"\n#include \"../../Context.h\"\n\nclass SystemConfig : public IConfig {\n\nprivate:\n    Context* context;\n    SystemConfigController* configController;\n\npublic:\n    SystemConfig(Context* cntxt);\n    void initialize() override;\n    String get(const String& key) override;\n    void set(const String& key, const String& value) override;\n};\n\nSystemConfig::SystemConfig(Context* cntxt):context (cntxt) {\n}\n\nvoid SystemConfig::initialize() {\n    configController = new SystemConfigController(context, storageType);\n}\n\nString SystemConfig::get(const String& key) {\n    \n    std::vector<KeyValueEntity> systemConfigEntities  = configController->Get(KeyValueEntity::COLUMN_KEY + \"=\" + key);\n    \n    if (systemConfigEntities.size() > 0)\n    {\n        KeyValueEntity configEntity = systemConfigEntities.at(0);\n        configEntity.fromString(configEntity.toString());\n        if (configEntity.id == -1) {\n            return \"\";\n        } else {\n            return configEntity.getValue();\n        }\n    }\n    else\n    {\n        KeyValueEntity* systemConfigEntity = new KeyValueEntity(key,DefaultSystemConfigs::get(key));\n        \n        configController->Add(*systemConfigEntity);\n        return DefaultSystemConfigs::get(key);\n    }\n}\n\nvoid SystemConfig::set(const String& key, const String& value) {\n    KeyValueEntity configEntity = configController->Get(KeyValueEntity::COLUMN_KEY + \"=\" + key).at(0);\n    if (configEntity.id == -1) { // Key does not exist\n        configEntity.setKey(key);\n        configEntity.setValue(value);\n        configController->Add(configEntity);\n    } else { // Key exists\n        configEntity.setValue(value);\n        configController->Update(configEntity);\n    }\n}\n\n#endif // SYSTEMCONFIG_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Config\\System\\SystemConfigKeys.h",
        "content": "#ifndef CONFIGKEYS_h\n#define CONFIGKEYS_h\n\nclass SystemConfigKey\n{\nprivate:\n    \npublic:\n    static const String DB_CHANGE_INFO_SAVE;\n\n    static const String WIFI_MODE_MESH;\n    static const String WIFI_MODE_AP;\n    static const String WIFI_MODE_WIFI;\n    static const String AP_SSID;\n    static const String AP_PASSWORD;\n    static const String CHANNEL;\n    static const String SSID_HIDDEN;\n    static const String MAX_CONNECTION;\n    static const String MESH_ROOT;\n    static const String CLOCK_TYPE;\n    static const String STORAGE_TYPE;\n    static const String SD_PIN;\n    static const String HTTPS_ENABLE;\n    static const String DEFAULT_USERNAME;\n    static const String DEFAULT_PASSWORD;\n};\n\n//Database keys\nconst String SystemConfigKey::DB_CHANGE_INFO_SAVE = \"db_change_info_save\";\n\n\n//Network keys\nconst String SystemConfigKey::WIFI_MODE_MESH = \"wifi_mode_mesh\";\nconst String SystemConfigKey::WIFI_MODE_AP = \"wifi_mode_ap\";\nconst String SystemConfigKey::WIFI_MODE_WIFI = \"wifi_mode_wifi\";\nconst String SystemConfigKey::AP_SSID = \"ap_ssid\";\nconst String SystemConfigKey::AP_PASSWORD = \"ap_password\";\nconst String SystemConfigKey::CHANNEL = \"channel\";\nconst String SystemConfigKey::SSID_HIDDEN = \"ssid_hidden\";\nconst String SystemConfigKey::MAX_CONNECTION = \"max_connection\";\nconst String SystemConfigKey::MESH_ROOT = \"mesh_root\";\nconst String SystemConfigKey::CLOCK_TYPE = \"clock_type\";\nconst String SystemConfigKey::STORAGE_TYPE = \"storage_type\";\nconst String SystemConfigKey::SD_PIN = \"sd_pin\";\nconst String SystemConfigKey::HTTPS_ENABLE = \"https_enable\";\nconst String SystemConfigKey::DEFAULT_USERNAME = \"default_username\";\nconst String SystemConfigKey::DEFAULT_PASSWORD = \"default_password\";\n\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\IController.h",
        "content": "#ifndef ICONTROLLER_H\n#define ICONTROLLER_H\n\n#include <vector>\n#include <string>\n\ntemplate<typename T>\nclass IController {\npublic:\n\n    virtual void RemoveTable() = 0;\n\n    virtual void removeColumn(const String column_name) = 0;\n\n    virtual int Add(T& entity) = 0;\n\n    virtual bool Update(T& entity) = 0;\n\n    virtual bool Delete(int id) = 0;\n\n    virtual T GetById(int id) = 0;\n\n    virtual std::vector<T> GetAll() = 0;\n\n    virtual String GetAllJson() = 0;\n\n    virtual std::vector<T> Get(const String query) = 0;\n    \n    virtual String GetJson(String query) = 0;\n};\n\n#endif // ICONTROLLER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\LogController.h",
        "content": "// path: .\\src\\Basic\\Database\\Controllers\\LogController.h\n\n#ifndef BASELOGCONTROLLER_H\n#define BASELOGCONTROLLER_H\n\n#include \"../Entities/LogEntitiy.h\"\n#include \"MainController.h\"\n#include <Arduino.h>\n#include <vector>\n\n\nclass LogController : public MainController<LogEntity>{\nprotected:\n    Context* context;\npublic:\n    LogController(Context* context, StorageType _storageType) : MainController(context, \"logs\", _storageType), context(context) {}\n    void AddLog(LogEntity::LogType logType, String logTitle, String logMessage, String timestamp);\n    std::vector<LogEntity> GetAllLogs();\n};\n\nvoid LogController::AddLog(LogEntity::LogType logType, String logTitle, String logMessage, String timestamp) {\n    LogEntity logEntity = LogEntity();\n    logEntity.logType = logType;\n    logEntity.logTitle = logTitle;\n    logEntity.message = logMessage;\n    logEntity.timestamp = timestamp;\n    Add(logEntity);\n}\n\nstd::vector<LogEntity> LogController::GetAllLogs() {\n    std::vector<LogEntity> logs = GetAll();    \n    return logs;\n}\n\n#endif // BASELOGCONTROLLER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\MainController.h",
        "content": "#ifndef MAINCONTROLLER_H\n#define MAINCONTROLLER_H\n\n#include <vector>\n#include <string>\n#include <ArduinoJson.h>\n#include \"IController.h\"\n#include \"../../Config/StaticConfigs.h\"\n#include \"../../Context.h\"\n#include \"../../Logging/LogTitles.h\"\n\ntemplate<typename T>\nclass MainController : public IController<T> {\nprivate:\npublic:\n    Context* context;\n    String path;\n    String _tableName;\n    StorageType _storageType;\n\n    MainController(Context* context, String tableName, StorageType _storageType) : context(context), _storageType(_storageType){\n        _tableName = tableName;\n        path = String(StaticConfigs::DATABASE_PATH + _tableName + \".db\");\n    }\n\n\n\nvoid RemoveTable()\n{\n  if (!(_storageType == StorageType::SPIFFS_TYPE ? context->getLittleFS() : context->getSD())->exists(path)) {\n        context->getErrorHandler()->handleError(ErrorType::TableDoesNotExist);\n        return;\n  }\n    (_storageType == StorageType::SPIFFS_TYPE ? context->getLittleFS() : context->getSD())->remove(path);\n    context->getLogger()->infoDB(_tableName, LogTitles::REMOVE_TABLE, LogTitles::REMOVE_TABLE_FROM_DB + \" - table = \" + _tableName);\n}\n\n\nvoid removeColumn(const String column_name) {\n    if (!context->getValidation()->isColumnNameValid(column_name)) {\n        context->getErrorHandler()->handleError(ErrorType::InvalidColumnName);\n        return;\n    }\n\n    std::vector<T> entities = GetAll();\n    for (size_t i = 0; i < entities.size(); i++) {\n        entities.at(i).removeColumn(column_name);\n    }\n\n    IEBPFile* file = (_storageType == StorageType::SPIFFS_TYPE ? context->getLittleFS() : context->getSD())->open(path, \"w\");\n    for (size_t i = 0; i < entities.size(); i++) {\n        file->println(entities.at(i).toString());\n    }\n    file->close();\n    context->getLogger()->infoDB(_tableName, LogTitles::REMOVE_COLUMN, LogTitles::REMOVE_COLUMN_FROM_DB + \" - column = \" + column_name + \" from table \" + _tableName);\n}\n\n\nint Add(T& entity) {\n\n  int entity_id = -1;\n    T e{};\n    entity.createDate = context->getClock()->now();\n    // entity.createDate = EBPDateTime(2000,1,1,0,0,0);    \n    e.fromString(entity.toString());\n    if (e.id == -1 || e.id == 0) {\n        int maxId = 0;\n        std::vector<T> entities = GetAll();\n        for (size_t i = 0; i < entities.size(); i++) {\n            if (entities.at(i).id > maxId) {\n                maxId = entities.at(i).id;\n            }\n        }\n        e.id = maxId + 1;\n        entity_id = e.id;\n        e.createDate = context->getClock()->now();\n    } else {\n        T existing_entity = GetById(e.id);\n        if (existing_entity.id != -1) {\n          context->getErrorHandler()->handleError(ErrorType::CustomError, \"Entity with the same ID already exists\");\n          return -1;\n        }\n    }\n    IEBPFile* file = (_storageType == StorageType::SPIFFS_TYPE ? context->getLittleFS() : context->getSD())->open(path, \"a\");\n    file->println(e.toString());\n    file->close();\n    \n    context->getLogger()->infoDB(_tableName, LogTitles::ADD, LogTitles::ADD_RECORD_TO_DB + \" - id = \" + String(entity_id));\n    return entity_id;\n}\n\n\nbool Update(T& entity) {\n    // T e = entity.toEntity();\n    std::vector<T> entities = GetAll();\n    bool entity_found = false;\n    for (size_t i = 0; i < entities.size(); i++) {\n        if (entities.at(i).id == entity.id) {\n            entities.at(i) = entity;\n            entity_found = true;\n            break;\n        }\n    }\n\n    if (!entity_found) {\n        context->getErrorHandler()->handleError(ErrorType::CustomError, \"Entity not found\");\n        return false;\n    }\n\n    IEBPFile* file = (_storageType == StorageType::SPIFFS_TYPE ? context->getLittleFS() : context->getSD())->open(path, \"w\");\n    for (size_t i = 0; i < entities.size(); i++) {\n        file->println(entities.at(i).toString());\n    }\n    file->close();\n    \n    context->getLogger()->infoDB(_tableName, LogTitles::UPDATE, LogTitles::UPDATE_RECORD_IN_DB + \" - id = \" + String(entity.id));\n    return true;\n}\n\n\nbool Delete(int id) {\n    std::vector<T> entities = GetAll();\n    bool entity_found = false;\n    for (size_t i = 0; i < entities.size(); i++) {\n        if (entities.at(i).id == id) {\n            entities.erase(entities.begin() + i);\n            entity_found = true;\n            break;\n        }\n    }\n\n    if (!entity_found) {\n        context->getErrorHandler()->handleError(ErrorType::CustomError, \"Entity not found\");\n        return false;\n    }\n\n    IEBPFile* file = (_storageType == StorageType::SPIFFS_TYPE ? context->getLittleFS() : context->getSD())->open(path, \"w\");\n    for (size_t i = 0; i < entities.size(); i++) {\n        file->println(entities.at(i).toString());\n    }\n    file->close();\n    context->getLogger()->infoDB(_tableName, LogTitles::DELETE, LogTitles::DELETE_RECORD_FROM_DB + \" - id = \" + String(id));\n    return true;\n}\n\n\nT GetById(int id) {\n    IEBPFile* file = (_storageType == StorageType::SPIFFS_TYPE ? context->getLittleFS() : context->getSD())->open(path, \"r\");\n    if (!file) {\n        context->getErrorHandler()->handleError(ErrorType::FileOpenError);\n        return T::fromEntity(T::Invalid());\n    }\n\n    String line;\n    while (file->available()) {\n        line = file->readStringUntil('\\n');\n        T entity{};\n        entity.fromString(line);\n        if (entity.id == id) {\n            file->close();\n            return T::fromEntity(entity);\n        }\n    }\n    file->close();\n    return T::fromEntity(T::Invalid());\n}\n\nstd::vector<T> GetAll() {\n    std::vector<T> entities;\n  if(_storageType == StorageType::SPIFFS_TYPE)\n  {\n    \n    if(context->getLittleFS()->exists(path))\n    {\n    }\n    \n  }\n    if(!(_storageType == StorageType::SPIFFS_TYPE ? context->getLittleFS() : context->getSD())->exists(path))\n    {\n      return entities;\n    }\n    IEBPFile* file = (_storageType == StorageType::SPIFFS_TYPE ? context->getLittleFS() : context->getSD())->open(path, \"r\");\n    if (!file) {\n        context->getErrorHandler()->handleError(ErrorType::FileOpenError);\n        return entities;\n    }\n\n    String line;\n    while (file->available()) {\n        line = file->readStringUntil('\\n');\n        T entity{};\n        entity.fromString(line);\n        entities.push_back(entity);\n    }\n    file->close();\n    return entities;\n}\n\n\nString GetAllJson() {\n    std::vector<T> entities = GetAll();\n    String result = \"[\";\n    for (size_t i = 0; i < entities.size(); i++) {\n        result += entities.at(i).toJson();\n        if (i < entities.size() - 1) {\n            result += \",\";\n        }\n    }\n    result += \"]\";\n    return result;\n}\n\n\nString GetJson(String query) {\n    std::vector<T> entities = Get(query);\n    String result = \"[\";\n    for (size_t i = 0; i < entities.size(); i++) {\n        result += entities.at(i).toJson();\n        if (i < entities.size() - 1) {\n            result += \",\";\n        }\n    }\n    result += \"]\";\n    return result;\n}\n\n\nstd::vector<T> Get(const String query) {\n\n  std::vector<T> entities;\n  if (_storageType == StorageType::SPIFFS_TYPE)\n  {\n    if(!LittleFS.exists(path))\n    {\n      return entities;\n    }\n  }else{\n    if (!SD.exists(path))\n    {\n      return entities;\n    }\n    \n  }\n  \n  \n  IEBPFile* file = (_storageType == StorageType::SPIFFS_TYPE ? context->getLittleFS() : context->getSD())->open(path, \"r\");\n  if (!file) {\n    context->getErrorHandler()->handleError(ErrorType::FileOpenError);\n    return entities;\n  }\n  while (file->available()) {\n    String str = file->readStringUntil('\\n');\n    T entity{};\n    entity.fromString(str);\n    bool matches = true;\n    int pos = 0;\n    while (pos < query.length()) {\n      int and_pos = query.indexOf(\" AND \", pos);\n      if (and_pos == -1) {\n        and_pos = query.length();\n      }\n      String condition = query.substring(pos, and_pos);\n      int operator_pos = -1;\n      if (condition.indexOf('=') != -1) {\n        operator_pos = condition.indexOf('=');\n      } else if (condition.indexOf('>') != -1) {\n        operator_pos = condition.indexOf('>');\n      } else if (condition.indexOf('<') != -1) {\n        operator_pos = condition.indexOf('<');\n      }\n\n      if (operator_pos == -1) {\n        context->getErrorHandler()->handleError(ErrorType::InvalidQuery);\n        matches = false;\n        break;\n      }\n\n      String column_name = condition.substring(0, operator_pos);\n      if (!context->getValidation()->isColumnNameValid(column_name)) {\n        context->getErrorHandler()->handleError(ErrorType::InvalidQuery);\n        matches = false;\n        break;\n      }\n\n      String value = condition.substring(operator_pos + 1);\n      String entity_value = entity.GetValue(column_name);\n      if (condition[operator_pos] == '=') {\n        if (entity_value != value) {\n          matches = false;\n          break;\n        }\n      } else if (condition[operator_pos] == '>') {\n        if (entity_value <= value) {\n          matches = false;\n          break;\n        }\n      } else if (condition[operator_pos] == '<') {\n        if (entity_value >= value) {\n          matches = false;\n          break;\n        }\n      }\n      pos = and_pos + 5;\n    }\n\n    if (matches) {\n      entities.push_back(entity);\n    }\n  }\n  file->close();\n  return entities;\n}\n};\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\SystemConfigController.h",
        "content": "#ifndef SYSTEMCONFIGCONTROLLER_H\n#define SYSTEMCONFIGCONTROLLER_H\n\n#include \"../Entities/KeyValueEntity.h\"\n#include \"MainController.h\"\n\nclass SystemConfigController : public MainController<KeyValueEntity>{\nprotected:\n    Context* context;\npublic:\n    SystemConfigController(Context* context, StorageType _storageType) : MainController<KeyValueEntity>(context ,\"system_config\", _storageType), context(context) {}    \n};\n\n\n#endif // SYSTEMCONFIGCONTROLLER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\WiFiConroller.h",
        "content": "#ifndef WIFICONTROLLER_H\n#define WIFICONTROLLER_H\n\n#include \"../Entities/WiFiEntity.h\"\n#include \"MainController.h\"\n\nclass WiFiController : public MainController<WiFiEntity> {\nprotected:\n    Context* context;\npublic:\n    WiFiController(Context* context, StorageType _storageType) : MainController<WiFiEntity>(context, \"wifi\", _storageType), context(context) {}\n};\n\n#endif // WIFICONTROLLER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Modules\\ButtonController.h",
        "content": "#ifndef BUTTONCONTROLLER_H\n#define BUTTONCONTROLLER_H\n\n#include \"../../Entities/Modules/ButtonEntity.h\"\n#include \"../MainController.h\"\n\nclass ButtonController : public MainController<ButtonEntity> {\nprotected:\n    Context* context;\npublic:\n    ButtonController(Context* context, StorageType _storageType) : MainController<ButtonEntity>(context, \"button\", _storageType), context(context) {}\n};\n\n#endif // BUTTONCONTROLLER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Modules\\DHTController.h",
        "content": "#ifndef DHTCONTROLLER_H\n#define DHTCONTROLLER_H\n\n#include \"../../Entities/Modules/DHTEntity.h\"\n#include \"../MainController.h\"\n\nclass DHTController : public MainController<DHTEntity> {\nprotected:\n    Context* context;\npublic:\n    DHTController(Context* context, StorageType _storageType) : MainController<DHTEntity>(context, \"dht\", _storageType), context(context) {}\n};\n\n#endif // DHTCONTROLLER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Modules\\LCDController.h",
        "content": "#ifndef LCDCONTROLLER_H\n#define LCDCONTROLLER_H\n\n#include \"../../Entities/Modules/LCDEntity.h\"\n#include \"../MainController.h\"\n\nclass LCDController : public MainController<LCDEntity> {\nprotected:\n    Context* context;\npublic:\n    LCDController(Context* context, StorageType _storageType) : MainController<LCDEntity>(context, \"lcd\", _storageType), context(context) {}\n};\n\n#endif // LCDCONTROLLER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Modules\\ModulesController.h",
        "content": "#ifndef MODULESCONTROLLER_H\n#define MODULESCONTROLLER_H\n\n#include \"../../Entities/Modules/ModuleEntity.h\"\n#include \"../../Entities/Modules/ButtonFullEntity.h\"\n#include \"../../Entities/Modules/ButtonEntity.h\"\n#include \"ButtonController.h\"\n\n#include \"../../Entities/Modules/RelayFullEntity.h\"\n#include \"../../Entities/Modules/RelayEntity.h\"\n#include \"RelayController.h\"\n\n#include \"../../Entities/Modules/LCDFullEntity.h\"\n#include \"../../Entities/Modules/LCDEntity.h\"\n#include \"LCDController.h\"\n\n#include \"../../Entities/Modules/DHTFullEntity.h\"\n#include \"../../Entities/Modules/DHTEntity.h\"\n#include \"DHTController.h\"\n\n#include \"../../Entities/Modules/RGBFullEntity.h\"\n#include \"../../Entities/Modules/RGBEntity.h\"\n#include \"RGBController.h\"\n\n#include \"../../Entities/Modules/PhotoresistorFullEntity.h\"\n#include \"../../Entities/Modules/PhotoresistorEntity.h\"\n#include \"PhotoresistorController.h\"\n\n#include \"../../Entities/Modules/SoilMoistureFullEntity.h\"\n#include \"../../Entities/Modules/SoilMoistureEntity.h\"\n#include \"SoilMoistureController.h\"\n\n#include \"../MainController.h\"\n\nclass ModulesController : public MainController<ModuleEntity> {\n    private:\n        Context* context;\n        ButtonController* buttonController;\n    public:\n        ModulesController(Context* context, StorageType _storageType);\n        std::vector<ButtonFullEntity> getAllButtons();\n        ButtonFullEntity getButtonByName(String name);\n        int AddButton(ButtonFullEntity button);\n        std::vector<RelayFullEntity> getAllRelays();\n        int AddRelay(RelayFullEntity relay);\n        std::vector<LCDFullEntity> getAllLCDs();\n        int AddLCD(LCDFullEntity lcd);\n        std::vector<DHTFullEntity> getAllDHTs();\n        void AddDHT(DHTFullEntity dht);\n        std::vector<RGBFullEntity> getAllRGBs();\n        void AddRGB(RGBFullEntity rgb);\n        std::vector<PhotoresistorFullEntity> getAllPhotoresistors();\n        void AddPhotoresistor(PhotoresistorFullEntity photoresistor);\n        std::vector<SoilMoistureFullEntity> getAllSoilMoistures();\n        void AddSoilMoisture(SoilMoistureFullEntity soilMoisture);\n};\n\nModulesController::ModulesController(Context* context, StorageType _storageType) : MainController<ModuleEntity>(context, \"modules\", _storageType), context(context) \n{\n\n}\n\nButtonFullEntity ModulesController::getButtonByName(String name)\n{\n    buttonController = new ButtonController(context, _storageType);\n    ButtonFullEntity fullButton;\n    std::vector<ModuleEntity> modules = GetAll();\n    for (size_t i = 0; i < modules.size(); i++)\n    {\n        ModuleEntity _module = modules.at(i);\n    _module.fromString(_module.toString());\n        if (_module.GetValue(ModuleEntity::COLUMN_MODULE_TYPE) == ModuleTypes::BUTTON && _module.GetValue(ModuleEntity::COLUMN_NAME) == name)\n        {\n            ButtonEntity _button = buttonController->GetById(_module.id);\n    _button.fromString(_button.toString());\n            fullButton = ButtonFullEntity(_module.id, _button.id, _module.GetValue(ModuleEntity::COLUMN_NAME), _module.GetValue(ModuleEntity::COLUMN_MODULE_TYPE), _module.GetValue(ModuleEntity::COLUMN_CONNECTION_TYPE), _module.GetValue(ModuleEntity::COLUMN_NODE_ID).toInt(), \n            _module.GetValue(ModuleEntity::COLUMN_PIN_NUMBER).toInt(), _button.GetValue(ButtonEntity::COLUMN_BUTTON_TYPE), _button.GetValue(ButtonEntity::COLUMN_ACTIVE_HIGH).toInt(), _button.GetValue(ButtonEntity::COLUMN_PULLUP_ACTIVE).toInt(), _button.GetValue(ButtonEntity::COLUMN_DEBOUNCE_DELAY).toInt());\n            // for (size_t j = 0; j < modules.size(); j++)\n            // {\n            //     modules[j].~ModuleEntity();\n            // }\n            modules.empty();\n            return fullButton;\n        }        \n    }\n    return fullButton;\n}\n\nstd::vector<ButtonFullEntity> ModulesController::getAllButtons()\n{\n    buttonController = new ButtonController(context, _storageType);\n    \n    std::vector<ButtonFullEntity> buttons = std::vector<ButtonFullEntity>();\n    std::vector<ModuleEntity> modules = GetAll();\n    for (size_t i = 0; i < modules.size(); i++)\n    {\n        ModuleEntity _module = modules.at(i);\n    _module.fromString(_module.toString());\n        if (_module.GetValue(ModuleEntity::COLUMN_MODULE_TYPE) == ModuleTypes::BUTTON)\n        {\n            ButtonEntity _button = buttonController->GetById(_module.id);\n            _button.fromString(_button.toString());\n            ButtonFullEntity fullButton = ButtonFullEntity(_module.id, _button.id, _module.GetValue(ModuleEntity::COLUMN_NAME), _module.GetValue(ModuleEntity::COLUMN_MODULE_TYPE), _module.GetValue(ModuleEntity::COLUMN_CONNECTION_TYPE), _module.GetValue(ModuleEntity::COLUMN_NODE_ID).toInt(), \n            _module.GetValue(ModuleEntity::COLUMN_PIN_NUMBER).toInt(), _button.GetValue(ButtonEntity::COLUMN_BUTTON_TYPE), _button.GetValue(ButtonEntity::COLUMN_ACTIVE_HIGH).toInt(), _button.GetValue(ButtonEntity::COLUMN_PULLUP_ACTIVE).toInt(), _button.GetValue(ButtonEntity::COLUMN_DEBOUNCE_DELAY).toInt());\n            buttons.push_back(fullButton);\n        }        \n    }\n    \n    for (size_t j = 0; j < modules.size(); j++)\n    {\n        // modules[j].~ModuleEntity();\n    }\n    \n    // modules.empty();\n    return buttons;\n}\n\nstd::vector<RelayFullEntity> ModulesController::getAllRelays()\n{\n    RelayController relayController = RelayController(context, _storageType);\n    std::vector<RelayFullEntity> relays;\n    std::vector<ModuleEntity> modules = GetAll();\n    for (size_t i = 0; i < modules.size(); i++)\n    {\n        ModuleEntity _module;\n        _module.fromString(modules.at(i).toString());\n        if (_module.GetValue(ModuleEntity::COLUMN_MODULE_TYPE) == ModuleTypes::RELAY)\n        {\n            RelayEntity _relay;\n            _relay.fromString(relayController.Get(String(RelayEntity::COLUMN_MODULE_ID + \"=\" + _module.id)).at(0).toString());\n\n            Serial.print(\"_relay.toString() = \"); Serial.println(_relay.toString());\n            Serial.print(\"COLUMN_NORMALLY_OPEN = \"); Serial.println(_relay.GetValue(RelayEntity::COLUMN_NORMALLY_OPEN));\n            RelayFullEntity fullRelay = RelayFullEntity(_relay.id, _module.id, _module.GetValue(ModuleEntity::COLUMN_NAME), \n                _module.GetValue(ModuleEntity::COLUMN_MODULE_TYPE), _module.GetValue(ModuleEntity::COLUMN_CONNECTION_TYPE), \n                _module.GetValue(ModuleEntity::COLUMN_NODE_ID).toInt(), _module.GetValue(ModuleEntity::COLUMN_PIN_NUMBER).toInt(), \n                _relay.GetValue(RelayEntity::COLUMN_NORMALLY_OPEN).toInt());\n            relays.push_back(fullRelay);\n        }        \n    }\n    return relays;\n}\nstd::vector<LCDFullEntity> ModulesController::getAllLCDs()\n{\n    LCDController lcdController = LCDController(context, _storageType);\n    std::vector<LCDFullEntity> lcds;\n    std::vector<ModuleEntity> modules = GetAll();\n    for (size_t i = 0; i < modules.size(); i++)\n    {\n        ModuleEntity _module = modules.at(i);\n        if (_module.ModuleType == ModuleTypes::LCD)\n        {\n            LCDEntity _lcd = lcdController.GetById(_module.id);\n            LCDFullEntity fullLcd = LCDFullEntity(_module.id, _lcd.id, _module.Name, _module.ModuleType, _module.ConnectionType, _module.NodeId, \n            _module.PinNumber, _lcd.Address, _lcd.Rows, _lcd.Cols, _lcd.Type);\n            lcds.push_back(fullLcd);\n        }        \n    }\n    return lcds;\n}\n\nstd::vector<DHTFullEntity> ModulesController::getAllDHTs()\n{\n    DHTController dhtController = DHTController(context, _storageType);\n    std::vector<DHTFullEntity> dhts;\n    std::vector<ModuleEntity> modules = GetAll();\n    for (size_t i = 0; i < modules.size(); i++)\n    {\n        ModuleEntity _module = modules.at(i);\n        if (_module.ModuleType == ModuleTypes::DHT)\n        {\n            DHTEntity _dht = dhtController.GetById(_module.id);\n            DHTFullEntity fullDht = DHTFullEntity(_module.id, _dht.id, _module.Name, _module.ModuleType, _module.ConnectionType, _module.NodeId, \n            _module.PinNumber, _dht.Type, _dht.DryTreshold, _dht.WetTreshold, _dht.CoolTreshold, _dht.HotTreshold);\n            dhts.push_back(fullDht);\n        }        \n    }\n    return dhts;\n}\n\nstd::vector<RGBFullEntity> ModulesController::getAllRGBs()\n{\n    RGBController rgbController = RGBController(context, _storageType);\n    std::vector<RGBFullEntity> rgbs;\n    std::vector<ModuleEntity> modules = GetAll();\n    for (size_t i = 0; i < modules.size(); i++)\n    {\n        ModuleEntity _module = modules.at(i);\n        if (_module.ModuleType == ModuleTypes::RGB)\n        {\n            RGBEntity _rgb = rgbController.GetById(_module.id);\n            RGBFullEntity fullRgb = RGBFullEntity(_module.id, _rgb.id, _module.Name, _module.ModuleType, _module.ConnectionType, _module.NodeId, \n            _module.PinNumber, _rgb.Type, _rgb.Rpin, _rgb.Gpin, _rgb.Bpin);\n            rgbs.push_back(fullRgb);\n        }        \n    }\n    return rgbs;\n}\n\nstd::vector<PhotoresistorFullEntity> ModulesController::getAllPhotoresistors()\n{\n    PhotoresistorController photoresistorController = PhotoresistorController(context, _storageType);\n    std::vector<PhotoresistorFullEntity> photoresistors;\n    std::vector<ModuleEntity> modules = GetAll();\n    for (size_t i = 0; i < modules.size(); i++)\n    {\n        ModuleEntity _module = modules.at(i);\n        if (_module.ModuleType == ModuleTypes::PHOTORESISTOR)\n        {\n            PhotoresistorEntity _photoresistor = photoresistorController.GetById(_module.id);\n            PhotoresistorFullEntity fullPhotoresistor = PhotoresistorFullEntity(_module.id, _photoresistor.id, _module.Name, _module.ModuleType, _module.ConnectionType, _module.NodeId, \n            _module.PinNumber, _photoresistor.LowTreshold, _photoresistor.HighTreshold);\n            photoresistors.push_back(fullPhotoresistor);\n        }        \n    }\n    return photoresistors;\n}\n\nint ModulesController::AddButton(ButtonFullEntity button)\n{\n    ModuleEntity *_module = new ModuleEntity(button.ModuleId, button.Name, button.ModuleType,button.ConnectionType, button.NodeId, button.PinNumber);\n    int _module_id = Add(*_module);\n    ButtonEntity *_button = new ButtonEntity(_module_id, button.ButtonType, button.ActiveHigh, button.PullupActive, button.DebounceDelay);\n    ButtonController *buttonController = new ButtonController(context, _storageType);\n    return buttonController->Add(*_button);\n}\n\nint ModulesController::AddRelay(RelayFullEntity relay)\n{\n    ModuleEntity *_module = new ModuleEntity(relay.ModuleId, relay.Name, relay.ModuleType, relay.ConnectionType, relay.NodeId, relay.PinNumber);\n    int _moduleId = Add(*_module);\n    RelayEntity *_relay = new RelayEntity(_moduleId, relay.NormallyOpen);\n    RelayController *relayController = new RelayController(context, _storageType);\n\n    return relayController->Add(*_relay);\n}\n\nint ModulesController::AddLCD(LCDFullEntity lcd)\n{\n    ModuleEntity *_module = new ModuleEntity(lcd.ModuleId, lcd.Name, lcd.ModuleType, lcd.ConnectionType, lcd.NodeId, lcd.PinNumber);\n    int _module_id = Add(*_module);\n    LCDEntity *_lcd = new LCDEntity(_module_id, lcd.Address, lcd.Rows, lcd.Cols, lcd.Type);\n    LCDController *lcdController = new LCDController(context, _storageType);\n\n    return lcdController->Add(*_lcd);\n}\n\nvoid ModulesController::AddDHT(DHTFullEntity dht)\n{\n    ModuleEntity *_module = new ModuleEntity(dht.ModuleId, dht.Name, dht.ModuleType, dht.ConnectionType, dht.NodeId, dht.PinNumber);\n    DHTEntity *_dht = new DHTEntity(dht.Type, dht.DryTreshold, dht.WetTreshold, dht.CoolTreshold, dht.HotTreshold);\n    DHTController *dhtController = new DHTController(context, _storageType);\n\n    dhtController->Add(*_dht);\n    Add(*_module);\n}\n\nvoid ModulesController::AddRGB(RGBFullEntity rgb)\n{\n    ModuleEntity *_module = new ModuleEntity(rgb.ModuleId, rgb.Name, rgb.ModuleType, rgb.ConnectionType, rgb.NodeId, rgb.PinNumber);\n    RGBEntity *_rgb = new RGBEntity(rgb.Type, rgb.Rpin, rgb.Gpin, rgb.Bpin);\n    RGBController *rgbController = new RGBController(context, _storageType);\n\n    rgbController->Add(*_rgb);\n    Add(*_module);\n}\n\nvoid ModulesController::AddPhotoresistor(PhotoresistorFullEntity photoresistor)\n{\n    ModuleEntity *_module = new ModuleEntity(photoresistor.ModuleId, photoresistor.Name, photoresistor.ModuleType, photoresistor.ConnectionType, photoresistor.NodeId, photoresistor.PinNumber);\n    PhotoresistorEntity *_photoresistor = new PhotoresistorEntity(photoresistor.LowTreshold, photoresistor.HighTreshold);\n    PhotoresistorController *photoresistorController = new PhotoresistorController(context, _storageType);\n\n    photoresistorController->Add(*_photoresistor);\n    Add(*_module);\n}\n\nstd::vector<SoilMoistureFullEntity> ModulesController::getAllSoilMoistures()\n{\n    SoilMoistureController soilMoistureController = SoilMoistureController(context, _storageType);\n    std::vector<SoilMoistureFullEntity> soilMoistures;\n    std::vector<ModuleEntity> modules = GetAll();\n    for (size_t i = 0; i < modules.size(); i++)\n    {\n        ModuleEntity _module = modules.at(i);\n        if (_module.ModuleType == ModuleTypes::SOILMOISTURE)\n        {\n            SoilMoistureEntity _soilMoisture = soilMoistureController.GetById(_module.id);\n            SoilMoistureFullEntity fullSoilMoisture = SoilMoistureFullEntity(_module.id, _soilMoisture.id, _module.Name, _module.ModuleType, _module.ConnectionType, _module.NodeId, \n            _module.PinNumber, _soilMoisture.DryTreshold, _soilMoisture.WetTreshold, _soilMoisture.Type);\n            soilMoistures.push_back(fullSoilMoisture);\n        }        \n    }\n    return soilMoistures;\n}\n\nvoid ModulesController::AddSoilMoisture(SoilMoistureFullEntity soilMoisture)\n{\n    ModuleEntity *_module = new ModuleEntity(soilMoisture.ModuleId, soilMoisture.Name, soilMoisture.ModuleType, soilMoisture.ConnectionType, soilMoisture.NodeId, soilMoisture.PinNumber);\n    SoilMoistureEntity *_soilMoisture = new SoilMoistureEntity(0, soilMoisture.DryTreshold, soilMoisture.WetTreshold, soilMoisture.Type);\n    SoilMoistureController *soilMoistureController = new SoilMoistureController(context, _storageType);\n\n    soilMoistureController->Add(*_soilMoisture);\n    Add(*_module);\n}\n\n#endif // MODULESCONTROLLER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Modules\\PhotoresistorController.h",
        "content": "#ifndef PHOTORESISTORCONTROLLER_H\n#define PHOTORESISTORCONTROLLER_H\n\n#include \"../../Entities/Modules/PhotoresistorEntity.h\"\n#include \"../MainController.h\"\n\nclass PhotoresistorController : public MainController<PhotoresistorEntity> {\nprotected:\n    Context* context;\npublic:\n    PhotoresistorController(Context* context, StorageType _storageType) : MainController<PhotoresistorEntity>(context, \"photoresistor\", _storageType), context(context) {}\n};\n\n#endif // PHOTORESISTORCONTROLLER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Modules\\RelayController.h",
        "content": "#ifndef RELAYCONTROLLER_H\n#define RELAYCONTROLLER_H\n\n#include \"../../Entities/Modules/RelayEntity.h\"\n#include \"../MainController.h\"\n\nclass RelayController : public MainController<RelayEntity> {\nprotected:\n    Context* context;\npublic:\n    RelayController(Context* context, StorageType _storageType) : MainController<RelayEntity>(context, \"relay\", _storageType), context(context) {}\n};\n\n#endif // RELAYCONTROLLER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Modules\\RGBController.h",
        "content": "#ifndef RGBCONTROLLER_H\n#define RGBCONTROLLER_H\n\n#include \"../../Entities/Modules/RGBEntity.h\"\n#include \"../MainController.h\"\n\nclass RGBController : public MainController<RGBEntity> {\nprotected:\n    Context* context;\npublic:\n    RGBController(Context* context, StorageType _storageType) : MainController<RGBEntity>(context, \"rgb\", _storageType), context(context) {}\n};\n\n#endif // RGBCONTROLLER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Modules\\SoilMoistureController.h",
        "content": "#ifndef SOILMOISTURECONTROLLER_H\n#define SOILMOISTURECONTROLLER_H\n\n#include \"../../Entities/Modules/SoilMoistureEntity.h\"\n#include \"../MainController.h\"\n\nclass SoilMoistureController : public MainController<SoilMoistureEntity> {\nprotected:\n    Context* context;\npublic:\n    SoilMoistureController(Context* context, StorageType _storageType) : MainController<SoilMoistureEntity>(context, \"soilmoisture\", _storageType), context(context) {}\n};\n\n#endif // SOILMOISTURECONTROLLER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Security\\AccountActivityLogController.h",
        "content": "#ifndef ACCOUNTACTIVITYLOGCONTROLLER_H\n#define ACCOUNTACTIVITYLOGCONTROLLER_H\n\n#include \"../../Entities/Security/AccountActivityLogEntity.h\"\n#include \"../../../Context.h\"\n\nclass AccountActivityLogController : public MainController<AccountActivityLogEntity> {\npublic:\n    Context* context;\n    AccountActivityLogController(Context* context, StorageType _storageType) : MainController<AccountActivityLogEntity>(context ,\"accountactivitylog\", _storageType), context(context) {}\n};\n\n#endif // ACCOUNTACTIVITYLOGCONTROLLER_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Security\\AccountLockoutController.h",
        "content": "#ifndef ACCOUNTLOCKOUTCONTROLLER_H\n#define ACCOUNTLOCKOUTCONTROLLER_H\n\n#include <ESPBoilerplate.h>\n#include \"../../Entities/Security/AccountLockoutEntity.h\"\n#include \"../../../Context.h\"\n\nclass AccountLockoutController : public MainController<AccountLockoutEntity> {\npublic:\n    Context* context;\n    AccountLockoutController(Context* context, StorageType _storageType) : MainController<AccountLockoutEntity>(context ,\"accountlockout\", _storageType), context(context) {}\n};\n\n#endif // ACCOUNTLOCKOUTCONTROLLER_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Security\\AuthenticationConfigController.h",
        "content": "\n#ifndef AUTHENTICATIONCONFIGCONTROLLER_H\n#define AUTHENTICATIONCONFIGCONTROLLER_H\n\n#include \"../../Entities/KeyValueEntity.h\"\n#include \"../../../Context.h\"\n\nclass AuthenticationConfigController : public MainController<KeyValueEntity>{\nprotected:\npublic:\n    Context* context;\n    AuthenticationConfigController(Context* context, StorageType _storageType) : MainController<KeyValueEntity>(context ,\"authentication_config\", _storageType), context(context) {}\n\n};\n\n#endif //AUTHENTICATIONCONFIGCONTROLLER_H\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Security\\LoginAttemptController.h",
        "content": "#ifndef LOGINATTEMPTCONTROLLER_H\n#define LOGINATTEMPTCONTROLLER_H\n\n#include \"../../Entities/Security/LoginAttemptEntity.h\"\n#include \"../../../Context.h\"\n\nclass LoginAttemptController : public MainController<LoginAttemptEntity> {\npublic:\n    Context* context;\n    LoginAttemptController(Context* context, StorageType _storageType) : MainController<LoginAttemptEntity>(context ,\"loginattempt\", _storageType), context(context) {}\n};\n\n#endif // LOGINATTEMPTCONTROLLER_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Security\\PermissionController.h",
        "content": "#ifndef PERMISSIONCONTROLLER_H\n#define PERMISSIONCONTROLLER_H\n\n#include \"../../Entities/Security/PermissionEntity.h\"\n#include \"../../../Context.h\"\n\nclass PermissionController : public MainController<PermissionEntity> {\npublic:\n    Context* context;\n    PermissionController(Context* context, StorageType _storageType) : MainController<PermissionEntity>(context ,\"permission\", _storageType), context(context) {}\n};\n\n#endif // PERMISSIONCONTROLLER_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Security\\RoleController.h",
        "content": "#ifndef ROLECONTROLLER_H\n#define ROLECONTROLLER_H\n\n#include \"../../Entities/Security/RoleEntity.h\"\n#include \"../../../Context.h\"\n\nclass RoleController : public MainController<RoleEntity> {\npublic:\n    Context* context;\n    RoleController(Context* context, StorageType _storageType) : MainController<RoleEntity>(context ,\"role\", _storageType), context(context) {}\n};\n\n#endif // ROLECONTROLLER_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Security\\RolePermissionController.h",
        "content": "#ifndef ROLEPERMISSIONCONTROLLER_H\n#define ROLEPERMISSIONCONTROLLER_H\n\n#include \"../../Entities/Security/RolePermissionEntity.h\"\n#include \"../../../Context.h\"\n\nclass RolePermissionController : public MainController<RolePermissionEntity> {\npublic:\n    Context* context;\n    RolePermissionController(Context* context, StorageType _storageType) : MainController<RolePermissionEntity>(context ,\"rolepermission\", _storageType), context(context) {}\n};\n\n#endif // ROLEPERMISSIONCONTROLLER_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Security\\SecurityQuestionController.h",
        "content": "#ifndef SECURITYQUESTIONCONTROLLER_H\n#define SECURITYQUESTIONCONTROLLER_H\n\n#include <ESPBoilerplate.h>\n#include \"../../Entities/Security/SecurityQuestionEntity.h\"\n#include \"../../../Context.h\"\n\nclass SecurityQuestionController : public MainController<SecurityQuestionEntity> {\npublic:\n    Context* context;\n    SecurityQuestionController(Context* context, StorageType _storageType) : MainController<SecurityQuestionEntity>(context ,\"securityquestion\", _storageType), context(context) {}\n};\n\n#endif // SECURITYQUESTIONCONTROLLER_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Security\\SecurityQuestionTitleController.h",
        "content": "#ifndef SECURITYQUESTIONTITLECONTROLLER_H\n#define SECURITYQUESTIONTITLECONTROLLER_H\n\n#include <ESPBoilerplate.h>\n#include \"../../Entities/Security/SecurityQuestionTitleEntity.h\"\n#include \"../../../Context.h\"\n\nclass SecurityQuestionTitleController : public MainController<SecurityQuestionTitleEntity> {\npublic:\n    Context* context;\n    SecurityQuestionTitleController(Context* context, StorageType _storageType) : MainController<SecurityQuestionTitleEntity>(context ,\"securityquestiontitle\", _storageType), context(context) {}\n};\n\n#endif // SECURITYQUESTIONTITLECONTROLLER_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Security\\TwoFactorAuthController.h",
        "content": "#ifndef TWOFACTORAUTHCONTROLLER_H\n#define TWOFACTORAUTHCONTROLLER_H\n\n#include <ESPBoilerplate.h>\n#include \"../../Entities/Security/TwoFactorAuthEntity.h\"\n#include \"../../../Context.h\"\n\nclass TwoFactorAuthController : public MainController<TwoFactorAuthEntity> {\npublic:\n    Context* context;\n    TwoFactorAuthController(Context* context, StorageType _storageType) : MainController<TwoFactorAuthEntity>(context ,\"twofactorauth\", _storageType), context(context) {}\n};\n\n#endif // TWOFACTORAUTHCONTROLLER_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Security\\UserController.h",
        "content": "#ifndef USERCONTROLLER_H\n#define USERCONTROLLER_H\n\n#include \"../../Entities/Security/UserEntity.h\"\n#include \"../../../Context.h\"\n\nclass UserController : public MainController<UserEntity> {\npublic:\n    Context* context;\n    UserController(Context* context, StorageType _storageType) : MainController<UserEntity>(context ,\"user\", _storageType), context(context) {}\n};\n\n#endif // USERCONTROLLER_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Controllers\\Security\\UserResetPassController.h",
        "content": "#ifndef USERRESETPASSCONTROLLER_H\n#define USERRESETPASSCONTROLLER_H\n\n#include <ESPBoilerplate.h>\n#include \"../../Entities/Security/UserResetPassEntity.h\"\n#include \"../../../Context.h\"\n\nclass UserResetPassController : public MainController<UserResetPassEntity> {\npublic:\n    Context* context;\n    UserResetPassController(Context* context, StorageType _storageType) : MainController<UserResetPassEntity>(context ,\"userresetpass\", _storageType), context(context) {}\n};\n\n#endif // USERRESETPASSCONTROLLER_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Entity.h",
        "content": "#ifndef ENTITY_H\n#define ENTITY_H\n\n#include <vector>\n#include <ArduinoJson.h>\n#include \"../../Clock/EBPDateTime.h\"\n\nstruct Column {\n  String name;\n  String type;\n  String value;\n};\n\nclass Entity {\n  public:\n    int id = -1;\n    bool isValid = true;\n    EBPDateTime createDate;\n    \n    Entity() \n    {\n      createDate = EBPDateTime(2000,1,1,0,0,0);\n    }\n    \n    Entity(String &str) :Entity(){\n      fromString(str);\n    }\n    static Entity Invalid() {\n      Entity invalidEntity;\n      invalidEntity.isValid = false;\n      return invalidEntity;\n    }\n    std::vector<Column> _columns;\n    String GetValue(String column_name);\n    void SetValue(String column_name, String value);\n    String toString();\n    String toJson();\n    void fromString(String str);\n    void addColumn(String column_name, String value, String type);\n    void removeColumn(String column_name);\n    Entity toEntity() const;\n\n};\n\n\nEntity Entity::toEntity() const \n{\n  Entity newEntity;\n  newEntity.id = this->id;\n  newEntity.isValid = this->isValid;\n  newEntity._columns = this->_columns;\n  newEntity.createDate = this->createDate;\n  return newEntity;\n}\n\nvoid Entity::removeColumn(String column_name) {\n  for (int i = 0; i < _columns.size(); i++) {\n    if (_columns[i].name == column_name) {\n      _columns.erase(_columns.begin() + i);\n      return;\n    }\n  }\n}\n\nString Entity::GetValue(String column_name) {\n  for (int i = 0; i < _columns.size(); i++) {\n    if (_columns[i].name == column_name) {\n      return _columns[i].value;\n    }\n  }\n  return \"\";\n}\n\nvoid Entity::SetValue(String column_name, String value) {\n  for (int i = 0; i < _columns.size(); i++) {\n    if (_columns[i].name == column_name) {\n      _columns[i].value = value;\n      return;\n    }\n  }\n  _columns.push_back({column_name, \"string\", value});\n}\n\nString Entity::toString() {\n\n  String str = String(id) + \",\";\n  for (int i = 0; i < _columns.size(); i++) {\n    str += _columns[i].name + \"=\" + _columns[i].value + \",\";\n  }\n  str += createDate.toDateTimeString();\n  return str;\n}\n\n\nvoid Entity::fromString(String str) {\n  int index = str.indexOf(\",\");\n  id = str.substring(0, index).toInt();\n  str = str.substring(index + 1);\n  while (str.length() > 0) {\n      index = str.indexOf(\"=\");\n      String name = str.substring(0, index);\n      str = str.substring(index + 1);\n      index = str.indexOf(\",\");\n      if (index < 0) {\n          index = str.length();\n      }\n      String value = str.substring(0, index);\n      name.trim();\n      if(name.length() > 0) {\n          if(str.indexOf(\",\") < 0 && str.indexOf(\"=\") < 0) { // This is the last element and no more columns exist\n              createDate.fromString(value);\n          }\n          else {\n              SetValue(name, value);\n          }\n      }\n      str = str.substring(index + 1);\n  }\n}\n\n\nvoid Entity::addColumn(String column_name, String value, String type) {\n  // if (!Validation::isColumnNameValid(column_name)) {\n  //   ErrorHandler::handleError(ErrorHandler::CustomError, \"Invalid column name: \" + column_name);\n  //   return;\n  // }\n\n  for (int i = 0; i < _columns.size(); i++) {\n    if (_columns[i].name == column_name) {\n      // ErrorHandler::handleError(ErrorHandler::CustomError, \"Column name already exists: \" + column_name);\n      return;\n    }\n  }\n  _columns.push_back({column_name, type, value});\n}\n\nString Entity::toJson() {\n  DynamicJsonDocument doc(512);\n  doc[\"id\"] = id;\n  for (int i = 0; i < _columns.size(); i++) {\n    doc[_columns[i].name] = _columns[i].value;\n  }\n  doc[\"create_date\"] = createDate.toDateTimeString();\n  String json;\n  serializeJson(doc, json);\n  doc.clear();\n  return json;\n}\n\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\FileSystem.h",
        "content": ""
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\IEntity.h",
        "content": "#ifndef IENTITY_H\n#define IENTITY_H\n\n#include <vector>\n#include <ArduinoJson.h>\n#include \"../../Clock/EBPDateTime.h\"\n\nstruct Column {\n  String name;\n  String type;\n  String value;\n};\n\nclass IEntity {\n  public:\n    virtual String GetValue(String column_name);\n    virtual void SetValue(String column_name, String value);\n    virtual String toString();\n    virtual String toJson();\n    virtual void fromString(String str);\n    virtual void addColumn(String column_name, String value, String type);\n    virtual void removeColumn(String column_name);\n    virtual IEntity toEntity() const;\n};\n\n#endif //IENTITY_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\KeyValueEntity.h",
        "content": "#ifndef SYSTEMCONFIGENTITY_H\n#define SYSTEMCONFIGENTITY_H\n\n#include \"Entity.h\"\n\nclass KeyValueEntity : public Entity {\npublic:\n    static const String COLUMN_KEY;\n    static const String COLUMN_VALUE;\n\n    String key;\n    String value;\n\n    KeyValueEntity() : Entity() {}\n\n    KeyValueEntity(int id, const String &_key, const String &_value) : Entity() {\n        this->id = id;\n        key = _key;\n        value = _value;\n        addColumn(COLUMN_KEY, key, \"string\");\n        addColumn(COLUMN_VALUE, value, \"string\");\n    }\n\n    KeyValueEntity(const String &_key, const String &_value) : KeyValueEntity(0, _key, _value) {}\n\n    static KeyValueEntity fromEntity(Entity entity)\n    {\n        KeyValueEntity systemConfigEntity = KeyValueEntity();\n        systemConfigEntity.fromString(entity.toString());\n        return systemConfigEntity;\n    }\n\n    void setKey(const String &_key) {\n        key = _key;\n        SetValue(COLUMN_KEY, _key);\n    }\n\n    String getKey() {\n        return GetValue(COLUMN_KEY);\n    }\n\n    void setValue(const String &_value) {\n        value = _value;\n        SetValue(COLUMN_VALUE, _value);\n    }\n\n    String getValue() {\n        return GetValue(COLUMN_VALUE);\n    }\n};\n\nconst String KeyValueEntity::COLUMN_KEY = \"key\";\nconst String KeyValueEntity::COLUMN_VALUE = \"value\";\n\n#endif // SYSTEMCONFIGENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\LogEntitiy.h",
        "content": "#ifndef LOGENTITY_H\n#define LOGENTITY_H\n\n#include \"Entity.h\"\n\nclass LogEntity : public Entity {\npublic:\n    enum LogType {\n        Info,\n        Warning,\n        Error,\n    };\n\n    static const String COLUMN_LOG_TYPE;\n    static const String COLUMN_LOG_TITLE;\n    static const String COLUMN_MESSAGE;\n    static const String COLUMN_TIMESTAMP;\n\n    LogType logType;\n    String logTitle;\n    String message;\n    String timestamp;\n\n    LogEntity() : Entity() {}\n\n    LogEntity(int id, LogType _logType, const String &_logTitle, const String &_timestamp, const String &_message) : Entity() {\n        this->id = id;\n        logType = _logType;\n        logTitle = _logTitle;\n        message = _message;\n        timestamp = _timestamp;\n        addColumn(COLUMN_LOG_TYPE, String(static_cast<int>(logType)), \"int\");\n        addColumn(COLUMN_LOG_TITLE, logTitle, \"string\");\n        addColumn(COLUMN_MESSAGE, message, \"string\");\n        addColumn(COLUMN_TIMESTAMP, timestamp, \"string\");\n    }\n\n    LogEntity(LogType _logType, const String &_logTitle, const String &_timestamp, const String &_message) : LogEntity(0, _logType, _logTitle, _timestamp, _message) {}\n\n    static LogEntity fromEntity(Entity entity)\n    {\n        LogEntity logEntity = LogEntity();\n        logEntity.fromString(entity.toString());\n        return logEntity;\n    }\n\n    void setLogType(LogType _logType) {\n        logType = _logType;\n        SetValue(COLUMN_LOG_TYPE, String(static_cast<int>(logType)));\n    }\n\n    LogType getLogType() {\n        return logType;\n    }\n\n    void setLogTitle(const String &_logTitle) {\n        logTitle = _logTitle;\n        SetValue(COLUMN_LOG_TITLE, _logTitle);\n    }\n\n    String getLogTitle() {\n        return logTitle;\n    }\n\n    void setMessage(const String &_message) {\n        message = _message;\n        SetValue(COLUMN_MESSAGE, _message);\n    }\n\n    String getMessage() {\n        return message;\n    }\n\n    void setTimestamp(const String &_timestamp) {\n        timestamp = _timestamp;\n        SetValue(COLUMN_TIMESTAMP, _timestamp);\n    }\n\n    String getTimestamp() {\n        return timestamp;\n    }\n};\n\nconst String LogEntity::COLUMN_LOG_TYPE = \"logType\";\nconst String LogEntity::COLUMN_LOG_TITLE = \"logTitle\";\nconst String LogEntity::COLUMN_MESSAGE = \"message\";\nconst String LogEntity::COLUMN_TIMESTAMP = \"timestamp\";\n\n#endif // LOGENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\WiFiEntity.h",
        "content": "#ifndef WIFIENTITY_H\n#define WIFIENTITY_H\n\n#include \"Entity.h\"\n\nclass WiFiEntity : public Entity {\npublic:\n    static const String COLUMN_SSID;\n    static const String COLUMN_PASSWORD;\n\n    String SSID;\n    String Password;\n\n    WiFiEntity() : Entity() {}\n\n    WiFiEntity(int id, const String &_SSID, const String &_Password) : Entity() {\n        this->id = id;\n        SSID = _SSID;\n        Password = _Password;\n        addColumn(COLUMN_SSID, SSID, \"string\");\n        addColumn(COLUMN_PASSWORD, Password, \"string\");\n    }\n\n    WiFiEntity(const String &_SSID, const String &_Password) : WiFiEntity(0, _SSID, _Password) {}\n\n    static WiFiEntity fromEntity(Entity entity)\n    {\n        WiFiEntity wifiEntity = WiFiEntity();\n        wifiEntity.fromString(entity.toString());\n        return wifiEntity;\n    }\n\n    void setSSID(const String &_SSID) {\n        SSID = _SSID;\n        SetValue(COLUMN_SSID, _SSID);\n    }\n\n    String getSSID() {\n        return GetValue(COLUMN_SSID);\n    }\n\n    void setPassword(const String &_Password) {\n        Password = _Password;\n        SetValue(COLUMN_PASSWORD, _Password);\n    }\n\n    String getPassword() {\n        return GetValue(COLUMN_PASSWORD);\n    }\n};\n\nconst String WiFiEntity::COLUMN_SSID = \"SSID\";\nconst String WiFiEntity::COLUMN_PASSWORD = \"Password\";\n\n#endif // WIFIENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\ButtonEntity.h",
        "content": "#ifndef BUTTONENTITY_H\n#define BUTTONENTITY_H\n\n#include \"..\\Entity.h\"\n\nclass ButtonEntity : public Entity {\npublic:\n    static const String COLUMN_MODULE_ID;\n    static const String COLUMN_BUTTON_TYPE;\n    static const String COLUMN_ACTIVE_HIGH;\n    static const String COLUMN_PULLUP_ACTIVE;\n    static const String COLUMN_DEBOUNCE_DELAY;\n\n    int ModuleId;\n    String ButtonType;\n    bool ActiveHigh;\n    bool PullupActive;\n    int DebounceDelay;\n\n    ButtonEntity()  : Entity(){}\n\n    ButtonEntity(int id, int moduleId, const String &_ButtonType, bool activeHigh, bool pullupActive, int debounceDelay) : Entity() {\n        this->id = id;\n        ModuleId = moduleId;\n        ButtonType = _ButtonType;\n        ActiveHigh = activeHigh;\n        PullupActive = pullupActive;\n        DebounceDelay = debounceDelay;\n        addColumn(COLUMN_MODULE_ID, String(ModuleId), \"int\");\n        addColumn(COLUMN_BUTTON_TYPE, ButtonType, \"string\");\n        addColumn(COLUMN_ACTIVE_HIGH, String(ActiveHigh), \"bool\");\n        addColumn(COLUMN_PULLUP_ACTIVE, String(PullupActive), \"bool\");\n        addColumn(COLUMN_DEBOUNCE_DELAY, String(DebounceDelay), \"int\");\n    }\n\n    ButtonEntity(int moduleId, const String &_ButtonType, bool activeHigh, bool pullupActive, int debounceDelay) : \n        ButtonEntity(0, moduleId, _ButtonType, activeHigh, pullupActive, debounceDelay)  {}\n\n    static ButtonEntity fromEntity(Entity entity)\n    {\n        ButtonEntity buttonEntity = ButtonEntity();\n        buttonEntity.fromString(entity.toString());\n        return buttonEntity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String ButtonEntity::COLUMN_MODULE_ID = \"ModuleId\";\nconst String ButtonEntity::COLUMN_BUTTON_TYPE = \"ButtonType\";\nconst String ButtonEntity::COLUMN_ACTIVE_HIGH = \"ActiveHigh\";\nconst String ButtonEntity::COLUMN_PULLUP_ACTIVE = \"PullupActive\";\nconst String ButtonEntity::COLUMN_DEBOUNCE_DELAY = \"DebounceDelay\";\n\n#endif // BUTTONENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\ButtonFullEntity.h",
        "content": "#ifndef BUTTONFULLENTITY_H\n#define BUTTONFULLENTITY_H\n\n\nclass ButtonFullEntity {\npublic:\n    int id;\n    int ModuleId;\n    String Name;\n    String ModuleType;\n    String ConnectionType;\n    int NodeId;\n    int PinNumber;\n    String ButtonType;\n    bool ActiveHigh;\n    bool PullupActive;\n    int DebounceDelay;\n    int longPressTime;\n\n    ButtonFullEntity() {}\n\n    ButtonFullEntity(int id, int moduleId, String _Name, String _ModuleType, String _ConnectionType, int nodeId,\n                     int pinNumber, String _ButtonType, bool activeHigh, bool pullupActive, int debounceDelay)  {\n        this->id = id;\n        ButtonType = _ButtonType;\n        ActiveHigh = activeHigh;\n        PullupActive = pullupActive;\n        DebounceDelay = debounceDelay;\n        ModuleId = moduleId;\n        Name = _Name;\n        ModuleType = _ModuleType;\n        ConnectionType = _ConnectionType;\n        NodeId = nodeId;\n        PinNumber = pinNumber;\n\n    }\n\n};\n#endif // BUTTONFULLENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\DHTEntity.h",
        "content": "#ifndef DHTENTITY_H\n#define DHTENTITY_H\n\n#include \"..\\Entity.h\"\n\nclass DHTEntity : public Entity {\npublic:\n    static const String COLUMN_TYPE;\n    static const String COLUMN_DRY_TRESHOLD;\n    static const String COLUMN_WET_TRESHOLD;\n    static const String COLUMN_COOL_TRESHOLD;\n    static const String COLUMN_HOT_TRESHOLD;\n\n    String Type;\n    int DryTreshold;\n    int WetTreshold;\n    int CoolTreshold;\n    int HotTreshold;\n\n    DHTEntity() : Entity() {}\n\n    DHTEntity(int id, const String &_Type, int dryTreshold, int wetTreshold, int coolTreshold, int hotTreshold) : Entity() {\n        this->id = id;\n        Type = _Type;\n        DryTreshold = dryTreshold;\n        WetTreshold = wetTreshold;\n        CoolTreshold = coolTreshold;\n        HotTreshold = hotTreshold;\n        addColumn(COLUMN_TYPE, Type, \"string\");\n        addColumn(COLUMN_DRY_TRESHOLD, String(DryTreshold), \"int\");\n        addColumn(COLUMN_WET_TRESHOLD, String(WetTreshold), \"int\");\n        addColumn(COLUMN_COOL_TRESHOLD, String(CoolTreshold), \"int\");\n        addColumn(COLUMN_HOT_TRESHOLD, String(HotTreshold), \"int\");\n    }\n\n    DHTEntity(const String &_Type, int dryTreshold, int wetTreshold, int coolTreshold, int hotTreshold) : \n        DHTEntity(0, _Type, dryTreshold, wetTreshold, coolTreshold, hotTreshold) {}\n\n    static DHTEntity fromEntity(Entity entity)\n    {\n        DHTEntity dhtEntity = DHTEntity();\n        dhtEntity.fromString(entity.toString());\n        return dhtEntity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String DHTEntity::COLUMN_TYPE = \"Type\";\nconst String DHTEntity::COLUMN_DRY_TRESHOLD = \"DryTreshold\";\nconst String DHTEntity::COLUMN_WET_TRESHOLD = \"WetTreshold\";\nconst String DHTEntity::COLUMN_COOL_TRESHOLD = \"CoolTreshold\";\nconst String DHTEntity::COLUMN_HOT_TRESHOLD = \"HotTreshold\";\n\n#endif // DHTENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\DHTFullEntity.h",
        "content": "#ifndef DHTFULLENTITY_H\n#define DHTFULLENTITY_H\n\n#include \"..\\Entity.h\"\n\nclass DHTFullEntity {\npublic:\n    int id;\n    int ModuleId;\n    String Name;\n    String ModuleType;\n    String ConnectionType;\n    int NodeId;\n    int PinNumber;\n    String Type;\n    int DryTreshold;\n    int WetTreshold;\n    int CoolTreshold;\n    int HotTreshold;\n\n    DHTFullEntity() {}\n\n    DHTFullEntity(int id, int moduleId, const String &_Name, const String &_ModuleType, const String &_ConnectionType, int nodeId,\n                  int pinNumber, const String &type, int dryTreshold, int wetTreshold, int coolTreshold, int hotTreshold) {\n        this->id = id;\n        Type = type;\n        DryTreshold = dryTreshold;\n        WetTreshold = wetTreshold;\n        CoolTreshold = coolTreshold;\n        HotTreshold = hotTreshold;\n        ModuleId = moduleId;\n        Name = _Name;\n        ModuleType = _ModuleType;\n        ConnectionType = _ConnectionType;\n        NodeId = nodeId;\n        PinNumber = pinNumber;\n    }\n};\n\n#endif // DHTFULLENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\LCDEntity.h",
        "content": "#ifndef LCDENTITY_H\n#define LCDENTITY_H\n\n#include \"..\\Entity.h\"\n\nclass LCDEntity : public Entity {\npublic:\n    static const String COLUMN_MODULE_ID;\n    static const String COLUMN_ADDRESS;\n    static const String COLUMN_ROW;\n    static const String COLUMN_COL;\n    static const String COLUMN_TYPE;\n\n    int ModuleId;\n    int Address;\n    int Rows;\n    int Cols;\n    String Type;\n\n    LCDEntity() : Entity() {}\n\n    LCDEntity(int id, int moduleId, int address, int row, int col, const String &_Type) : Entity() {\n        this->id = id;\n        ModuleId = moduleId;\n        Address = address;\n        Rows = row;\n        Cols = col;\n        Type = _Type;\n        addColumn(COLUMN_ADDRESS, String(Address), \"int\");\n        addColumn(COLUMN_ROW, String(Rows), \"int\");\n        addColumn(COLUMN_COL, String(Cols), \"int\");\n        addColumn(COLUMN_TYPE, Type, \"string\");\n    }\n\n    LCDEntity(int moduleId, int address, int row, int col, const String &_Type) : \n        LCDEntity(0, moduleId, address, row, col, _Type) {}\n\n    static LCDEntity fromEntity(Entity entity)\n    {\n        LCDEntity lcdEntity = LCDEntity();\n        lcdEntity.fromString(entity.toString());\n        return lcdEntity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String LCDEntity::COLUMN_MODULE_ID = \"ModuleId\";\nconst String LCDEntity::COLUMN_ADDRESS = \"Address\";\nconst String LCDEntity::COLUMN_ROW = \"Rows\";\nconst String LCDEntity::COLUMN_COL = \"Cols\";\nconst String LCDEntity::COLUMN_TYPE = \"Type\";\n\n#endif // LCDENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\LCDFullEntity.h",
        "content": "#ifndef LCDFULLENTITY_H\n#define LCDFULLENTITY_H\n\n#include \"..\\Entity.h\"\n\nclass LCDFullEntity {\npublic:\n    int id;\n    int ModuleId;\n    String Name;\n    String ModuleType;\n    String ConnectionType;\n    int NodeId;\n    int PinNumber;\n    int Address;\n    int Rows;\n    int Cols;\n    String Type;\n\n    LCDFullEntity() {}\n\n    LCDFullEntity(int id, int moduleId, const String &_Name, const String &_ModuleType, const String &_ConnectionType, int nodeId,\n                  int pinNumber, int address, int row, int col, const String &type) {\n        this->id = id;\n        Address = address;\n        Rows = row;\n        Cols = col;\n        Type = type;\n        ModuleId = moduleId;\n        Name = _Name;\n        ModuleType = _ModuleType;\n        ConnectionType = _ConnectionType;\n        NodeId = nodeId;\n        PinNumber = pinNumber;\n    }\n};\n\n#endif // LCDFULLENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\ModuleEntity.h",
        "content": "#ifndef MODULEENTITY_H\n#define MODULEENTITY_H\n\n#include \"..\\Entity.h\"\n\nclass ModuleEntity : public Entity {\npublic:\n    static const String COLUMN_NAME;\n    static const String COLUMN_MODULE_TYPE;\n    static const String COLUMN_CONNECTION_TYPE;\n    static const String COLUMN_NODE_ID;\n    static const String COLUMN_PIN_NUMBER;\n\n    String Name;\n    String ModuleType;\n    String ConnectionType;\n    int NodeId;\n    int PinNumber;\n\n    ModuleEntity() : Entity(){}\n    \n    ~ModuleEntity(){}\n\n    ModuleEntity(int id, const String &_Name, const String &_ModuleType, const String &_ConnectionType, int nodeId, int pinNumber) : Entity() {\n        this->id = id;\n        Name = _Name;\n        ModuleType = _ModuleType;\n        ConnectionType = _ConnectionType;\n        NodeId = nodeId;\n        PinNumber = pinNumber;\n        addColumn(COLUMN_NAME, Name, \"string\");\n        addColumn(COLUMN_MODULE_TYPE, ModuleType, \"string\");\n        addColumn(COLUMN_CONNECTION_TYPE, ConnectionType, \"string\");\n        addColumn(COLUMN_NODE_ID, String(NodeId), \"int\");\n        addColumn(COLUMN_PIN_NUMBER, String(PinNumber), \"int\");\n    }\n\n    ModuleEntity(const String &_Name, const String &_ModuleType, const String &_ConnectionType, int nodeId, int pinNumber) : \n        ModuleEntity(0, _Name, _ModuleType, _ConnectionType, nodeId, pinNumber) {}\n\n    static ModuleEntity fromEntity(Entity entity)\n    {\n        ModuleEntity moduleEntity = ModuleEntity();\n        moduleEntity.fromString(entity.toString());\n        return moduleEntity;\n    }\n\n    // Setters and Getters for each field\n\n};\n\nconst String ModuleEntity::COLUMN_NAME = \"Name\";\nconst String ModuleEntity::COLUMN_MODULE_TYPE = \"ModuleType\";\nconst String ModuleEntity::COLUMN_CONNECTION_TYPE = \"ConnectionType\";\nconst String ModuleEntity::COLUMN_NODE_ID = \"NodeId\";\nconst String ModuleEntity::COLUMN_PIN_NUMBER = \"PinNumber\";\n\n#endif // MODULEENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\PhotoresistorEntity.h",
        "content": "#ifndef PHOTORESISTORENTITY_H\n#define PHOTORESISTORENTITY_H\n\n#include \"..\\Entity.h\"\n\nclass PhotoresistorEntity : public Entity {\npublic:\n    static const String COLUMN_LOW_TRESHOLD;\n    static const String COLUMN_HIGH_TRESHOLD;\n\n    int LowTreshold;\n    int HighTreshold;\n\n    PhotoresistorEntity() : Entity() {}\n\n    PhotoresistorEntity(int id, int lowTreshold, int highTreshold) : Entity() {\n        this->id = id;\n        LowTreshold = lowTreshold;\n        HighTreshold = highTreshold;\n        addColumn(COLUMN_LOW_TRESHOLD, String(LowTreshold), \"int\");\n        addColumn(COLUMN_HIGH_TRESHOLD, String(HighTreshold), \"int\");\n    }\n\n    PhotoresistorEntity(int lowTreshold, int highTreshold) : \n        PhotoresistorEntity(0, lowTreshold, highTreshold) {}\n\n    static PhotoresistorEntity fromEntity(Entity entity)\n    {\n        PhotoresistorEntity photoresistorEntity = PhotoresistorEntity();\n        photoresistorEntity.fromString(entity.toString());\n        return photoresistorEntity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String PhotoresistorEntity::COLUMN_LOW_TRESHOLD = \"LowTreshold\";\nconst String PhotoresistorEntity::COLUMN_HIGH_TRESHOLD = \"HighTreshold\";\n\n#endif // PHOTORESISTORENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\PhotoresistorFullEntity.h",
        "content": "#ifndef PHOTORESISTORFULLENTITY_H\n#define PHOTORESISTORFULLENTITY_H\n\n#include \"..\\Entity.h\"\n\nclass PhotoresistorFullEntity {\npublic:\n    int id;\n    int ModuleId;\n    String Name;\n    String ModuleType;\n    String ConnectionType;\n    int NodeId;\n    int PinNumber;\n    int LowTreshold;\n    int HighTreshold;\n\n    PhotoresistorFullEntity() {}\n\n    PhotoresistorFullEntity(int id, int moduleId, const String &_Name, const String &_ModuleType, const String &_ConnectionType, int nodeId,\n                            int pinNumber, int lowTreshold, int highTreshold) {\n        this->id = id;\n        LowTreshold = lowTreshold;\n        HighTreshold = highTreshold;\n        ModuleId = moduleId;\n        Name = _Name;\n        ModuleType = _ModuleType;\n        ConnectionType = _ConnectionType;\n        NodeId = nodeId;\n        PinNumber = pinNumber;\n    }\n};\n\n#endif // PHOTORESISTORFULLENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\RelayEntity.h",
        "content": "#ifndef RELAYENTITY_H\n#define RELAYENTITY_H\n\n#include \"..\\Entity.h\"\n\nclass RelayEntity : public Entity {\npublic:\n    static const String COLUMN_NORMALLY_OPEN;\n    static const String COLUMN_MODULE_ID;\n\n    int ModuleId;\n    bool NormallyOpen;\n\n    RelayEntity() : Entity() {}\n\n    RelayEntity(int id, int moduleId, bool normallyOpen) : Entity() {\n        this->id = id;\n        ModuleId = moduleId;\n        NormallyOpen = normallyOpen;\n        addColumn(COLUMN_MODULE_ID, String(ModuleId), \"int\");\n        addColumn(COLUMN_NORMALLY_OPEN, String(NormallyOpen), \"bool\");\n    }\n\n    RelayEntity(int moduleId, bool normallyOpen) : \n        RelayEntity(0, moduleId, normallyOpen) {}\n\n    static RelayEntity fromEntity(Entity entity)\n    {\n        RelayEntity relayEntity = RelayEntity();\n        relayEntity.fromString(entity.toString());\n        return relayEntity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String RelayEntity::COLUMN_MODULE_ID = \"ModuleId\";\nconst String RelayEntity::COLUMN_NORMALLY_OPEN = \"NormallyOpen\";\n\n#endif // RELAYENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\RelayFullEntity.h",
        "content": "#ifndef RELAYFULLENTITY_H\n#define RELAYFULLENTITY_H\n\n#include \"..\\Entity.h\"\n\nclass RelayFullEntity {\npublic:\n    int id;\n    int ModuleId;\n    String Name;\n    String ModuleType;\n    String ConnectionType;\n    int NodeId;\n    int PinNumber;\n    bool NormallyOpen;\n\n    RelayFullEntity() {}\n\n    RelayFullEntity(int id, int moduleId, const String &_Name, const String &_ModuleType, const String &_ConnectionType, int nodeId,\n                    int pinNumber, bool normallyOpen) {\n        this->id = id;\n        NormallyOpen = normallyOpen;\n        ModuleId = moduleId;\n        Name = _Name;\n        ModuleType = _ModuleType;\n        ConnectionType = _ConnectionType;\n        NodeId = nodeId;\n        PinNumber = pinNumber;\n    }\n};\n\n#endif // RELAYFULLENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\RGBEntity.h",
        "content": "#ifndef RGBENTITY_H\n#define RGBENTITY_H\n\n#include \"..\\Entity.h\"\n\nclass RGBEntity : public Entity {\npublic:\n    static const String COLUMN_TYPE;\n    static const String COLUMN_RPIN;\n    static const String COLUMN_GPIN;\n    static const String COLUMN_BPIN;\n\n    String Type;\n    int Rpin;\n    int Gpin;\n    int Bpin;\n\n    RGBEntity() : Entity() {}\n\n    RGBEntity(int id, const String &_Type, int rpin, int gpin, int bpin) : Entity() {\n        this->id = id;\n        Type = _Type;\n        Rpin = rpin;\n        Gpin = gpin;\n        Bpin = bpin;\n        addColumn(COLUMN_TYPE, Type, \"string\");\n        addColumn(COLUMN_RPIN, String(Rpin), \"int\");\n        addColumn(COLUMN_GPIN, String(Gpin), \"int\");\n        addColumn(COLUMN_BPIN, String(Bpin), \"int\");\n    }\n\n    RGBEntity(const String &_Type, int rpin, int gpin, int bpin) : \n        RGBEntity(0, _Type, rpin, gpin, bpin) {}\n\n    static RGBEntity fromEntity(Entity entity)\n    {\n        RGBEntity rgbEntity = RGBEntity();\n        rgbEntity.fromString(entity.toString());\n        return rgbEntity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String RGBEntity::COLUMN_TYPE = \"Type\";\nconst String RGBEntity::COLUMN_RPIN = \"Rpin\";\nconst String RGBEntity::COLUMN_GPIN = \"Gpin\";\nconst String RGBEntity::COLUMN_BPIN = \"Bpin\";\n\n#endif // RGBENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\RGBFullEntity.h",
        "content": "#ifndef RGBFULLENTITY_H\n#define RGBFULLENTITY_H\n\n#include \"..\\Entity.h\"\n\nclass RGBFullEntity {\npublic:\n    int id;\n    int ModuleId;\n    String Name;\n    String ModuleType;\n    String ConnectionType;\n    int NodeId;\n    int PinNumber;\n    String Type;\n    int Rpin;\n    int Gpin;\n    int Bpin;\n\n    RGBFullEntity() {}\n\n    RGBFullEntity(int id, int moduleId, const String &_Name, const String &_ModuleType, const String &_ConnectionType, int nodeId,\n                  int pinNumber, const String &type, int rpin, int gpin, int bpin) {\n        this->id = id;\n        Type = type;\n        Rpin = rpin;\n        Gpin = gpin;\n        Bpin = bpin;\n        ModuleId = moduleId;\n        Name = _Name;\n        ModuleType = _ModuleType;\n        ConnectionType = _ConnectionType;\n        NodeId = nodeId;\n        PinNumber = pinNumber;\n    }\n};\n\n#endif // RGBFULLENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\SoilMoistureEntity.h",
        "content": "#ifndef SOILMOISTUREENTITY_H\n#define SOILMOISTUREENTITY_H\n\n#include \"..\\Entity.h\"\n\nclass SoilMoistureEntity : public Entity {\npublic:\n    static const String COLUMN_DRY_TRESHOLD;\n    static const String COLUMN_WET_TRESHOLD;\n    static const String COLUMN_TYPE;\n\n    int DryTreshold;\n    int WetTreshold;\n    String Type;\n\n    SoilMoistureEntity() : Entity() {}\n\n    SoilMoistureEntity(int id, int dryTreshold, int wetTreshold, const String &_Type) : Entity() {\n        this->id = id;\n        DryTreshold = dryTreshold;\n        WetTreshold = wetTreshold;\n        Type = _Type;\n        addColumn(COLUMN_DRY_TRESHOLD, String(DryTreshold), \"int\");\n        addColumn(COLUMN_WET_TRESHOLD, String(WetTreshold), \"int\");\n        addColumn(COLUMN_TYPE, Type, \"string\");\n    }\n\n    SoilMoistureEntity(int dryTreshold, int wetTreshold, const String &_Type) : \n        SoilMoistureEntity(0, dryTreshold, wetTreshold, _Type) {}\n\n    static SoilMoistureEntity fromEntity(Entity entity)\n    {\n        SoilMoistureEntity soilMoistureEntity = SoilMoistureEntity();\n        soilMoistureEntity.fromString(entity.toString());\n        return soilMoistureEntity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String SoilMoistureEntity::COLUMN_DRY_TRESHOLD = \"DryTreshold\";\nconst String SoilMoistureEntity::COLUMN_WET_TRESHOLD = \"WetTreshold\";\nconst String SoilMoistureEntity::COLUMN_TYPE = \"Type\";\n\n#endif // SOILMOISTUREENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Modules\\SoilMoistureFullEntity.h",
        "content": "#ifndef SOILMOISTUREFULLENTITY_H\n#define SOILMOISTUREFULLENTITY_H\n\n#include \"..\\Entity.h\"\n\nclass SoilMoistureFullEntity {\npublic:\n    int id;\n    int ModuleId;\n    String Name;\n    String ModuleType;\n    String ConnectionType;\n    int NodeId;\n    int PinNumber;\n    int DryTreshold;\n    int WetTreshold;\n    String Type;\n\n    SoilMoistureFullEntity() {}\n\n    SoilMoistureFullEntity(int id, int moduleId, const String &_Name, const String &_ModuleType, const String &_ConnectionType, int nodeId,\n                           int pinNumber, int dryTreshold, int wetTreshold, const String &type) {\n        this->id = id;\n        DryTreshold = dryTreshold;\n        WetTreshold = wetTreshold;\n        Type = type;\n        ModuleId = moduleId;\n        Name = _Name;\n        ModuleType = _ModuleType;\n        ConnectionType = _ConnectionType;\n        NodeId = nodeId;\n        PinNumber = pinNumber;\n    }\n};\n\n#endif // SOILMOISTUREFULLENTITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Security\\AccountActivityLogEntity.h",
        "content": "#ifndef ACCOUNTACTIVITYLOGENTITY_H\n#define ACCOUNTACTIVITYLOGENTITY_H\n\n#include \"../Entity.h\"\n\nclass AccountActivityLogEntity : public Entity {\npublic:\n    static const String COLUMN_USERID;\n    static const String COLUMN_ACTIVITY;\n    static const String COLUMN_TIMESTAMP;\n    \n\n    int UserId;\n    String Activity;\n    EBPDateTime Timestamp;\n    \n\n    AccountActivityLogEntity()  : Entity(){}\n\n    AccountActivityLogEntity(int id, int _UserId, String _Activity, EBPDateTime _Timestamp) : Entity() {\n        this->id = id;\n        UserId = _UserId;\n        Activity = _Activity;\n        Timestamp = _Timestamp;\n        \n\n        addColumn(COLUMN_USERID, String(UserId), \"int\");\n        addColumn(COLUMN_ACTIVITY, String(Activity), \"String\");\n        addColumn(COLUMN_TIMESTAMP, Timestamp.toDateTimeString(), \"EBPDateTime\");\n        \n    }\n\n    AccountActivityLogEntity(int _UserId, String _Activity, EBPDateTime _Timestamp) : \n        AccountActivityLogEntity(0, _UserId, _Activity, _Timestamp)  {}\n\n    static AccountActivityLogEntity fromEntity(Entity entity)\n    {\n        AccountActivityLogEntity accountactivitylogentity = AccountActivityLogEntity();\n        accountactivitylogentity.fromString(entity.toString());\n        return accountactivitylogentity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String AccountActivityLogEntity::COLUMN_USERID = \"UserId\";\nconst String AccountActivityLogEntity::COLUMN_ACTIVITY = \"Activity\";\nconst String AccountActivityLogEntity::COLUMN_TIMESTAMP = \"Timestamp\";\n\n\n#endif // ACCOUNTACTIVITYLOGENTITY_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Security\\AccountLockoutEntity.h",
        "content": "#ifndef ACCOUNTLOCKOUTENTITY_H\n#define ACCOUNTLOCKOUTENTITY_H\n\n#include \"../Entity.h\"\n\nclass AccountLockoutEntity : public Entity {\npublic:\n    static const String COLUMN_USERID;\n    static const String COLUMN_LOCKOUTSTARTTIME;\n    static const String COLUMN_LOCKOUTENDTIME;\n    \n\n    int UserId;\n    EBPDateTime LockoutStartTime;\n    EBPDateTime LockoutEndTime;\n    \n\n    AccountLockoutEntity()  : Entity(){}\n\n    AccountLockoutEntity(int id, int _UserId, EBPDateTime _LockoutStartTime, EBPDateTime _LockoutEndTime) : Entity() {\n        this->id = id;\n        UserId = _UserId;\n        LockoutStartTime = _LockoutStartTime;\n        LockoutEndTime = _LockoutEndTime;\n        \n\n        addColumn(COLUMN_USERID, String(UserId), \"int\");\n        addColumn(COLUMN_LOCKOUTSTARTTIME, LockoutStartTime.toDateTimeString(), \"EBPDateTime\");\n        addColumn(COLUMN_LOCKOUTENDTIME, LockoutEndTime.toDateTimeString(), \"EBPDateTime\");\n        \n    }\n\n    AccountLockoutEntity(int _UserId, EBPDateTime _LockoutStartTime, EBPDateTime _LockoutEndTime) : \n        AccountLockoutEntity(0, _UserId, _LockoutStartTime, _LockoutEndTime)  {}\n\n    static AccountLockoutEntity fromEntity(Entity entity)\n    {\n        AccountLockoutEntity accountlockoutentity = AccountLockoutEntity();\n        accountlockoutentity.fromString(entity.toString());\n        return accountlockoutentity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String AccountLockoutEntity::COLUMN_USERID = \"UserId\";\nconst String AccountLockoutEntity::COLUMN_LOCKOUTSTARTTIME = \"LockoutStartTime\";\nconst String AccountLockoutEntity::COLUMN_LOCKOUTENDTIME = \"LockoutEndTime\";\n\n\n#endif // ACCOUNTLOCKOUTENTITY_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Security\\LoginAttemptEntity.h",
        "content": "#ifndef LOGINATTEMPTENTITY_H\n#define LOGINATTEMPTENTITY_H\n\n#include \"../Entity.h\"\n\nclass LoginAttemptEntity : public Entity {\npublic:\n    static const String COLUMN_USERID;\n    static const String COLUMN_TIMESTAMP;\n    \n\n    int UserId;\n    EBPDateTime Timestamp;\n    \n\n    LoginAttemptEntity()  : Entity(){}\n\n    LoginAttemptEntity(int id, int _UserId, EBPDateTime _Timestamp) : Entity() {\n        this->id = id;\n        UserId = _UserId;\n        Timestamp = _Timestamp;\n        \n\n        addColumn(COLUMN_USERID, String(UserId), \"int\");\n        addColumn(COLUMN_TIMESTAMP, Timestamp.toDateTimeString(), \"EBPDateTime\");\n        \n    }\n\n    LoginAttemptEntity(int _UserId, EBPDateTime _Timestamp) : \n        LoginAttemptEntity(0, _UserId, _Timestamp)  {}\n\n    static LoginAttemptEntity fromEntity(Entity entity)\n    {\n        LoginAttemptEntity loginattemptentity = LoginAttemptEntity();\n        loginattemptentity.fromString(entity.toString());\n        return loginattemptentity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String LoginAttemptEntity::COLUMN_USERID = \"UserId\";\nconst String LoginAttemptEntity::COLUMN_TIMESTAMP = \"Timestamp\";\n\n\n#endif // LOGINATTEMPTENTITY_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Security\\PermissionEntity.h",
        "content": "#ifndef PERMISSIONENTITY_H\n#define PERMISSIONENTITY_H\n\n#include \"../Entity.h\"\n\nclass PermissionEntity : public Entity {\npublic:\n    static const String COLUMN_PERMISSIONNAME;\n    static const String COLUMN_PERMISSIONGROUP;\n    \n\n    String PermissionName;\n    String PermissionGroup;\n    \n\n    PermissionEntity()  : Entity(){}\n\n    PermissionEntity(int id, String _PermissionName, String _PermissionGroup) : Entity() {\n        this->id = id;\n        PermissionName = _PermissionName;\n        PermissionGroup = _PermissionGroup;\n        \n\n        addColumn(COLUMN_PERMISSIONNAME, String(PermissionName), \"String\");\n        addColumn(COLUMN_PERMISSIONGROUP, String(PermissionGroup), \"String\");\n        \n    }\n\n    PermissionEntity(String _PermissionName, String _PermissionGroup) : \n        PermissionEntity(0, _PermissionName, _PermissionGroup)  {}\n\n    static PermissionEntity fromEntity(Entity entity)\n    {\n        PermissionEntity permissionentity = PermissionEntity();\n        permissionentity.fromString(entity.toString());\n        return permissionentity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String PermissionEntity::COLUMN_PERMISSIONNAME = \"PermissionName\";\nconst String PermissionEntity::COLUMN_PERMISSIONGROUP = \"PermissionGroup\";\n\n\n#endif // PERMISSIONENTITY_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Security\\RoleEntity.h",
        "content": "#ifndef ROLEENTITY_H\n#define ROLEENTITY_H\n\n#include \"../Entity.h\"\n\nclass RoleEntity : public Entity {\npublic:\n    static const String COLUMN_ROLENAME;\n    \n\n    String RoleName;\n    \n\n    RoleEntity()  : Entity(){}\n\n    RoleEntity(int id, String _RoleName) : Entity() {\n        this->id = id;\n        RoleName = _RoleName;\n        \n\n        addColumn(COLUMN_ROLENAME, String(RoleName), \"String\");\n        \n    }\n\n    RoleEntity(String _RoleName) : \n        RoleEntity(0, _RoleName)  {}\n\n    static RoleEntity fromEntity(Entity entity)\n    {\n        RoleEntity roleentity = RoleEntity();\n        roleentity.fromString(entity.toString());\n        return roleentity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String RoleEntity::COLUMN_ROLENAME = \"RoleName\";\n\n\n#endif // ROLEENTITY_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Security\\RolePermissionEntity.h",
        "content": "#ifndef ROLEPERMISSIONENTITY_H\n#define ROLEPERMISSIONENTITY_H\n\n#include \"../Entity.h\"\n\nclass RolePermissionEntity : public Entity {\npublic:\n    static const String COLUMN_ROLEID;\n    static const String COLUMN_PERMISSIONID;\n    \n\n    int RoleId;\n    int PermissionId;\n    \n\n    RolePermissionEntity()  : Entity(){}\n\n    RolePermissionEntity(int id, int _RoleId, int _PermissionId) : Entity() {\n        this->id = id;\n        RoleId = _RoleId;\n        PermissionId = _PermissionId;\n        \n\n        addColumn(COLUMN_ROLEID, String(RoleId), \"int\");\n        addColumn(COLUMN_PERMISSIONID, String(PermissionId), \"int\");\n        \n    }\n\n    RolePermissionEntity(int _RoleId, int _PermissionId) : \n        RolePermissionEntity(0, _RoleId, _PermissionId)  {}\n\n    static RolePermissionEntity fromEntity(Entity entity)\n    {\n        RolePermissionEntity rolepermissionentity = RolePermissionEntity();\n        rolepermissionentity.fromString(entity.toString());\n        return rolepermissionentity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String RolePermissionEntity::COLUMN_ROLEID = \"RoleId\";\nconst String RolePermissionEntity::COLUMN_PERMISSIONID = \"PermissionId\";\n\n\n#endif // ROLEPERMISSIONENTITY_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Security\\SecurityQuestionEntity.h",
        "content": "#ifndef SECURITYQUESTIONENTITY_H\n#define SECURITYQUESTIONENTITY_H\n\n#include \"../Entity.h\"\n\nclass SecurityQuestionEntity : public Entity {\npublic:\n    static const String COLUMN_USERID;\n    static const String COLUMN_SECURITYQUESTIONTITLEID;\n    static const String COLUMN_ANSWER;\n    \n\n    int UserId;\n    String SecurityQuestionTitleId;\n    String Answer;\n    \n\n    SecurityQuestionEntity()  : Entity(){}\n\n    SecurityQuestionEntity(int id, int _UserId, String _SecurityQuestionTitleId, String _Answer) : Entity() {\n        this->id = id;\n        UserId = _UserId;\n        SecurityQuestionTitleId = _SecurityQuestionTitleId;\n        Answer = _Answer;\n        \n\n        addColumn(COLUMN_USERID, String(UserId), \"int\");\n        addColumn(COLUMN_SECURITYQUESTIONTITLEID, String(SecurityQuestionTitleId), \"String\");\n        addColumn(COLUMN_ANSWER, String(Answer), \"String\");\n        \n    }\n\n    SecurityQuestionEntity(int _UserId, String _SecurityQuestionTitleId, String _Answer) : \n        SecurityQuestionEntity(0, _UserId, _SecurityQuestionTitleId, _Answer)  {}\n\n    static SecurityQuestionEntity fromEntity(Entity entity)\n    {\n        SecurityQuestionEntity securityquestionentity = SecurityQuestionEntity();\n        securityquestionentity.fromString(entity.toString());\n        return securityquestionentity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String SecurityQuestionEntity::COLUMN_USERID = \"UserId\";\nconst String SecurityQuestionEntity::COLUMN_SECURITYQUESTIONTITLEID = \"SecurityQuestionTitleId\";\nconst String SecurityQuestionEntity::COLUMN_ANSWER = \"Answer\";\n\n\n#endif // SECURITYQUESTIONENTITY_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Security\\SecurityQuestionTitleEntity.h",
        "content": "#ifndef SECURITYQUESTIONTITLEENTITY_H\n#define SECURITYQUESTIONTITLEENTITY_H\n\n#include \"../Entity.h\"\n\nclass SecurityQuestionTitleEntity : public Entity {\npublic:\n    static const String COLUMN_QUESTIONTITLE;\n    \n\n    String QuestionTitle;\n    \n\n    SecurityQuestionTitleEntity()  : Entity(){}\n\n    SecurityQuestionTitleEntity(int id, String _QuestionTitle) : Entity() {\n        this->id = id;\n        QuestionTitle = _QuestionTitle;\n        \n\n        addColumn(COLUMN_QUESTIONTITLE, String(QuestionTitle), \"String\");\n        \n    }\n\n    SecurityQuestionTitleEntity(String _QuestionTitle) : \n        SecurityQuestionTitleEntity(0, _QuestionTitle)  {}\n\n    static SecurityQuestionTitleEntity fromEntity(Entity entity)\n    {\n        SecurityQuestionTitleEntity securityquestiontitleentity = SecurityQuestionTitleEntity();\n        securityquestiontitleentity.fromString(entity.toString());\n        return securityquestiontitleentity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String SecurityQuestionTitleEntity::COLUMN_QUESTIONTITLE = \"QuestionTitle\";\n\n\n#endif // SECURITYQUESTIONTITLEENTITY_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Security\\TwoFactorAuthEntity.h",
        "content": "#ifndef TWOFACTORAUTHENTITY_H\n#define TWOFACTORAUTHENTITY_H\n\n#include \"../Entity.h\"\n\nclass TwoFactorAuthEntity : public Entity {\npublic:\n    static const String COLUMN_USERID;\n    static const String COLUMN_OTPCODE;\n    static const String COLUMN_EXPIRYTIME;\n    \n\n    int UserId;\n    String OtpCode;\n    EBPDateTime ExpiryTime;\n    \n\n    TwoFactorAuthEntity()  : Entity(){}\n\n    TwoFactorAuthEntity(int id, int _UserId, String _OtpCode, EBPDateTime _ExpiryTime) : Entity() {\n        this->id = id;\n        UserId = _UserId;\n        OtpCode = _OtpCode;\n        ExpiryTime = _ExpiryTime;\n        \n\n        addColumn(COLUMN_USERID, String(UserId), \"int\");\n        addColumn(COLUMN_OTPCODE, String(OtpCode), \"String\");\n        addColumn(COLUMN_EXPIRYTIME, ExpiryTime.toDateTimeString(), \"EBPDateTime\");\n        \n    }\n\n    TwoFactorAuthEntity(int _UserId, String _OtpCode, EBPDateTime _ExpiryTime) : \n        TwoFactorAuthEntity(0, _UserId, _OtpCode, _ExpiryTime)  {}\n\n    static TwoFactorAuthEntity fromEntity(Entity entity)\n    {\n        TwoFactorAuthEntity twofactorauthentity = TwoFactorAuthEntity();\n        twofactorauthentity.fromString(entity.toString());\n        return twofactorauthentity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String TwoFactorAuthEntity::COLUMN_USERID = \"UserId\";\nconst String TwoFactorAuthEntity::COLUMN_OTPCODE = \"OtpCode\";\nconst String TwoFactorAuthEntity::COLUMN_EXPIRYTIME = \"ExpiryTime\";\n\n\n#endif // TWOFACTORAUTHENTITY_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Security\\UserEntity.h",
        "content": "#ifndef USERENTITY_H\n#define USERENTITY_H\n\n#include \"../Entity.h\"\n\nclass UserEntity : public Entity {\npublic:\n    static const String COLUMN_USERNAME;\n    static const String COLUMN_PASSWORD;\n    static const String COLUMN_EMAIL;\n    static const String COLUMN_PHONENUMBER;\n    static const String COLUMN_ROLEID;\n    static const String COLUMN_TWOFACTORAUTH;\n    static const String COLUMN_APIKEY;\n    static const String COLUMN_TOKEN;\n    static const String COLUMN_TOKENEXPIRYTIME;\n    \n\n    String Username;\n    String Password;\n    String Email;\n    String PhoneNumber;\n    int RoleId;\n    bool TwoFactorAuth;\n    String ApiKey;\n    String Token;\n    EBPDateTime TokenExpiryTime;\n    \n\n    UserEntity()  : Entity(){}\n\n    UserEntity(int id, String _Username, String _Password, String _Email, String _PhoneNumber, int _RoleId, bool _TwoFactorAuth, String _ApiKey, String _Token, EBPDateTime _TokenExpiryTime) : Entity() {\n        this->id = id;\n        Username = _Username;\n        Password = _Password;\n        Email = _Email;\n        PhoneNumber = _PhoneNumber;\n        RoleId = _RoleId;\n        TwoFactorAuth = _TwoFactorAuth;\n        ApiKey = _ApiKey;\n        Token = _Token;\n        TokenExpiryTime = _TokenExpiryTime;\n        \n\n        addColumn(COLUMN_USERNAME, String(Username), \"String\");\n        addColumn(COLUMN_PASSWORD, String(Password), \"String\");\n        addColumn(COLUMN_EMAIL, String(Email), \"String\");\n        addColumn(COLUMN_PHONENUMBER, String(PhoneNumber), \"String\");\n        addColumn(COLUMN_ROLEID, String(RoleId), \"int\");\n        addColumn(COLUMN_TWOFACTORAUTH, String(TwoFactorAuth), \"bool\");\n        addColumn(COLUMN_APIKEY, String(ApiKey), \"String\");\n        addColumn(COLUMN_TOKEN, String(Token), \"String\");\n        addColumn(COLUMN_TOKENEXPIRYTIME, TokenExpiryTime.toDateTimeString(), \"EBPDateTime\");\n        \n    }\n\n    UserEntity(String _Username, String _Password, String _Email, String _PhoneNumber, int _RoleId, bool _TwoFactorAuth, String _ApiKey, String _Token, EBPDateTime _TokenExpiryTime) : \n        UserEntity(0, _Username, _Password, _Email, _PhoneNumber, _RoleId, _TwoFactorAuth, _ApiKey, _Token, _TokenExpiryTime)  {}\n\n    static UserEntity fromEntity(Entity entity)\n    {\n        UserEntity userentity = UserEntity();\n        userentity.fromString(entity.toString());\n        return userentity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String UserEntity::COLUMN_USERNAME = \"Username\";\nconst String UserEntity::COLUMN_PASSWORD = \"Password\";\nconst String UserEntity::COLUMN_EMAIL = \"Email\";\nconst String UserEntity::COLUMN_PHONENUMBER = \"PhoneNumber\";\nconst String UserEntity::COLUMN_ROLEID = \"RoleId\";\nconst String UserEntity::COLUMN_TWOFACTORAUTH = \"TwoFactorAuth\";\nconst String UserEntity::COLUMN_APIKEY = \"ApiKey\";\nconst String UserEntity::COLUMN_TOKEN = \"Token\";\nconst String UserEntity::COLUMN_TOKENEXPIRYTIME = \"TokenExpiryTime\";\n\n\n#endif // USERENTITY_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Database\\Entities\\Security\\UserResetPassEntity.h",
        "content": "#ifndef USERRESETPASSENTITY_H\n#define USERRESETPASSENTITY_H\n\n#include \"../Entity.h\"\n\nclass UserResetPassEntity : public Entity {\npublic:\n    static const String COLUMN_USERID;\n    static const String COLUMN_RESETTOKEN;\n    static const String COLUMN_EXPIRYTIME;\n    \n\n    int UserId;\n    String ResetToken;\n    EBPDateTime ExpiryTime;\n    \n\n    UserResetPassEntity()  : Entity(){}\n\n    UserResetPassEntity(int id, int _UserId, String _ResetToken, EBPDateTime _ExpiryTime) : Entity() {\n        this->id = id;\n        UserId = _UserId;\n        ResetToken = _ResetToken;\n        ExpiryTime = _ExpiryTime;\n        \n\n        addColumn(COLUMN_USERID, String(UserId), \"int\");\n        addColumn(COLUMN_RESETTOKEN, String(ResetToken), \"String\");\n        addColumn(COLUMN_EXPIRYTIME, ExpiryTime.toDateTimeString(), \"EBPDateTime\");\n        \n    }\n\n    UserResetPassEntity(int _UserId, String _ResetToken, EBPDateTime _ExpiryTime) : \n        UserResetPassEntity(0, _UserId, _ResetToken, _ExpiryTime)  {}\n\n    static UserResetPassEntity fromEntity(Entity entity)\n    {\n        UserResetPassEntity userresetpassentity = UserResetPassEntity();\n        userresetpassentity.fromString(entity.toString());\n        return userresetpassentity;\n    }\n\n    // Setters and Getters for each field\n};\n\nconst String UserResetPassEntity::COLUMN_USERID = \"UserId\";\nconst String UserResetPassEntity::COLUMN_RESETTOKEN = \"ResetToken\";\nconst String UserResetPassEntity::COLUMN_EXPIRYTIME = \"ExpiryTime\";\n\n\n#endif // USERRESETPASSENTITY_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ErrorHandler\\ErrorHandler.h",
        "content": "// ErrorHandler.h\n\n#ifndef ERRORHANDLER_H\n#define ERRORHANDLER_H\n\n#include <string>\n#include \"IErrorHandler.h\"\n\nclass ErrorHandler : public IErrorHandler {\npublic:\n\n    void handleError(ErrorType error, const String& customMessage = \"\") override{\n    switch (error) {\n      case FileOpenError:\n        Serial.println(\"Error: Failed to open the file.\");\n        break;\n      case InvalidQuery:\n        Serial.println(\"Error: Invalid query format.\");\n        break;\n      case InvalidColumnName:\n        Serial.println(\"Error: Invalid column name.\");\n        break;\n      case CustomError:\n        Serial.println(\"Error: \" + customMessage);\n        break;\n      default:\n        Serial.println(\"Error: Unknown error.\");\n    }\n  }\n\n    void handleError(const String& errorMessage) override {\n        handleError(ErrorType::CustomError, errorMessage);\n    }\n\n  void handleError(ErrorType error) override {\n    handleError(error, \"\");\n  }\n};\n\n#endif // ERRORHANDLER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ErrorHandler\\IErrorHandler.h",
        "content": "#ifndef IERRORHANDLER_H\n#define IERRORHANDLER_H\n\n#include <string>\n\nenum ErrorType {\n    FileOpenError,\n    InvalidQuery,\n    InvalidColumnName,\n    CustomError,\n    TableDoesNotExist,\n    CalibrationSensorTriggeredWhileNotMoving,\n};\n\nclass IErrorHandler {\npublic:\n    virtual ~IErrorHandler() {}\n\n    virtual void handleError(ErrorType error, const String& customMessage) = 0;\n    virtual void handleError(ErrorType error) = 0;\n    virtual void handleError(const String& errorMessage) = 0;\n};\n\n#endif // IERRORHANDLER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\EventManager\\EventManager.h",
        "content": "//"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\FileManager\\EBPFile.h",
        "content": "// EBPFile.h\n#ifndef EBP_FILE_H\n#define EBP_FILE_H\n\n#include <Arduino.h>\n#if defined(ESP32)\n  #include <LittleFS.h>\n#elif defined(ESP8266)\n  #include <FS.h>\n#endif\n#include <SD.h>\n#include \"../Context.h\"\n#include \"../Config/System/SystemConfigKeys.h\"\n#include \"IEBPFile.h\"\n\n\nclass EBPFile : public IEBPFile {\nprivate:\n  StorageType _storageType;\npublic:\n    Context* context;\n    EBPFile(Context* cntxt, StorageType storage_type) : context(cntxt), _storageType(storage_type) {\n      initialize();\n      \n    }\n\n    EBPFile(Context* cntxt, File file, StorageType storage_type): EBPFile(cntxt, storage_type){\n      internalFile = file;\n    }\n\n    void initialize() override {\n      begin();\n    }\n\n    void setInternalFile(const File& file) {\n        internalFile = file;\n    }\n\n    size_t write(uint8_t val) override {\n        size_t result = internalFile.write(val);\n        // Add your code here.\n        return result;\n    }\n\n    std::vector<FileData> Browse(String path) override{\n        initialize();\n        std::vector<FileData> file_datas = std::vector<FileData>();\n        File root;\n        if (_storageType == SPIFFS_TYPE) {\n            root = LittleFS.open(path.c_str());\n        } else if (_storageType == SD_TYPE) {\n            root = SD.open(path.c_str());\n        }\n        if(root){\n          File file = root.openNextFile();\n          while(file){\n              FileData fileData = FileData(file.name(), file.size(), true, file.size() == 0 ? true : false);\n              file_datas.push_back(fileData);\n              Serial.println(file.name());\n              file = root.openNextFile();\n          }\n        }\n\n        return file_datas;\n    }\n\n\n    IEBPFile* open(String _path, String mode) override {\n      path = _path;\n      // initialize();\n\n      if (_storageType == SPIFFS_TYPE) {\n        internalFile = LittleFS.open(path.c_str(), mode.c_str());\n      } else if (_storageType == SD_TYPE) {\n        internalFile = SD.open(path.c_str(), mode.c_str());\n      }\n      return this;\n    }\n\n    bool begin() {\n      // return LittleFS.begin(true);\n      if (_storageType == SPIFFS_TYPE) {\n        #if defined(ESP32)\n          Serial.println(\"\\nin EBPFile.begin() -> befor LittleFS.begin()\");\n          \n          return true;\n          // return LittleFS.begin();\n        #elif defined(ESP8266)\n          return LittleFS.begin();\n        #endif\n      } else if (_storageType == SD_TYPE) {\n        return SD.begin();\n      }\n      return false;\n    }\n\n    bool exists(String path) {\n      if (_storageType == SPIFFS_TYPE) {\n        return LittleFS.exists(path);\n      } else if (_storageType == SD_TYPE) {\n        return SD.exists(path);\n      }\n      return false;\n    }\n\n    bool remove(String path) {\n      internalFile.close();\n      if (_storageType == SPIFFS_TYPE) {\n        return LittleFS.remove(path);\n      } else if (_storageType == SD_TYPE) {\n        return SD.remove(path);\n      }\n      return false;\n    }\n\n    bool rename(String pathFrom, String pathTo) {\n      if (_storageType == SPIFFS_TYPE) {\n        return LittleFS.rename(pathFrom, pathTo);\n      } else if (_storageType == SD_TYPE) {\n        return SD.rename(pathFrom, pathTo);\n      }\n      return false;\n    }\n\n    bool end() {\n      if (_storageType == SPIFFS_TYPE) {\n        #if defined(ESP32)\n          LittleFS.end();\n          return true;\n        #elif defined(ESP8266)\n          LittleFS.end();\n          return true;\n        #endif\n      } else if (_storageType == SD_TYPE) {\n        // There is no explicit end() function for SD, but you could add any cleanup code here if necessary.\n        return true;\n      }\n      return false;\n    }\n    \n    void close() override {\n        internalFile.close();\n    }\n\n    operator bool() override {\n        return static_cast<bool>(internalFile);\n    }\n\n    String name() override {\n        return internalFile.name();\n    }\n\n    int available() override {\n        return internalFile.available();\n    }\n\n    int peek() override {\n        return internalFile.peek();\n    }\n\n    void flush() override {\n        internalFile.flush();\n    }\n\n    int read() override {\n        return internalFile.read();\n    }\n\n    size_t readBytes(char *buffer, size_t length) override {\n        return internalFile.readBytes(buffer, length);\n    }\n\n    String readString() override {\n        return internalFile.readString();\n    }\n\n    String readStringUntil(char terminator) override {\n        return internalFile.readStringUntil(terminator);\n    }\n\n    long position() override {\n        return internalFile.position();\n    }\n\n    bool seek(uint32_t pos) override {\n        return internalFile.seek(pos);\n    }\n\n    long size() override {\n        return internalFile.size();\n    }\n\n    bool isDirectory() override {\n        return internalFile.isDirectory();\n    }\n\n    bool createDirectory(String path) override {\n      if (_storageType == StorageType::SD_TYPE)\n      {\n        return false;\n      }\n      \n      \n    }\n\n    IEBPFile* openNextFile(String mode) override {\n        internalFile = internalFile.openNextFile(mode.c_str());\n        return this;\n    }\n\n    void rewindDirectory() override {\n        internalFile.rewindDirectory();\n    }\n\n    bool isFile() override {\n        return !internalFile.isDirectory();\n    }\n\n    size_t getSize() override {\n        return internalFile.size();\n    }\n\n    size_t print(const __FlashStringHelper * str) override {\n        return internalFile.print(str);\n    }\n\n    size_t print(const String & str) override {\n        return internalFile.print(str);\n    }\n\n    size_t println(const String & str) override {\n        return internalFile.println(str);\n    }\n\n    size_t print(const char str[]) override {\n        return internalFile.print(str);\n    }\n\n    bool format() override {\n        if (_storageType == SPIFFS_TYPE) {\n            #if defined(ESP32)\n                return LittleFS.format();\n            #elif defined(ESP8266)\n                // ESP8266's LittleFS library does not have a format() function.\n                return false;\n            #endif\n        } else if (_storageType == SD_TYPE) {\n            // SD library does not have a format() function.\n            return false;\n        }\n        return false;\n    }\n\n    bool move(String dest) override {\n        if (rename(internalFile.name(), dest.c_str())) {\n            internalFile.close();\n            open(dest, \"r\");\n            return true;\n        }\n        return false;\n    }\n\n    bool copy(String dest) override {\n        File destFile;\n\n        if (_storageType == SPIFFS_TYPE) {\n            destFile = LittleFS.open(dest, \"w\");\n        } else if (_storageType == SD_TYPE) {\n            destFile = SD.open(dest, \"w\");\n        }\n\n        if (!destFile) {\n            return false;\n        }\n\n        internalFile.seek(0);\n\n        while (internalFile.available()) {\n            destFile.write(internalFile.read());\n        }\n\n        destFile.close();\n        return true;\n    }\n\n    bool duplicate() override {\n        String path = internalFile.path();\n        int dotIndex = path.lastIndexOf('.');\n        \n        // If a dot is found, add \"-Copy\" before the file extension\n        if (dotIndex >= 0) {\n          String newPath = path.substring(0, dotIndex) + \"-Copy\" + path.substring(dotIndex);\n          \n          // Pass the new path to the copy function\n          return copy(newPath);\n        }\n        \n        return false;\n    }\n\n    bool mkdir(String path) override {\n        return LittleFS.mkdir(path);\n    }\n\n};\n\n#endif // EBP_FILE_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\FileManager\\FileData.h",
        "content": "#ifndef FILEDATA_H\n#define FILEDATA_H\n\nclass FileData\n{\nprivate:\n    \npublic:\n    FileData(String _name, int _size, bool _isFolder, bool _isEmpty);\n    ~FileData();\n    String name;\n    int size;\n    bool isFile;\n    bool isEmpty;\n\n};\n\nFileData::FileData(String _name, int _size, bool _isFolder, bool _isEmpty)\n{\n    name = _name;\n    size = _size;\n    isFile = _isFolder;\n    isEmpty = _isEmpty;\n}\n\nFileData::~FileData()\n{\n}\n\n\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\FileManager\\IEBPFile.h",
        "content": "// IEBPFile.h\n#ifndef IEBP_FILE_H\n#define IEBP_FILE_H\n\n#include <Arduino.h>\n#include <FS.h>\n#include <LittleFS.h>\n#include <SD.h>\n#include \"FileData.h\"\n\nenum StorageType {\n  SPIFFS_TYPE,\n  SD_TYPE\n};\n\nclass IEBPFile {\npublic:\n    virtual ~IEBPFile() {}\n    File internalFile;\n    String path;\n    \n    virtual void initialize() = 0;\n\n    virtual size_t write(uint8_t val) = 0;\n\n    virtual bool begin() = 0;\n\n    virtual IEBPFile* open(String path, String mode) = 0;\n\n    virtual std::vector<FileData> Browse(String path) = 0;\n\n    virtual bool exists(String path) = 0;\n\n    virtual bool remove(String path) = 0;\n\n    virtual bool rename(String pathFrom, String pathTo) = 0;\n\n    virtual bool end() = 0;\n\n    virtual void close() = 0;\n    virtual operator bool() = 0;\n    virtual String name() = 0;\n\n    virtual int available() = 0;\n    virtual int peek() = 0;\n    virtual void flush() = 0;\n    virtual int read() = 0;\n    virtual size_t readBytes(char *buffer, size_t length) = 0; // Reads characters from the file into buffer\n    virtual String readString() = 0; // Reads a string from the file\n    virtual String readStringUntil(char terminator) = 0; // Reads a string from the file until a specific character\n    virtual long position() = 0; // Get the current position within the file\n    virtual bool seek(uint32_t pos) = 0; // Set the position within the file\n    virtual long size() = 0; // Get the size of the file\n    virtual bool createDirectory(String path) = 0; // create a directory\n    virtual bool isDirectory() = 0; // Check if the current file object is a directory\n    virtual IEBPFile* openNextFile(String mode) = 0;\n    virtual void rewindDirectory() = 0; // Resets a directory listing to the start\n    virtual bool isFile() = 0;\n    virtual size_t getSize() = 0;\n    virtual size_t print(const __FlashStringHelper *) = 0;\n    virtual size_t print(const String &) = 0;\n    virtual size_t println(const String &) = 0;\n    virtual size_t print(const char[]) = 0;    \n    virtual bool format() = 0;\n    virtual bool move(String dest) = 0;\n    virtual bool copy(String dest) = 0;\n    virtual bool duplicate() = 0;\n    virtual bool mkdir(String path) = 0;\n\n    static StorageType getStorageType(String storageTypeStr)\n    {\n      if (storageTypeStr == \"SPIFFS_TYPE\")\n      {\n        return StorageType::SPIFFS_TYPE;\n      } \n      else if (storageTypeStr == \"SD_TYPE\")\n      {\n        return StorageType::SD_TYPE;\n      }\n      return StorageType::SPIFFS_TYPE;      \n    }\n\n};\n\n#endif // IEBP_FILE_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\FrimwareManager\\FrimwareManager.h",
        "content": ""
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Logging\\ILog.h",
        "content": "#ifndef ILOG_H\n#define ILOG_H\n\n#include <Arduino.h>\n#include \"LogTitles.h\"\n\nclass SystemLog;\n\nclass ILog {\npublic:\n    virtual void infoDB(const String &table,String dbAction, const String &message) = 0;\n    virtual void info(const String &title, const String &message) = 0;\n    virtual void warning(const String &title, const String &message) = 0;\n    virtual void error(const String &title, const String &message) = 0;\n\n    virtual void onInfo(void (*func)(const String &)) = 0;\n    virtual void onWarning(void (*func)(const String &)) = 0;\n    virtual void onError(void (*func)(const String &)) = 0;\n    String value = \"\";\n};\n\n#endif // ILOG_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Logging\\Log.h",
        "content": "// path: .\\src\\Basic\\Logging\\Log.h\n\n#ifndef LOG_H\n#define LOG_H\n\n#include \"../Context.h\"\n#include \"../Database/Controllers/LogController.h\"\n#include \"ILog.h\"\n#include <memory>\n\n// #include \"../Events/EventSystem.h\"\n\nclass SystemLog : public ILog {\n\npublic:\n    Context* context;\n    LogController* logController;\n    // static EventSystem eventSystem;\n    \n    SystemLog(Context* cntxt):context(cntxt)\n    {\n        logController = new LogController(context, storageType);\n    }\n\n    void infoDB(const String &table,String dbAction, const String &message) override;\n    void info(const String &title, const String &message) override;\n    void warning(const String &title, const String &message) override;\n    void error(const String &title, const String &message) override;\n\n    void onInfo(void (*func)(const String &)) override;\n    void onWarning(void (*func)(const String &)) override;\n    void onError(void (*func)(const String &)) override;\n    String value = \"\";\n};\n\n// EventSystem Log::eventSystem;\n\nvoid SystemLog::infoDB(const String &table,String dbActionStr, const String &message)\n{\n    if (table != logController->_tableName)\n    {\n        info(LogTitles::DB_CHANGE , dbActionStr + \"::\" + message + \" at \" + table);\n    }    \n}\nvoid SystemLog::info(const String &title, const String &message) {\n    if(context->getConfig()->getSystemConfig()->get(title+LogTitles::_INFO_CHANGE) == \"true\")\n    {\n        LogEntity *logEntity = new LogEntity(LogEntity::Info, title, String(millis()), message);\n        logController->Add(*logEntity);\n    }\n    Serial.println(title + \" - \" + message);\n    // eventSystem.emit(\"info\", message);\n}\n\nvoid SystemLog::warning(const String &title, const String &message) {\n    // LogEntity logEntity;\n    // logEntity.logType = LogEntity::Warning;\n    // logEntity.message = message;\n    // logEntity.timestamp = String(millis());\n    \n    // if(context.getConfig()->get(title+\"_warning_save\") == \"true\")\n    // {\n    //     logController->Add(logEntity);\n    // }\n    // eventSystem.emit(\"warning\", message);\n}\n\nvoid SystemLog::error(const String &title, const String &message) {\n    // LogEntity logEntity;\n    // logEntity.logType = LogEntity::Error;\n    // logEntity.message = message;\n    // logEntity.timestamp = String(millis());\n    \n    // if(context.getConfig()->get(title+\"_error_save\") == \"true\")\n    // {\n    //     logController->Add(logEntity);\n    // }\n    // eventSystem.emit(\"error\", message);\n    Serial.print(\"Error - \");Serial.print(title);Serial.print(\" - \");Serial.print(message);Serial.print(\" - \");Serial.print(context->getClock()->now().toTimeString());\n}\n\nvoid SystemLog::onInfo(void (*func)(const String &)) {\n    // eventSystem.on(\"info\", func);\n}\n\nvoid SystemLog::onWarning(void (*func)(const String &)) {\n    // eventSystem.on(\"warning\", func);\n}\n\nvoid SystemLog::onError(void (*func)(const String &)) {\n    // eventSystem.on(\"error\", func);\n}\n\n#endif // LOG_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Logging\\LogTitles.h",
        "content": "#ifndef LOGTITLES_H\n#define LOGTITLES_H\n\nclass LogTitles\n{    \npublic:\n    //Database\n    static const String ADD_RECORD_TO_DB;\n    static const String UPDATE_RECORD_IN_DB;\n    static const String DELETE_RECORD_FROM_DB;\n    static const String REMOVE_COLUMN_FROM_DB;\n    static const String REMOVE_TABLE_FROM_DB;\n    \n    static const String ADD;\n    static const String UPDATE;\n    static const String DELETE;\n    static const String GET;\n    static const String REMOVE_COLUMN;\n    static const String REMOVE_TABLE;\n    \n    //System\n    static const String DB_CHANGE;\n    static const String SYSTEM_BOOT;\n    static const String _INFO_CHANGE;\n\n    //Modules\n    static const String BUTTON_LONG_PRESS;\n    static const String BUTTON_CLICK;\n    static const String RELAY_STATE_CHANGE;\n    static const String MODULE_NOT_FOUND_IN_DB;\n    static const String MODULE_ADDED_TO_DB;\n    static const String MODULE_NOT_ADDED_TO_DB;\n    \n    //SIM800\n    static const String SIM800_MESSAGE_RECIEVED;\n//MODULE_NOT_FOUND_IN_DB \n\n\n};\n\nconst String LogTitles::ADD_RECORD_TO_DB = \"add_record_to_db\";\nconst String LogTitles::UPDATE_RECORD_IN_DB = \"update_record_in_db\";\nconst String LogTitles::DELETE_RECORD_FROM_DB = \"delete_record_from_db\";\nconst String LogTitles::REMOVE_COLUMN_FROM_DB = \"remove_column_from_db\";\nconst String LogTitles::REMOVE_TABLE_FROM_DB = \"remove_table_from_db\";\n\nconst String LogTitles::ADD = \"add\";\nconst String LogTitles::UPDATE = \"update\";\nconst String LogTitles::DELETE = \"delete\";\nconst String LogTitles::GET = \"get\";\nconst String LogTitles::REMOVE_COLUMN = \"remove_column\";\nconst String LogTitles::REMOVE_TABLE = \"remove_table\";\n\nconst String LogTitles::DB_CHANGE = \"db_change\";\nconst String LogTitles::SYSTEM_BOOT = \"system_boot\";\nconst String LogTitles::_INFO_CHANGE = \"_info_save\";\n\nconst String LogTitles::BUTTON_LONG_PRESS = \"button_long_press\";\nconst String LogTitles::BUTTON_CLICK = \"button_click\";\nconst String LogTitles::RELAY_STATE_CHANGE = \"relay_state_changed\";\nconst String LogTitles::MODULE_NOT_FOUND_IN_DB = \"module_not_found_in_db\";\nconst String LogTitles::MODULE_ADDED_TO_DB = \"module_added_to_db\";\nconst String LogTitles::MODULE_NOT_ADDED_TO_DB = \"module_not_added_to_db\";\n\nconst String LogTitles::SIM800_MESSAGE_RECIEVED = \"sim800_message_recieved\";\n\n\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ModuleManager\\IModules.h",
        "content": "#ifndef IMODULES_H\n#define IMODULES_H\n\n#include <string>\n#include <PCF8574.h>\n#include \"Modules/Button.h\"\n#include \"Modules/Relay.h\"\n#include \"Modules/OLEDLCD.h\"\n#include \"Modules/LCD16X2.h\"\n#include \"Modules/SoilMoistureSensor.h\"\n#include \"Modules/ModuleTypes.h\"\n#include \"Modules/SimCardManager.h\"\n\nclass IModules\n{\npublic:\n    virtual ~IModules() = default;\n\n    virtual Button* getButton(String name) = 0;\n    virtual Button* getButton(String name, PCF8574* pcf8574) = 0;\n    virtual int addButton(Button* button) = 0;\n    \n    virtual Relay* getRelay(String name) = 0;\n    virtual int addRelay(Relay* relay) = 0;\n\n    virtual LCD16X2* getLCD16X2(String name) = 0;\n    virtual int addLCD16X2(LCD16X2* lcd16x2) = 0;\n    \n    virtual OLEDLCD* getOLEDLCD(String name) = 0;\n    virtual void addOLEDLCD(OLEDLCD* oledlcd) = 0;\n        \n    virtual SoilMoistureSensor* getSoilMoistureSensor(String name) = 0;\n    virtual void addSoilMoistureSensor(SoilMoistureSensor* soilMoistureSensor) = 0;\n    \n    virtual SimCardManager* getSimCardManager(int tx_pin, int rx_pin) = 0;\n\n    virtual void initialize() = 0;\n};\n\n#endif // IMODULES_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ModuleManager\\Modules.h",
        "content": "// Modules.h\n\n#ifndef MODULESS_H\n#define MODULESS_H\n\n#include \"IModules.h\"\n\n#include \"../Database/Entities/Modules/ButtonFullEntity.h\"\n#include \"../Database/Entities/Modules/RelayFullEntity.h\"\n#include \"../Database/Entities/Modules/DHTFullEntity.h\"\n#include \"../Database/Entities/Modules/LCDFullEntity.h\"\n#include \"../Database/Entities/Modules/PhotoresistorFullEntity.h\"\n#include \"../Database/Entities/Modules/RGBFullEntity.h\"\n#include \"../Database/Entities/Modules/SoilMoistureFullEntity.h\"\n\n#include \"../Database/Controllers/Modules/ModulesController.h\"\n\n#include \"../Context.h\"\n\nconst static String NOT_FOUNDED = \"notFounded\";\n\nclass Modules: public IModules\n{\nprivate:\n    Context* context;\n    ModulesController *modulesController;\n\n    std::vector<RelayFullEntity> relays;\n    std::vector<LCDFullEntity> lcd16x2s;\n    std::vector<LCDFullEntity> oledlcds;\n    std::vector<SoilMoistureFullEntity> sensors;\n\n    ButtonFullEntity buttonFull;\n    Button* _button;\n    Button* emptyButton;\n    SimCardManager* simCardManager;\n    PCF8574* _pcf8574;\n\npublic:\n    bool isNameUnique(String name);\n    Modules(Context* context);\n\n    Button* getButton(String name) override;\n    Button* getButton(String name, PCF8574* pcf8574) override;\n    int addButton(Button* button) override;\n    Relay* getRelay(String name) override;\n    int addRelay(Relay* relay) override;\n    LCD16X2* getLCD16X2(String name) override;\n    int addLCD16X2(LCD16X2* lcd16x2) override;\n    OLEDLCD* getOLEDLCD(String name) override;\n    void addOLEDLCD(OLEDLCD* oledlcd) override;\n    SoilMoistureSensor* getSoilMoistureSensor(String name) override;\n    void addSoilMoistureSensor(SoilMoistureSensor* soilMoistureSensor) override;\n    SimCardManager* getSimCardManager(int tx_pin, int rx_pin) override;\n    void initialize() override;\n};\n\nModules::Modules(Context* cntx): context(cntx)\n{\n\n}\n\nvoid Modules::initialize()\n{\n    modulesController = new ModulesController(context, storageType);\n}\n\nButton* Modules::getButton(String name)\n{\n    Button* button;\n    buttonFull = modulesController->getButtonByName(name);\n    button = new Button(buttonFull.PinNumber, name, buttonFull.ActiveHigh, buttonFull.PullupActive, buttonFull.ButtonType);\n    button->setDebounceDelay(buttonFull.DebounceDelay);\n    // button->setLongPressTime(buttonFull.)\n    return  button;\n}\n\nButton* Modules::getButton(String name, PCF8574* pcf8574)\n{\n    Button* button;\n    buttonFull = modulesController->getButtonByName(name);\n    if (buttonFull.ButtonType == \"PCF8574\")\n    {\n        button = new Button(buttonFull.PinNumber, name, buttonFull.ActiveHigh, buttonFull.PullupActive, Button::getButtonType(buttonFull.ButtonType), pcf8574);        \n    }\n    else if(buttonFull.ButtonType == \"PIN\")\n    {\n        button = new Button(buttonFull.PinNumber, name, buttonFull.ActiveHigh, buttonFull.PullupActive, buttonFull.ButtonType);\n    }\n    button->setDebounceDelay(buttonFull.DebounceDelay);\n    // button->setLongPressTime(buttonFull.)\n    return button;\n}\n\nint Modules::addButton(Button* button)\n{\n    ButtonFullEntity *buttonEntity = button->getEntity();\n    if (!isNameUnique(buttonEntity->Name))\n    {\n        return -1;\n    }\n    modulesController = new ModulesController(context, storageType);\n    int button_id = modulesController->AddButton(*buttonEntity);\n    context->getLogger()->info(LogTitles::MODULE_ADDED_TO_DB, \"Button name : \" + buttonEntity->Name);\n    return button_id;\n}\n\nRelay* Modules::getRelay(String name)\n{\n    relays = modulesController->getAllRelays();\n    for (size_t i = 0; i < relays.size(); i++)\n    {\n        RelayFullEntity relay = relays.at(i);\n        if (relay.Name == name)\n        {\n            return new Relay(relay.PinNumber, name, relay.NormallyOpen); \n        }        \n    }\n    context->getLogger()->error(LogTitles::MODULE_NOT_FOUND_IN_DB, \"Relay name : \" + name);\n    return new Relay(-1, NOT_FOUNDED, true); // Empty Relay\n}\n\nint32_t Modules::addRelay(Relay* relay)\n{\n    RelayFullEntity *relayEntity = relay->getEntity();\n    if (!isNameUnique(relayEntity->Name))\n    {\n        return -1;\n    }\n\n    int _id = modulesController->AddRelay(*relayEntity);\n    if(_id == -1)\n    {\n        context->getLogger()->error(LogTitles::MODULE_ADDED_TO_DB, \"Relay name : \" + relayEntity->Name);\n    }\n    else{\n        context->getLogger()->info(LogTitles::MODULE_NOT_ADDED_TO_DB, \"Relay name : \" + relayEntity->Name);\n    }\n    return _id;\n}\n\n// Continuing from previous code ...\n\nLCD16X2* Modules::getLCD16X2(String name)\n{\n    lcd16x2s = modulesController->getAllLCDs();\n    for (size_t i = 0; i < lcd16x2s.size(); i++)\n    {\n        LCDFullEntity oled = lcd16x2s.at(i);\n        if (oled.Name == name)\n        {\n            return new LCD16X2(name, oled.Address, oled.Cols, oled.Rows); \n        }        \n    }\n    context->getLogger()->error(LogTitles::MODULE_NOT_FOUND_IN_DB, \"LCD16X2 name : \" + name);\n    return new LCD16X2(NOT_FOUNDED, -1, 0, 0); // Empty LCD16X2\n}\n\nint Modules::addLCD16X2(LCD16X2* oledlcd)\n{\n    LCDFullEntity *oledEntity = oledlcd->getEntity();\n    if (!isNameUnique(oledEntity->Name))\n    {\n        return -1;\n    }\n    int _id = modulesController->AddLCD(*oledEntity);\n    if(_id == -1)\n    {\n        context->getLogger()->error(LogTitles::MODULE_NOT_ADDED_TO_DB, \"LCD16X2 name : \" + oledEntity->Name);\n    }\n    else{\n        context->getLogger()->info(LogTitles::MODULE_ADDED_TO_DB, \"LCD16X2 name : \" + oledEntity->Name);\n    }\n    return _id;\n}\n\nOLEDLCD* Modules::getOLEDLCD(String name)\n{\n    oledlcds = modulesController->getAllLCDs();\n    for (size_t i = 0; i < oledlcds.size(); i++)\n    {\n        LCDFullEntity lcd = oledlcds.at(i);\n        if (lcd.Name == name)\n        {\n            return new OLEDLCD(name, lcd.Address, lcd.Cols, lcd.Rows); \n        }        \n    }\n    context->getLogger()->error(LogTitles::MODULE_NOT_FOUND_IN_DB, \"LCDHandler name : \" + name);\n    return new OLEDLCD(NOT_FOUNDED, -1, 0, 0); // Empty LCDHandler\n}\n\nvoid Modules::addOLEDLCD(OLEDLCD* lcdHandler)\n{\n    LCDFullEntity *lcdEntity = lcdHandler->getEntity();\n    if (!isNameUnique(lcdEntity->Name))\n    {\n        return;\n    }\n    modulesController->AddLCD(*lcdEntity);\n    context->getLogger()->info(LogTitles::MODULE_ADDED_TO_DB, \"LCDHandler name : \" + lcdEntity->Name);\n}\n\nSoilMoistureSensor* Modules::getSoilMoistureSensor(String name)\n{\n    sensors = modulesController->getAllSoilMoistures();\n    for (size_t i = 0; i < sensors.size(); i++)\n    {\n        SoilMoistureFullEntity sensor = sensors.at(i);\n        if (sensor.Name == name)\n        {\n            return new SoilMoistureSensor(name, sensor.ConnectionType, sensor.NodeId, sensor.PinNumber, sensor.DryTreshold, sensor.WetTreshold); \n        }        \n    }\n    context->getLogger()->error(LogTitles::MODULE_NOT_FOUND_IN_DB, \"SoilMoistureSensor name : \" + name);\n    return new SoilMoistureSensor( NOT_FOUNDED,\"\" , -1, -1, 0, 0); // Empty SoilMoistureSensor\n}\n\nvoid Modules::addSoilMoistureSensor(SoilMoistureSensor* soilMoistureSensor)\n{\n    SoilMoistureFullEntity *sensorEntity = soilMoistureSensor->getEntity();\n    if (!isNameUnique(sensorEntity->Name))\n    {\n        return;\n    }\n    modulesController->AddSoilMoisture(*sensorEntity);\n    context->getLogger()->info(LogTitles::MODULE_ADDED_TO_DB, \"SoilMoistureSensor name : \" + sensorEntity->Name);\n}\n\nSimCardManager* Modules::getSimCardManager(int tx_pin, int rx_pin)\n{\n    return simCardManager;\n}\n\nbool Modules::isNameUnique(String name)\n{\n    std::vector<ModuleEntity> modules = modulesController->Get(String(ModuleEntity::COLUMN_NAME + \"=\" + name));\n    if (modules.size() == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }    \n}\n\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ModuleManager\\Modules\\Button.h",
        "content": "#ifndef BUTTON_H\n#define BUTTON_H\n\n#include <functional>\n#include <Arduino.h>\n#include <Wire.h>\n#include <PCF8574.h>\n#include \"../../Database/Entities/Modules/ButtonFullEntity.h\"\n#include \"ModuleTypes.h\"\n\nenum class ButtonType { PIN, PCF8574 };\nenum class ClickType { None, Clicked, LongPressClicked };\n\nclass Button\n{\npublic:\n    using ButtonCallback = std::function<void(Button*)>;\nprivate:\n    String name;\n    uint8_t pin_number;\n    PCF8574* pcf8574;\n    ButtonType buttonType;\n    bool activeHigh;\n    bool pullUpActive;\n    bool pressed;\n    bool lastState;\n    String connectionType;\n    int nodeId;\n    bool waitingForRelease; // new member variable to track button release\n    unsigned long lastDebounceTime;\n    unsigned long debounceDelay;\n    unsigned long longPressTime;\n    unsigned long buttonDownTime;\n    bool reading;\n    long press_time;\n    bool longPressTriggered = false;\n    uint8_t pcf_address;\n    bool onClickSeted;\n    bool onLongPressSeted;\n\n\n    ButtonCallback onClickFunction;\n    ButtonCallback onLongPressFunction;\npublic:\n    Button(uint8_t pin_number, String name, bool activeHigh, bool pullUpActive, ButtonType buttonType, PCF8574* pcf8574);\n    Button(uint8_t pin_number, String name, bool activeHigh, bool pullUpActive, ButtonType buttonType);\n    Button(uint8_t pin_number, String name, bool activeHigh, bool pullUpActive, String buttonTypeStr);\n    Button(uint8_t pin_number, String name, bool activeHigh, bool pullUpActive);\n    // Button();\n    \n    void setOnClick(ButtonCallback function);\n    void setOnLongPress(ButtonCallback function);\n    void setDebounceDelay(unsigned long delay);\n    void setLongPressTime(unsigned long time);\n    bool getState();\n    String getName();\n    void update();\n    ButtonFullEntity* getEntity();\n    static String getButtonType(ButtonType buttonType);\n    static ButtonType getButtonType(String buttonTypeStr);\n    int getPinNumber();\n    bool getActiveHigh();\n    bool getPullUpActive();\n};\n\n// Button::Button()\n// {\n    \n// }\nButton::Button(uint8_t _pin_number, String _name, bool _activeHigh, bool _pullUpActive, ButtonType _buttonType, PCF8574* _pcf8574)\n    : pin_number(_pin_number), activeHigh(_activeHigh), pullUpActive(_pullUpActive), name(_name), \n      pressed(false), lastState(false), lastDebounceTime(0), debounceDelay(60), longPressTime(2000), buttonDownTime(0),\n      buttonType(_buttonType), onClickFunction(NULL), onLongPressFunction(nullptr), pcf8574(_pcf8574), onClickSeted(false), onLongPressSeted(false)\n{\n    if (buttonType == ButtonType::PIN)\n    {\n        pinMode(pin_number, pullUpActive ? INPUT_PULLUP : INPUT);\n    }\n    else if(buttonType == ButtonType::PCF8574)\n    {\n        // pcf8574 = new PCF8574(pcf_address);//read from settings\n\t    \n        pcf8574->pinMode(pin_number, INPUT);\n        \n\n    }\n    lastState = false;\n    pressed = false;\n    \n}\nButton::Button(uint8_t _pin_number, String _name, bool _activeHigh, bool _pullUpActive, ButtonType _buttonType):\n    Button(_pin_number, _name, _activeHigh, _pullUpActive, _buttonType, 0)\n{\n\n}\nButton::Button(uint8_t _pin_number, String _name, bool _activeHigh = true, bool _pullUpActive = false):\n    Button(_pin_number, _name, _activeHigh, _pullUpActive, ButtonType::PIN)\n{\n\n}\n\nButton::Button(uint8_t _pin_number, String _name, bool _activeHigh, bool _pullUpActive, String _buttonTypeStr):\n    Button(_pin_number, _name, _activeHigh, _pullUpActive, Button::getButtonType(_buttonTypeStr))\n{\n\n}\n\nButtonFullEntity* Button::getEntity()\n{\n    String buttonTypeStr = Button::getButtonType(buttonType);\n    ButtonFullEntity *buttonEntity = new ButtonFullEntity(0, 0, name, ModuleTypes::BUTTON, connectionType, nodeId, pin_number,  buttonTypeStr, activeHigh, pullUpActive, debounceDelay);\n    return buttonEntity;\n}\n\nvoid Button::update() {\n    // Serial.print(\"*\");\n    uint8_t reading;\n\n    if (buttonType == ButtonType::PIN) {\n        reading = digitalRead(pin_number);\n    } else if (buttonType == ButtonType::PCF8574) {\n        reading = pcf8574->digitalRead(pin_number);\n        // Serial.print(\"PCF8574 pin = \");\n        // Serial.print(pin_number);\n        // Serial.print(\" => \");\n        // Serial.println(reading);\n    }\n\n    if (activeHigh) {\n        reading = !reading;\n    }\n\n    if (debounceDelay == 0 && reading == true && onClickSeted)\n    {\n        onClickFunction(this);\n        return;\n    }\n    \n    unsigned long now = millis();\n    if (reading != lastState && reading == true) {\n        lastDebounceTime = now;\n    }\n\n    // Serial.print(\"*\");\n    if ((now - lastDebounceTime) > debounceDelay) {\n        // Serial.print(\"1\");\n        if (reading != pressed) {\n            // Serial.print(\"2\");\n            pressed = reading;\n            if (pressed) {\n                // Serial.print(\"3\");\n                // Button pressed\n                buttonDownTime = now;\n                waitingForRelease = true; // set the flag to wait for button release\n            } else {\n                // Serial.print(\"4\");\n                // Button released\n                unsigned long pressDuration = now - buttonDownTime;\n                if (!longPressTriggered && (pressDuration >= debounceDelay)) {\n                    // Serial.print(\"5\");\n                    // onClickFunction(this);\n                }\n                longPressTriggered = false; // reset the longPressTriggered flag when the button is released\n                waitingForRelease = false; // reset the flag when the button is released\n            }\n        } else if (waitingForRelease && pressed) {\n                    // Serial.print(\"6\");\n            // Button is still pressed and waiting for release\n            if (now - buttonDownTime > debounceDelay) {\n                    // Serial.print(\"7\");\n                // Button held down after debounce delay, trigger onClickFunction again\n                if (onClickSeted)\n                {\n                    onClickFunction(this);\n                }\n                waitingForRelease = false; // reset the flag to wait for release again\n                \n            }\n        } else if (!longPressTriggered && pressed && longPressTime > 0 && (now - buttonDownTime) > longPressTime) {\n                    // Serial.print(\"8\");\n            // The button is pressed and longPressTime passed.\n            if (onLongPressSeted)\n            {\n                onLongPressFunction(this);\n                longPressTriggered = true;\n            }\n            \n        }\n    }\n    // Serial.println(\"*\");\n    lastState = reading;\n}\n\nvoid Button::setOnClick(ButtonCallback function)\n{\n    onClickSeted = true;\n    onClickFunction = function;\n}\n\nvoid Button::setOnLongPress(ButtonCallback function)\n{\n    onLongPressSeted = true;\n    onLongPressFunction = function;\n}\n\nvoid Button::setDebounceDelay(unsigned long delay)\n{\n    debounceDelay = delay;\n}\n\nvoid Button::setLongPressTime(unsigned long time)\n{\n    longPressTime = time;\n}\n\nbool Button::getState()\n{\n    return pressed;\n}\n\nString Button::getName()\n{\n    return name;\n}\n\nString Button::getButtonType(ButtonType buttonType)\n{\n    if (buttonType == ButtonType::PIN)\n    {\n        return \"PIN\";\n    }\n    else if (buttonType == ButtonType::PCF8574)\n    {\n        return \"PCF8574\";\n    }\n}\n\nButtonType Button::getButtonType(String buttonTypeStr)\n{\n    if (buttonTypeStr == \"PIN\")\n    {\n        return ButtonType::PIN;\n    }\n    else if (buttonTypeStr == \"PCF8574\")\n    {\n        return ButtonType::PCF8574;\n    }    \n\n}\n\nint Button::getPinNumber()\n{\n    return pin_number;\n}\n\nbool Button::getActiveHigh()\n{\n    return activeHigh;\n}\n\nbool Button::getPullUpActive()\n{\n    return pullUpActive;\n}\n\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ModuleManager\\Modules\\IButton.h",
        "content": "#ifndef IBUTTON_H\n#define IBUTTON_H\n\n#include <Arduino.h>\n#include <Wire.h>\n#include <PCF8574.h>\n#include \"../../Database/Entities/Modules/ButtonFullEntity.h\"\n\nenum class ButtonType { PIN, PCF8574 };\nenum class ClickType { None, Clicked, LongPressClicked };\n\nclass IButton\n{\npublic:\n    \n    virtual void setOnClick(void (*function)(IButton*)) = 0;\n    virtual void setOnLongPress(void (*function)(IButton*)) = 0;\n    virtual void setDebounceDelay(unsigned long delay) = 0;\n    virtual void setLongPressTime(unsigned long time) = 0;\n    virtual bool getState() = 0;\n    virtual String getName() = 0;\n    virtual void update() = 0;\n    virtual ButtonFullEntity* getEntity() = 0;\n    virtual ~IButton() {}\n};\n\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ModuleManager\\Modules\\ILCD.h",
        "content": "#ifndef ILCD_H\n#define ILCD_H\n\n#include <SPI.h>\n#include <Wire.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n#include \"../../Database/Entities/Modules/LCDFullEntity.h\"\n\nenum LCDTypes {OLED_LCD, LCD_16X2};\n\nclass ILCD\n{\npublic:\n    virtual void drawText(String text, int textSize) = 0;\n    virtual void Clean() = 0;\n    virtual LCDFullEntity* getEntity() = 0;\n    static String getLCDType(LCDTypes lcdType)\n    {\n        if (lcdType == LCDTypes::LCD_16X2)\n        {\n            return \"LCD16X2\";\n        }\n        else if (lcdType == LCDTypes::OLED_LCD)\n        {\n            return \"OLED\";\n        }\n    }\n\n    static LCDTypes getLCDType(String lcdTypeStr)\n    {\n        if (lcdTypeStr == \"LCD16X2\")\n        {\n            return LCDTypes::LCD_16X2;\n        }\n        else if (lcdTypeStr == \"OLED\")\n        {\n            return LCDTypes::OLED_LCD;\n        }    \n   \n    }\n};\n\n\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ModuleManager\\Modules\\IRelay.h",
        "content": "#ifndef IRELAY_H\n#define IRELAY_H\n\n#include \"../../Database/Entities/Modules/RelayFullEntity.h\"\n#include <Arduino.h>\n\nclass IRelay\n{\npublic:\n    virtual void turnOn() = 0;\n    virtual void turnOff() = 0;\n    virtual bool getState() = 0;\n    virtual void update() = 0;\n    virtual void turnOnAfterDelay(unsigned long delay_millis) = 0;\n    virtual void turnOffAfterDelay(unsigned long delay_millis) = 0;\n    virtual void turnOnForDelay(unsigned long delay_millis) = 0;\n    virtual void turnOffForDelay(unsigned long delay_millis) = 0;\n    virtual RelayFullEntity* getEntity() = 0;\n\n\n};\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ModuleManager\\Modules\\ISoilMoistureSensor.h",
        "content": "#ifndef ISOILMOISTURESENSOR_H\n#define ISOILMOISTURESENSOR_H\n\n#include <string>\n#include \"../../Database/Entities/Modules/SoilMoistureFullEntity.h\"\n\nclass ISoilMoistureSensor {\npublic:\n    virtual ~ISoilMoistureSensor() {}\n    virtual void initialize() = 0;\n    virtual int readMoisture() = 0;\n    virtual bool isDry() = 0;\n    virtual bool isWet() = 0;\n    virtual String getName() = 0;\n    virtual String getConnectionType() = 0;\n    virtual int getNodeId() = 0;\n    virtual int getSensorPin() = 0;\n    virtual int getDryThreshold() = 0;\n    virtual int getWetThreshold() = 0;\n    virtual SoilMoistureFullEntity* getEntity() = 0;\n\n};\n\n#endif //ISOILMOISTURESENSOR_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ModuleManager\\Modules\\LCD16X2.h",
        "content": "#ifndef LCD16x2_H\n#define LCD16x2_H\n\n#include \"ModuleTypes.h\"\n#include <SPI.h>\n#include <Wire.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n#include \"../../Database/Entities/Modules/LCDFullEntity.h\"\n\nclass LCD16X2\n{\nprivate:\n    String name;\n    String connectionType;\n    int nodeId;\n    int SCREEN_WIDTH = 128; // OLED display width, in pixels\n    int SCREEN_HEIGHT = 32; // OLED display height, in pixels\n    int SCREEN_ADDRESS = 0x3C;\n    int OLED_RESET = -1;\n    Adafruit_SSD1306 display;\n\npublic:\n    LCD16X2(String _name, int address, int width, int hight);\n    void drawText(String text, int textSize);\n    void Clean();\n    LCDFullEntity* getEntity();\n    static String getLCDType(LCDTypes lcdType);\n    static LCDTypes getLCDType(String lcdTypeStr);\n};\n\nLCD16X2::LCD16X2(String _name, int address, int width, int height) : display(width, height, &Wire, OLED_RESET)\n{\n    SCREEN_WIDTH = width;\n    SCREEN_HEIGHT = height;\n    SCREEN_ADDRESS = address;\n    name = _name;\n    connectionType = \"\";\n    nodeId = 0;\n    \n    if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {\n        Serial.println(F(\"SSD1306 allocation failed\"));\n        for(;;); // Don't proceed, loop forever\n    }\n    display.display();\n    delay(2000); // Pause for 2 seconds\n\n    // Clear the buffer\n    display.clearDisplay();\n    display.setTextSize(1);\n    display.setCursor(5, 5);\n    display.println(\"E-B-P\");\n    // Show the display buffer on the screen. You MUST call display() after\n    // drawing commands to make them visible on screen!\n    display.display();\n    delay(2000);\n}\n\nLCDFullEntity* LCD16X2::getEntity()\n{\n    String lcdTypeStr = getLCDType(LCDTypes::LCD_16X2);\n    LCDFullEntity *lcdEntity = new LCDFullEntity(0, 0, name, ModuleTypes::LCD, connectionType, nodeId, -1,  SCREEN_ADDRESS, SCREEN_HEIGHT, SCREEN_WIDTH, lcdTypeStr);\n    return lcdEntity;\n}\n\nvoid LCD16X2::drawText(String text, int textSize)\n{\n    display.clearDisplay();\n\n    display.setTextSize(textSize); // Draw 2X-scale text\n    display.setTextColor(SSD1306_WHITE);\n    display.setCursor(10, 0);\n    display.println(text);\n    display.display();\n}\n\nvoid LCD16X2::Clean()\n{\n    display.clearDisplay();\n    display.display();\n}\n\nString LCD16X2::getLCDType(LCDTypes lcdType)\n{\n    if (lcdType == LCDTypes::LCD_16X2)\n    {\n        return \"LCD16X2\";\n    }\n    else if (lcdType == LCDTypes::OLED_LCD)\n    {\n        return \"OLED\";\n    }\n}\n\nLCDTypes LCD16X2::getLCDType(String lcdTypeStr)\n{\n    if (lcdTypeStr == \"LCD16X2\")\n    {\n        return LCDTypes::LCD_16X2;\n    }\n    else if (lcdTypeStr == \"OLED\")\n    {\n        return LCDTypes::OLED_LCD;\n    }    \n\n}\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ModuleManager\\Modules\\ModuleTypes.h",
        "content": "#ifndef MODULETYPES_h\n#define MODULETYPES_h\n\nenum LCDTypes {OLED_LCD, LCD_16X2};\n\nclass ModuleTypes {\npublic:\n    static const String BUTTON;\n    static const String RELAY;\n    static const String SOILMOISTURE;\n    static const String LCD;\n    static const String DHT;\n    static const String RGB;\n    static const String PHOTORESISTOR;\n};\n\nconst String ModuleTypes::BUTTON = \"Button\";\nconst String ModuleTypes::RELAY = \"Relay\";\nconst String ModuleTypes::SOILMOISTURE = \"SoilMoisture\";\nconst String ModuleTypes::LCD = \"LCD\";\nconst String ModuleTypes::DHT = \"DHT\";\nconst String ModuleTypes::RGB = \"RGB\";\nconst String ModuleTypes::PHOTORESISTOR = \"PhotoResistor\";\n\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ModuleManager\\Modules\\OLEDLCD.h",
        "content": "#ifndef OLEDLCD_H\n#define OLEDLCD_H\n\n#include \"ModuleTypes.h\"\n#include <Wire.h>\n#include <LiquidCrystal_I2C.h>\n#include <SPI.h>\n#include <Wire.h>\n#include <Adafruit_GFX.h>\n#include <Adafruit_SSD1306.h>\n#include \"../../Database/Entities/Modules/LCDFullEntity.h\"\n\nclass OLEDLCD {\n  private:\n    String name;\n    uint8_t lcdColumns; \n    uint8_t lcdRows;\n    uint8_t lcdAddress;\n    String connectionType;\n    int nodeId;\n    LiquidCrystal_I2C lcd;\n\n  public:\n    OLEDLCD(String name, uint8_t address, uint8_t columns, uint8_t rows) \n      : lcdColumns(columns), lcdRows(rows), lcdAddress(address), name(name), lcd(address, columns, rows)\n      {\n        begin();\n      }\n\n    void begin() {\n      lcd.begin(lcdColumns, lcdRows);\n      lcd.init();\n      lcd.init();\n      lcd.backlight();\n      lcd.clear();\n    }\n\n    LCDFullEntity* getEntity()\n    {\n        String lcdTypeStr = getLCDType(LCDTypes::LCD_16X2);\n        LCDFullEntity *lcdEntity = new LCDFullEntity(0, 0, name, ModuleTypes::LCD, connectionType, nodeId, -1,  lcdAddress, lcdRows, lcdColumns, lcdTypeStr);\n        return lcdEntity;\n    }\n    void print(const String& message) {\n      lcd.print(message);\n    }\n\n    void printAt(uint8_t col, uint8_t row, const String& message) {\n      lcd.setCursor(col, row);\n      lcd.print(message);\n    }\n\n    void drawText(String text, int textSize)\n    {\n      print(text);\n    }\n\n    void Clean(){\n      lcd.clear();\n    }\n\n    static String getLCDType(LCDTypes lcdType)\n    {\n        if (lcdType == LCDTypes::LCD_16X2)\n        {\n            return \"LCD16X2\";\n        }\n        else if (lcdType == LCDTypes::OLED_LCD)\n        {\n            return \"OLED\";\n        }\n    }\n\n    static LCDTypes getLCDType(String lcdTypeStr)\n    {\n        if (lcdTypeStr == \"LCD16X2\")\n        {\n            return LCDTypes::LCD_16X2;\n        }\n        else if (lcdTypeStr == \"OLED\")\n        {\n            return LCDTypes::OLED_LCD;\n        }    \n   \n    }\n};\n\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ModuleManager\\Modules\\Relay.h",
        "content": "#ifndef RELAY_H\n#define RELAY_H\n\n#include \"ModuleTypes.h\"\n#include \"../../Database/Entities/Modules/RelayFullEntity.h\"\n\nclass Relay\n{\nprivate:\n    String name;\n    int pin_number;\n    String connectionType;\n    int nodeId;\n    bool state;\n    bool normallyOpen;\n    unsigned long delay_millis;\n    unsigned long start_time;\n    enum { IDLE, TURN_ON_AFTER_DELAY, TURN_OFF_AFTER_DELAY, TURN_ON_FOR_DELAY, TURN_OFF_FOR_DELAY } mode;\n\npublic:\n    Relay(int pin_number, String name, bool normallyOpen = true);\n\n    void turnOn();\n    void turnOff();\n    bool getState();\n    void update();\n    void turnOnAfterDelay(unsigned long delay_millis);\n    void turnOffAfterDelay(unsigned long delay_millis);\n    void turnOnForDelay(unsigned long delay_millis);\n    void turnOffForDelay(unsigned long delay_millis);\n    RelayFullEntity* getEntity();\n\n};\n\nRelay::Relay(int pin_number, String name, bool normallyOpen)\n    : pin_number(pin_number), state(false), name(name), normallyOpen(normallyOpen), mode(IDLE)\n{\n    pinMode(pin_number, OUTPUT);\n    digitalWrite(pin_number, normallyOpen ? LOW : HIGH);\n}\n\nRelayFullEntity* Relay::getEntity()\n{\n    return new RelayFullEntity(0, 0, name, ModuleTypes::RELAY, connectionType, nodeId, pin_number, normallyOpen);\n}\n\nvoid Relay::turnOn()\n{\n    digitalWrite(pin_number, normallyOpen ? HIGH : LOW);\n    if (!state)\n    {\n        state = true;\n    }\n}\n\nvoid Relay::turnOff()\n{\n    digitalWrite(pin_number, normallyOpen ? LOW : HIGH);\n    if(state)\n    {\n        state = false;\n    }\n}\n\nbool Relay::getState()\n{\n    return state;\n}\n\nvoid Relay::update()\n{\n    switch(mode)\n    {\n        case TURN_ON_AFTER_DELAY:\n            if (millis() - start_time >= delay_millis)\n            {\n                turnOn();\n                mode = IDLE;\n            }\n            break;\n        case TURN_OFF_AFTER_DELAY:\n            if (millis() - start_time >= delay_millis)\n            {\n                turnOff();\n                mode = IDLE;\n            }\n            break;\n        case TURN_ON_FOR_DELAY:\n            if (millis() - start_time >= delay_millis)\n            {\n                turnOff();\n                mode = IDLE;\n            }\n            break;\n        case TURN_OFF_FOR_DELAY:\n            if (millis() - start_time >= delay_millis)\n            {\n                turnOn();\n                mode = IDLE;\n            }\n            break;\n    }\n}\n\nvoid Relay::turnOnAfterDelay(unsigned long delay_millis)\n{\n    this->delay_millis = delay_millis;\n    start_time = millis();\n    mode = TURN_ON_AFTER_DELAY;\n}\n\nvoid Relay::turnOffAfterDelay(unsigned long delay_millis)\n{\n    this->delay_millis = delay_millis;\n    start_time = millis();\n    mode = TURN_OFF_AFTER_DELAY;\n}\n\nvoid Relay::turnOnForDelay(unsigned long delay_millis)\n{\n    turnOn();\n    this->delay_millis = delay_millis;\n    start_time = millis();\n    mode = TURN_ON_FOR_DELAY;\n}\n\nvoid Relay::turnOffForDelay(unsigned long delay_millis)\n{\n    turnOff();\n    this->delay_millis = delay_millis;\n    start_time = millis();\n    mode = TURN_OFF_FOR_DELAY;\n}\n\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ModuleManager\\Modules\\SimCardManager.h",
        "content": "#ifndef SIMCARDMANAGER_H\n#define SIMCARDMANAGER_H\n\n#include <Arduino.h>\n#include <HardwareSerial.h>\n\nusing MessageCallback = std::function<void(String, String)>;\n\nclass SimCardManager\n{\npublic:\n    SimCardManager(int rxPin, int txPin) : _sim800(1), _rxPin(rxPin), _txPin(txPin), _lastMillis(0) \n    {\n      initialize();\n    }\n\n    void initialize() {\n        _sim800.begin(4800, SERIAL_8N1, _rxPin, _txPin); // RX, TX\n        delay(1000);\n        _sim800.println(\"AT\");\n        delay(1000);\n        _sim800.println(\"AT+CMGF=1\");\n        delay(1000);\n        _sim800.println(\"AT+CNMI=1,2,0,0,0\");\n        delay(1000);\n        // Other initialization can be added here\n    }\n\nvoid update() {\n  if (_sim800.available() && millis() - _lastMillis > 1000) {\n    String response = _sim800.readString();\n    Serial.println(response);\n\n    // parse the response, extract phone number and message\n    String phoneNumber = \"\"; \n    String message = \"\"; \n\n    // check if the response contains \"+CMT:\"\n    int indexCMT = response.indexOf(\"+CMT:\");\n    if (indexCMT != -1) {\n      int indexFirstQuote = response.indexOf(\"\\\"\", indexCMT);\n      int indexSecondQuote = response.indexOf(\"\\\"\", indexFirstQuote + 1);\n      \n      // extract the phone number\n      phoneNumber = response.substring(indexFirstQuote + 1, indexSecondQuote);\n      \n      // extract the message\n      int indexNewLine = response.indexOf(\"\\n\", indexSecondQuote);\n      if (indexNewLine != -1) {\n        message = response.substring(indexNewLine + 1);\n        message.trim();  // remove leading/trailing whitespaces\n      }\n    }\n\n    if (_onMessageReceived && phoneNumber != \"\" && message != \"\") {\n      _onMessageReceived(phoneNumber, message);\n    }\n\n    _lastMillis = millis();\n  }\n}\n\n    bool sendMessage(String phoneNumber, String message) {\n        _sim800.println(\"AT+CMGF=1\"); // set to SMS mode\n        _sim800.print(\"AT+CMGS=\\\"\");\n        _sim800.print(phoneNumber);\n        _sim800.println(\"\\\"\");\n\n        _sim800.println(message);\n        _sim800.write(26); // send Ctrl+Z\n\n        // here you could check if the message was sent successfully\n        // return true if successful, false otherwise\n        return true;\n    }\n\n    void setOnMessageReceived(MessageCallback function) {\n        _onMessageReceived = function;\n    }\n\nprivate:\n    HardwareSerial _sim800;\n    int _rxPin, _txPin;\n    unsigned long _lastMillis;\n    MessageCallback _onMessageReceived;\n};\n\n#endif //SIMCARDMANAGER_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\ModuleManager\\Modules\\SoilMoistureSensor.h",
        "content": "#ifndef SOILMOISTURE_H\n#define SOILMOISTURE_H\n\n#include \"ISoilMoistureSensor.h\"\n#include <string>\n#include \"ModuleTypes.h\"\n\nclass SoilMoistureSensor : public ISoilMoistureSensor {\nprivate:\n  String name;\n  String connectionType;\n  int nodeId;\n  int sensorPin;       // Pin connected to the soil moisture sensor\n  int dryThreshold;    // Threshold value indicating dry soil\n  int wetThreshold;    // Threshold value indicating wet soil\n\npublic:\n  SoilMoistureSensor(String name, String connectionType, int nodeId, int sensorPin, int dryThreshold, int wetThreshold)\n    : name(name), connectionType(connectionType), nodeId(nodeId), sensorPin(sensorPin), dryThreshold(dryThreshold), wetThreshold(wetThreshold) {}\n\n  void initialize() override {\n    pinMode(sensorPin, INPUT);\n  }\n\n  int readMoisture() override {\n    int moisture = analogRead(sensorPin);\n    return moisture;\n  }\n\n  bool isDry() override {\n    int moisture = readMoisture();\n    return moisture <= dryThreshold;\n  }\n\n  bool isWet() override {\n    int moisture = readMoisture();\n    return moisture >= wetThreshold;\n  }\n\n  String getName() override {\n    return name;\n  }\n\n  String getConnectionType() override {\n    return connectionType;\n  }\n\n  int getNodeId() override {\n    return nodeId;\n  }\n\n  int getSensorPin() override {\n    return sensorPin;\n  }\n\n  int getDryThreshold() override {\n    return dryThreshold;\n  }\n\n  int getWetThreshold() override {\n    return wetThreshold;\n  }\n\n  SoilMoistureFullEntity* getEntity() override\n  {\n    SoilMoistureFullEntity *soilMoistureEntity = new SoilMoistureFullEntity(0, 0, name, ModuleTypes::SOILMOISTURE, connectionType, nodeId, sensorPin,  dryThreshold, wetThreshold, \"Analog\");\n    return soilMoistureEntity;\n  }\n};\n\n\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\INetwork.h",
        "content": "#ifndef INETWORK\n#define INETWORK\n#include <HTTPS_Server_Generic.h>\n// #include \"MeshNetwork/IMeshNetworkManager.h\"\n#include \"WiFi/IWiFiManager.h\"\n#include \"MeshNetwork/Receive.h\"\n#include \"LambdaResourceNode.h\"\n\nusing namespace httpsserver;\n\nstruct CertificateData{\n    unsigned char* certificate;\n    uint16_t certificate_length;\n    unsigned char* privatekey;\n    uint16_t privateky_length;\n};\n\nclass INetwork {\npublic:\n    virtual void initialize() = 0;\n    virtual void addApis(std::vector<ApiInterface*> apis) = 0;\n    virtual void update() = 0;\n    // virtual IMeshNetworkManager* getMeshManager() = 0;\n    virtual IWiFiManager* getWiFiManager() = 0;\n    virtual HTTPServer& getHTTPServer() = 0;\n    virtual HTTPSServer& getHTTPSServer() = 0;\n    virtual void addApi(ResourceNode* api) = 0;\n    virtual void addUrlNotFound(ResourceNode* api) = 0;\n    virtual Receive* getReceive() = 0;\n\n};\n\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\LambdaResourceNode.h",
        "content": "#ifndef LAMBDARESOURCENODE_H\n#define LAMBDARESOURCENODE_H\n\n#include <map>\n#include <string>\n#include <functional>\n\nclass LambdaResourceNode : public httpsserver::ResourceNode {\npublic:\n    LambdaResourceNode(const std::string &path, const std::string &method, \n                       std::function<void(HTTPRequest *, HTTPResponse *)> lambda)\n    : httpsserver::ResourceNode(path, method, &LambdaResourceNode::staticHandler), \n      lambda_(lambda) {\n        lambdaMap_[path] = lambda;\n    }\n\n    static const std::string REQUEST_METHOD_GET;\n    static const std::string REQUEST_METHOD_POST;\n    static const std::string REQUEST_METHOD_PUT;\n    static const std::string REQUEST_METHOD_DELETE;\n\nprivate:\n    std::function<void(HTTPRequest *, HTTPResponse *)> lambda_;\n    static std::map<std::string, std::function<void(HTTPRequest *, HTTPResponse *)>> lambdaMap_;\n\n    static void staticHandler(HTTPRequest *req, HTTPResponse *res) {\n        std::string path = req->getRequestString(); // Get the path from the request\n        auto it = lambdaMap_.find(path);\n        if (it != lambdaMap_.end()) {\n            it->second(req, res); // Execute the lambda function associated with the path\n        }\n    }\n};\n\nstd::map<std::string, std::function<void(HTTPRequest *, HTTPResponse *)>> LambdaResourceNode::lambdaMap_;\n\n\nconst std::string LambdaResourceNode::REQUEST_METHOD_GET = \"GET\";\nconst std::string LambdaResourceNode::REQUEST_METHOD_POST = \"POST\";\nconst std::string LambdaResourceNode::REQUEST_METHOD_PUT = \"PUT\";\nconst std::string LambdaResourceNode::REQUEST_METHOD_DELETE = \"DELETE\";\n#endif //LAMBDARESOURCENODE_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\Network.h",
        "content": "#ifndef Network_H\n#define Network_H\n\n#define ASYNC_TCP_SSL_ENABLED 1\n\n#include \"INetwork.h\"\n#include \"IPAddress.h\"\n#if defined(ESP8266)\n#include <ESP8266HTTPClient.h>\n#else\n#include <HTTPClient.h>\n#endif\n#include \"../Context.h\"\n// #include \"MeshNetwork/MeshNetworkManager.h\"\n#include \"WiFi/WiFiManager.h\"\n\n#include \"apis/FileApis.h\"\n#include \"apis/WiFiApis.h\"\n#include \"apis/SystemConfigApis.h\"\n#include \"apis/SSIDApis.h\"\n#include \"apis/Modules/AddModulesApis.h\"\n#include \"apis/Authorization/AuthorizationApis.h\"\n\n// The HTTPS Server comes in a separate namespace. For easier use, include it here.\nusing namespace httpsserver;\n\nstruct ServerTaskParams {\n    HTTPSServer* httpsServer;\n    HTTPServer* httpServer;\n    bool https_enabled;\n    // Add other members as needed\n};\n\nclass Network : public INetwork {\nprivate:\n    // AsyncWebServer server;\n    HTTPServer* httpServer;\n    HTTPSServer* httpsServer;\n    // HTTPClient http;\n    Context* context;\n    Receive receive;\n    SSLCert cert;\n\n    void configureWebServer();\n    void rebootESP(String message);\n    // MeshNetworkManager* meshManager;\n    WiFiManager* wiFiManager;\n    CertificateData _certificateData;\n    static void serverTask(ServerTaskParams* params);\n    static void serverTaskWrapper(void *params);\n\npublic:\n    Network(Context* context);\n    Network(Context* context, CertificateData certificateDate);\n    void initialize() override;\n    void addApi(ResourceNode* api) override;\n    void addUrlNotFound(ResourceNode* api) override;\n    void addApis(std::vector<ApiInterface*> apis) override;\n    void update() override;\n    // IMeshNetworkManager* getMeshManager() override;\n    IWiFiManager* getWiFiManager() override;\n    HTTPServer& getHTTPServer() override;\n    HTTPSServer& getHTTPSServer() override;\n\n    Receive* getReceive() override;\n    void begin();\n};\n\nNetwork::Network(Context* cntxt) : context(cntxt)\n{\n\n}\n\nNetwork::Network(Context* ctxt, CertificateData certificateData): context(ctxt), _certificateData(certificateData)\n{\n\n}\n\nvoid Network::rebootESP(String message) {\n    Serial.print(\"Rebooting ESP: \"); Serial.println(message);\n    ESP.restart();\n}\n\nHTTPServer& Network::getHTTPServer()\n{\n  return *httpServer;\n}\n\nHTTPSServer& Network::getHTTPSServer()\n{\n  return *httpsServer;\n}\n\nReceive* Network::getReceive()\n{\n  return &receive;\n}\n\nvoid Network::configureWebServer() {\n    if (_https_enabled)\n    {\n      \n      cert = SSLCert(\n                      _certificateData.certificate, _certificateData.certificate_length,\n                      _certificateData.privatekey, _certificateData.privateky_length\n                    );\n\n      // First, we create the HTTPSServer with the certificate created above\n      httpsServer = new HTTPSServer(&cert);\n      // Additionally, we create an HTTPServer for unencrypted traffic\n    }\n    httpServer = new HTTPServer();\n\n    WiFiApis *wifiApis = new WiFiApis(context, true);\n    FileApis *fileApis = new FileApis(context, true);\n    SSIDApis *ssidApis = new SSIDApis(context, true);\n    SystemConfigAPis *systemConfigAPis = new SystemConfigAPis(context, true);\n\n    //add API classes to mesh callback message parser\n    //receive.registerClass(fileApis->getClassPath(), fileApis);\n    //receive.registerClass(ssidApis->getClassPath(), ssidApis);\n    //receive.registerClass(systemConfigAPis->getClassPath(), systemConfigAPis);\n    //receive.registerClass(wifiApis->getClassPath(), wifiApis);\n    \n    createAuthorizationApis(context);\n    // createModulesApis(context);\n}\n\nvoid Network::addUrlNotFound(ResourceNode* api)\n{\n  httpServer->setDefaultNode(api);\n  if (_https_enabled)\n  {\n    httpsServer->setDefaultNode(api);\n  }\n}\n\nvoid Network::addApi(ResourceNode* api)\n{\n  httpServer->registerNode(api);\n  if (_https_enabled)\n  {\n    httpsServer->registerNode(api);\n  }\n}\n\nvoid Network::addApis(std::vector<ApiInterface*> apis)\n{\n  for (size_t i = 0; i < apis.size(); i++)\n  {\n    ApiInterface* api = apis.at(i);\n    receive.registerClass(String(api->getClassPath().c_str()), api);\n  } \n}\n\nvoid Network::begin() {\n  Serial.println(\"Starting Webserver ...\");\n    \n  ServerTaskParams* params = new ServerTaskParams;\n  params->httpsServer = httpsServer;\n  params->httpServer = httpServer;\n  params->https_enabled = _https_enabled;\n  // Set other members as needed\n  xTaskCreatePinnedToCore(serverTaskWrapper, \"https443\", 6144, params, 1, NULL, ARDUINO_RUNNING_CORE);\n}\n\nvoid Network::serverTaskWrapper(void *params) {\n    \n    ServerTaskParams* taskParams = static_cast<ServerTaskParams*>(params);\n    Network::serverTask(taskParams);\n}\n\nvoid Network::serverTask(ServerTaskParams* params) {\n    // Use params->httpsServer and params->httpServer here\n    params->httpServer->start();\n    if (params->https_enabled)\n    {\n      params->httpsServer->start();\n    }\n    \n\n    if (params->httpServer->isRunning())\n    {\n      Serial.println(\"HTTP Server is ready.\");\n      if(params->https_enabled  && params->httpsServer->isRunning())\n      {\n        Serial.println(\"HTTPS Server is ready.\");\n      }\n\n      // \"loop()\" function of the separate task\n      while (true)\n      {\n        // This call will let the server do its work\n        params->httpServer->loop();\n        if (params->https_enabled)\n        {\n          params->httpsServer->loop();\n        }\n\n        // Other code would go here...\n        delay(1);\n      }\n    }\n    \n}\n\nvoid Network::initialize() {\n  Serial.println(\"\\nLoading Network Configuration ...\");\n  \n  // meshManager = new MeshNetworkManager(*context);\n  wiFiManager = new WiFiManager(context);\n\n  int stationCount = 0;\n\n  // WiFi.mode(WIFI_MODE_AP);\n  if(context->getConfig()->getSystemConfig()->get(SystemConfigKey::WIFI_MODE_AP) == \"true\")\n  {\n    wiFiManager->configureAccessPointMode();\n    stationCount = stationCount + 1;\n  }\n  if(context->getConfig()->getSystemConfig()->get(SystemConfigKey::WIFI_MODE_WIFI) == \"true\")\n  {\n    if(stationCount > 1)\n    {\n      context->getLogger()->error(\"********************************\",\"Mesh and AccesPoint are active and Wifi can not run. but it is true.\");\n      return;\n    }\n    else if(stationCount == 1)\n    {\n      // WiFi.mode(WIFI_MODE_STA);\n    }\n    else\n    {\n      // WiFi.mode(WIFI_MODE_STA);\n    }\n    wiFiManager->configureStationMode();\n  }\n  if(context->getConfig()->getSystemConfig()->get(SystemConfigKey::WIFI_MODE_MESH) == \"true\")\n  {\n    // meshManager->initialize();\n    stationCount = stationCount + 1;\n  }\n\n  else\n  {\n    if (stationCount == 0)\n    {\n      wiFiManager->configureAccessPointMode();\n    }    \n  }\n  wiFiManager->displayNetworkInfo();\n  configureWebServer();\n\n  \n}\n\nvoid Network::update() {\n  // meshManager->loop();  \n    // syncDatabaseLoop();\n}\n\n// IMeshNetworkManager* Network::getMeshManager()\n// {\n//   return meshManager;\n// }\n\nIWiFiManager* Network::getWiFiManager()\n{\n  return wiFiManager;\n}\n\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\ApiInterface.h",
        "content": "#ifndef APIINTERFACE_H\n#define APIINTERFACE_H\n\n// ApiInterface.h\n#include <map>\n#include <string>\n#include <sstream>\n#include <Arduino.h>\n#include <HTTPS_Server_Generic.h>\n#include \"../../FileManager/IEBPFile.h\"\n\nusing namespace httpsserver;\n\nclass ApiInterface {\npublic:\n    virtual String callFunction(String functionName, std::map<String, String> parameters) = 0;\n    virtual String getClassPath() = 0;\n\n    static const String MISSING_INPUT_PARAMS_MESSAGE;\n    static const String CREATE_SUCCESFULL_MESSAGE;\n    static const String CREATE_FAILED_MESSAGE;\n    static const String DELETE_FAILED_MESSAGE;\n    static const String DELETE_SUCCESFULL_MESSAGE;\n    static const String UPDATE_SUCCESFULL_MESSAGE;\n    static const String UPDATE_FAILED_MESSAGE;\n    static const String NO_FUNCTION_MESSAGE;\n    static const String PAGE_NOT_FOUND_MESSAGE;\n};\n\nconst String ApiInterface::MISSING_INPUT_PARAMS_MESSAGE = \"missing some input params in your request\";\nconst String ApiInterface::CREATE_FAILED_MESSAGE = \"Create Operation Failed!\";\nconst String ApiInterface::CREATE_SUCCESFULL_MESSAGE = \"Create Succesfull\";\nconst String ApiInterface::DELETE_FAILED_MESSAGE = \"Delete Operation Failed!\";\nconst String ApiInterface::DELETE_SUCCESFULL_MESSAGE = \"Delete Succesfull\";\nconst String ApiInterface::UPDATE_SUCCESFULL_MESSAGE = \"Update Succesfull\";\nconst String ApiInterface::UPDATE_FAILED_MESSAGE = \"Update Operation Failed!\";\nconst String ApiInterface::NO_FUNCTION_MESSAGE = \"There is no function named \";\nconst String ApiInterface::PAGE_NOT_FOUND_MESSAGE = \"<!DOCTYPE html><html><body style=\\\"background-color:black; color:white; text-align:center; height:100vh; display:flex; align-items:center; justify-content:center; margin:0;\\\"><h1>Page Not Found!</h1></body></html>\";\n\n\nvoid response(HTTPResponse * res, int status_code, String status_text, String content_type, String response_text)\n{\n    res->setStatusCode(status_code);\n    res->setStatusText(status_text.c_str());\n    res->setHeader(\"Content-Type\", content_type.c_str());\n    res->println(response_text);\n}\n\nvoid response(HTTPResponse * res, int status_code, String content_type, String response_text)\n{\n    res->setStatusCode(status_code);\n    res->setStatusText(String(status_code).c_str());\n    res->setHeader(\"Content-Type\", content_type.c_str());\n    res->println(response_text);\n}\n\nvoid response(HTTPResponse * res, int status_code, String response_text)\n{\n    res->setStatusCode(status_code);\n    res->setStatusText(String(status_code).c_str());\n    res->setHeader(\"Content-Type\", \"text/html\");\n    res->println(response_text);\n}\n\nvoid response(HTTPResponse * res, String response_text)\n{\n    Serial.println(\"responssse-1\");\n    res->setStatusCode(200);\n    Serial.println(\"responssse-2\");\n    res->setStatusText(\"Succesfull\");\n    Serial.println(\"responssse-3\");\n    res->setHeader(\"Content-Type\", \"text/html\");\n    Serial.println(\"responssse-4\");\n    res->println(response_text);\n    Serial.println(\"responssse-5\");\n}\n\nString getQueryParameterString(HTTPRequest * req, String parameter)\n{\n    std::string output;\n    req->getParams()->getQueryParameter(parameter.c_str(), output);\n    return String(output.c_str());\n}\n\nint getQueryParameterint(HTTPRequest * req, String parameter)\n{\n    std::string output;\n    req->getParams()->getQueryParameter(parameter.c_str(), output);\n    int number;\n    std::stringstream ss(output);\n\n    if (ss >> number && ss.eof()) {\n        // Successfully converted to an int\n        return number;\n    } else {\n        // Conversion failed, return -9999\n        return -9999;\n    }\n}\n\nvoid DownloadFile(HTTPResponse *res, String filename, String contentType, StorageType storageType) {\n  // Set content type based on file extension\n//   std::string _contentType = \"application/octet-stream\"; // Default content type\n    std::string _contentType ; // Default content type\n    if (contentType == \"\")\n    {\n        // Determine content type based on file extension\n        if (filename.endsWith(\".html\")) {\n            _contentType = \"text/html\";\n        } else if (filename.endsWith(\".css\")) {\n            _contentType = \"text/css\";\n        } else if (filename.endsWith(\".js\")) {\n            _contentType = \"application/javascript\";\n        } else if (filename.endsWith(\".json\")) {\n            _contentType = \"application/json\";\n        } else if (filename.endsWith(\".png\")) {\n            _contentType = \"image/png\";\n        } else if (filename.endsWith(\".jpg\") || filename.endsWith(\".jpeg\")) {\n            _contentType = \"image/jpeg\";\n        } else if (filename.endsWith(\".svg\")) {\n            _contentType = \"image/svg+xml\";\n        } else if (filename.endsWith(\".gif\")) {\n            _contentType = \"image/gif\";\n        } else if (filename.endsWith(\".pdf\")) {\n            _contentType = \"application/pdf\";\n        } else if (filename.endsWith(\".xml\")) {\n            _contentType = \"application/xml\";\n        } else if (filename.endsWith(\".txt\") || filename.endsWith(\".db\")) {\n            _contentType = \"text/plain\";\n        } else if (filename.endsWith(\".mp3\")) {\n            _contentType = \"audio/mpeg\";\n        } else if (filename.endsWith(\".mp4\")) {\n            _contentType = \"video/mp4\";\n        } else if (filename != \"\") {\n            // Set a default content type for unknown file types\n            _contentType = \"application/octet-stream\";\n        } \n    } else {\n        // if contentType is filled by user, add it to header content type\n        _contentType = std::string(contentType.c_str());\n    }\n  \n    File file;\n    if (storageType == StorageType::SPIFFS_TYPE) {\n        file = LittleFS.open(filename.c_str(), \"r\");\n    } else if (storageType == StorageType::SD_TYPE) {\n        file = SD.open(filename.c_str(), \"r\");\n    }\n\n  // Set response headers\n//   res->setHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + std::string(filename.c_str()) + \"\\\"\");\n    res->setHeader(\"Content-Type\", _contentType);\n//   res->setHeader(\"Content-Length\", std::string(String(file.size()).c_str()));\n\n    // Send the file content\n    uint8_t buffer[256];\n    size_t bytesRead;\n\n    while ((bytesRead = file.read(buffer, sizeof(buffer))) > 0) {\n        res->write(buffer, bytesRead);\n    }\n\n    // Close the file\n    file.close();\n}\n\nvoid RedirectUrl(HTTPResponse * res, String url)\n{\n    res->setStatusCode(303);\n    res->setStatusText(\"See Other\");\n    res->setHeader(\"Location\", url.c_str());\n    res->println(\"Redirecting...\");    \n}\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\FileApis.h",
        "content": "#ifndef FILE_API_H\n#define FILE_API_H\n\n#include \"../../Context.h\"\n#include \"FileManager/EBPFile.h\"\n#include <ArduinoJson.h>\n#include \"ApiInterface.h\"\n#include \"SystemPermissions.h\"\n\nclass FileApis : public ApiInterface{\nprivate:\n    Context* context;\n\npublic:\n    std::string class_path = \"/fileApi\";\n    FileApis(Context* context, bool add_apis);\n    String getClassPath() override;\n\n    String handleBrowseFolder(String path, int offset, int count, StorageType _storageType);\n    String handleOpen(String path, String mod, StorageType _storageType);\n    void handleFileUploadAndRedirect(HTTPRequest *req, HTTPResponse *res, String path, StorageType storageType_path);\n    void handleRoot(HTTPResponse* res);\n    String handleDelete(String path, StorageType _storageType);\n    String handleWrite(String path, String content, StorageType _storageType);\n    String handleFormat(StorageType _storageType);\n    String handleRename(String path, String new_name, StorageType _storageType);\n    String handleMove(String source_path, String destination_path, StorageType _storageType);\n    String handleCopy(String source_path, String destination_path, StorageType _storageType);\n    String handleDuplicate(String path, StorageType _storageType);\n    String handleMkDir(String path, StorageType _storageType);\n    \n    String callFunction(String functionName, std::map<String, String> parameters);\n    \n};\n\nFileApis::FileApis(Context* cntxt, bool add_apis) : context(cntxt) {\n    if (!add_apis) return;\n    \n    context->getNetwork()->addApi(new ResourceNode(\"/\", LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        this->handleRoot(res);\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/browse_folder\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        if(req->getParams()->isQueryParameterSet(\"path\")) {\n            String path = getQueryParameterString(req, \"path\");\n            int offset = 0;\n            int count = 1000;\n            if(req->getParams()->isQueryParameterSet(\"offset\") && req->getParams()->isQueryParameterSet(\"count\")) {\n                offset = getQueryParameterint(req, \"offset\");\n                count = getQueryParameterint(req, \"count\");\n            }\n            \n            StorageType _storageType = storageType;\n            if(req->getParams()->isQueryParameterSet(\"storage_type\"))\n            {\n                _storageType = EBPFile::getStorageType(getQueryParameterString(req, \"storage_type\"));\n            }\n\n            response(res, 200, \"application/json\", handleBrowseFolder(path, offset, count, _storageType));\n        } else {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n        }\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/open\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        StorageType _storageType = storageType;\n        if(req->getParams()->isQueryParameterSet(\"storage_type\"))\n        {\n            _storageType = EBPFile::getStorageType(getQueryParameterString(req, \"storage_type\"));\n        }\n        if(req->getParams()->isQueryParameterSet(\"path\")) {\n            String path = getQueryParameterString(req, \"path\");\n            String content = this->handleOpen(path, \"r\", _storageType);\n            response(res, content);\n        } else {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n        }\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        StorageType _storageType = storageType;\n        if(req->getParams()->isQueryParameterSet(\"storage_type\"))\n        {\n            _storageType = EBPFile::getStorageType(getQueryParameterString(req, \"storage_type\"));\n        }\n        if(req->getParams()->isQueryParameterSet(\"path\")) {\n            String path = getQueryParameterString(req, \"path\");\n            String content = handleDelete(path, _storageType);\n            response(res, content);\n        } else {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n        }\n\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/write\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        StorageType _storageType = storageType;\n        if(req->getParams()->isQueryParameterSet(\"storage_type\"))\n        {\n            _storageType = EBPFile::getStorageType(getQueryParameterString(req, \"storage_type\"));\n        }\n        \n        if(req->getParams()->isQueryParameterSet(\"path\") && req->getParams()->isQueryParameterSet(\"content\")) {\n            String path = getQueryParameterString(req, \"path\");\n            String content = handleWrite(path, content, _storageType);\n            response(res, handleWrite(path, content, _storageType));\n        } else {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n        }\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/format\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        StorageType _storageType = storageType;\n        if(req->getParams()->isQueryParameterSet(\"storage_type\"))\n        {\n            _storageType = EBPFile::getStorageType(getQueryParameterString(req, \"storage_type\"));\n        }\n        \n        response(res, handleFormat(_storageType));\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/rename\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        StorageType _storageType = storageType;\n        if(req->getParams()->isQueryParameterSet(\"storage_type\"))\n        {\n            _storageType = EBPFile::getStorageType(getQueryParameterString(req, \"storage_type\"));\n        }\n        \n        if(req->getParams()->isQueryParameterSet(\"path\") && req->getParams()->isQueryParameterSet(\"new_name\")) {\n            String path = getQueryParameterString(req, \"path\");\n            String new_name = getQueryParameterString(req, \"new_name\");\n            response(res, handleRename(path, new_name, _storageType));\n        } else {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n        }\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/move\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        StorageType _storageType = storageType;\n        if(req->getParams()->isQueryParameterSet(\"storage_type\"))\n        {\n            _storageType = EBPFile::getStorageType(getQueryParameterString(req, \"storage_type\"));\n        }\n        \n        if(req->getParams()->isQueryParameterSet(\"source_path\") && req->getParams()->isQueryParameterSet(\"destination_path\")) {\n            String source_path = getQueryParameterString(req, \"source_path\");\n            String destination_path = getQueryParameterString(req, \"destination_path\");\n            response(res, handleMove(source_path, destination_path, _storageType));\n        } else {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n        }\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/copy\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        StorageType _storageType = storageType;\n        if(req->getParams()->isQueryParameterSet(\"storage_type\"))\n        {\n            _storageType = EBPFile::getStorageType(getQueryParameterString(req, \"storage_type\"));\n        }\n        \n        if(req->getParams()->isQueryParameterSet(\"source_path\") && req->getParams()->isQueryParameterSet(\"destination_path\")) {\n            String source_path = getQueryParameterString(req, \"source_path\");\n            String destination_path = getQueryParameterString(req, \"destination_path\");\n            response(res, handleCopy(source_path, destination_path, _storageType));\n        } else {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n        }\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/duplicate\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        StorageType _storageType = storageType;\n        if(req->getParams()->isQueryParameterSet(\"storage_type\"))\n        {\n            _storageType = EBPFile::getStorageType(getQueryParameterString(req, \"storage_type\"));\n        }\n        \n        if(req->getParams()->isQueryParameterSet(\"path\")) {\n            String path = getQueryParameterString(req, \"path\");\n            response(res, handleDuplicate(path, _storageType));\n        } else {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n        }\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/mkdir\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        StorageType _storageType = storageType;\n        if(req->getParams()->isQueryParameterSet(\"storage_type\"))\n        {\n            _storageType = EBPFile::getStorageType(getQueryParameterString(req, \"storage_type\"));\n        }\n        \n        if(req->getParams()->isQueryParameterSet(\"path\")) {\n            String path = getQueryParameterString(req, \"path\");\n            response(res, handleMkDir(path, _storageType));\n        } else {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n        }\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(\"/test\", LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        Serial.println(\"test\");\n        response(res, \"TEST\");\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(\"/files\", LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        String file_html = String(R\"rawliteral(\n            <!DOCTYPE html><html lang=\"en\"><head><meta charset=\"UTF-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><title>File Manager</title><style>body{font-family:Arial,sans-serif;color:#333}#container{display:flex;height:100vh}#nav{flex:1;border-right:1px solid #ccc;overflow:auto;padding:20px}#content{flex:2;padding:20px}table{width:100%;border-collapse:collapse}th,td{padding:10px;text-align:left}tr:nth-child(even){background-color:#f2f2f2}.icon{width:20px;height:20px;margin-right:10px}#upload-form{display:flex;align-items:center;gap:10px;margin-bottom:20px}.custom-file-upload{padding:5px 10px;background:#3498db;color:#fff;border-radius:5px;cursor:pointer}.custom-file-upload:hover{background:#2980b9}#file-upload{display:none}.upload-btn{padding:5px 10px;background:#2ecc71;border:none;color:#fff;border-radius:5px;cursor:pointer}.upload-btn:hover{background:#27ae60}#storage-toggle{margin-right:10px}.storage_info{width:0;height:0}#storage-toggle{display:flex;justify-content:center;padding:10px;background-color:#f2f2f2;border-radius:30px;margin-bottom:20px}#storage-toggle label{cursor:pointer;padding:10px 20px;border-radius:20px;font-weight:bold}input[type=\"radio\"]{display:none}input[type=\"radio\"]:checked+label{background-color:#3498db;color:#fff}#file-path{margin-left:10px;border:none;background:#f2f2f2;padding:5px 10px;border-radius:5px;font-size:16px;color:#555;box-shadow:0 2px 5px rgba(0,0,0,.1);transition:box-shadow .3s ease}#file-path:focus{box-shadow:0 2px 5px rgba(0,0,0,.2);outline:none}.custom-file-upload{padding:5px 10px;background:#3498db;color:#fff;border-radius:5px;cursor:pointer;display:inline-block;transition:background .3s ease}.custom-file-upload:hover{background:#2980b9}</style></head><body><div id=\"container\"><div id=\"nav\"><h2>Folders</h2><ul id=\"folders\"></ul></div><div id=\"content\"><div id=\"storage-toggle\"><input type=\"radio\" id=\"SD\" name=\"storage\" value=\"SD_TYPE\" onchange=\"handleStorageToggle()\"><label for=\"SD\">SD</label><input type=\"radio\" id=\"LittleFS\" name=\"storage\" value=\"SPIFFS_TYPE\" checked onchange=\"handleStorageToggle()\"><label for=\"LittleFS\">SPIFFS</label></div><form method=\"POST\" action=\"/upload_spiffs\" enctype=\"multipart/form-data\" id=\"upload-form\"><label for=\"file-upload\" class=\"custom-file-upload\"><i class=\"fa fa-cloud-upload\"></i> Choose File</label><input id=\"file-upload\" type=\"file\" name=\"data\" onchange=\"showFileName()\"/><input type=\"text\" id=\"file-path\" readonly><button type=\"submit\" name=\"upload\" class=\"upload-btn\" title=\"Upload File\">Upload</button></form><h2 id=\"currentPath\"></h2><table><thead><tr><th>Name</th><th>Type</th><th>Size</th><th>Actions</th></tr></thead><tbody id=\"files\"></tbody></table></div></div><div id=\"storage-info\" style=\"visibility: hidden;\"><span id=\"currentStorage\">SD</span></div><script>let currentPath=\"/\",currentData=null,currentStorage=\"SD\";function handleStorageToggle(){var e=document.getElementById(\"upload-form\"),n=document.getElementsByName(\"storage\");for(var t=0,r=n.length;t<r;t++)if(n[t].checked){n[t].value==\"SD_TYPE\"?e.action=\"/upload_sd\":e.action=\"/upload_spiffs\",currentStorage=event.target.value,document.getElementById(\"currentStorage\").textContent=currentStorage,browse(currentPath);break}}function browse(e){fetch(`/fileApi/browse_folder?path=${e}&storage_type=${currentStorage}`).then(e=>e.json()).then(e=>(currentData=e,updateView(e))).catch(e=>{console.error(\"Error:\",e)})}function updateView(e){document.getElementById(\"currentPath\").textContent=currentPath;const n=document.getElementById(\"files\");while(n.firstChild)n.firstChild.remove();for(const t of e){let e=window.location.origin;const r=document.createElement(\"tr\");let o=t.is_file?\"\ud83d\udcc4\":\"\ud83d\udcc1\";t.name=t.name.startsWith(\"/\")?t.name.slice(1):t.name;let c=e+\"/\"+t.name;r.innerHTML=`<td><a href=\"${c}\" target=\"_blank\" class=\"fileLink\"><span class=\"icon\">${o}</span>${t.name}</a></td><td>${t.is_file?\"file\":\"directory\"}</td><td>${t.size||\"\"}</td><td><button onclick=\"openItem('${t.name}')\">Open</button><button>Rename</button><button onclick=\"deleteItem('${t.name}')\">Delete</button></td>`,n.appendChild(r)}}function openItem(e){const n=currentPath.endsWith(\"/\")?e:e,t=currentData.find(e=>e.name===n);t&&!t.is_file?(currentPath=n,browse(currentPath)):t&&fetch(`/fileApi/open?path=${currentPath+n}&storage_type=${currentStorage}`).then(e=>e.text()).then(e=>{const n=window.open(\"\",\"_blank\");n.document.write(`<pre>${e}</pre>`)}).catch(e=>{console.error(\"Error:\",e)})}function deleteItem(e){fetch(`/fileApi/delete?path=${currentPath}${e}&storage_type=${currentStorage}`,{method:\"DELETE\"}).then(e=>e.headers.get(\"content-type\")===\"application/json\"?e.json():e.text()).then(e=>{typeof e===\"string\"||e.success?(alert(\"Deleted \"+e),browse(currentPath)):alert(\"Error: \"+e.error)}).catch(e=>{console.error(\"Error:\",e)})}function showFileName(){const e=document.getElementById(\"file-upload\"),n=document.getElementById(\"file-path\");n.value=e.value.split(\"\\\\\").pop()}browse(currentPath)</script></body></html>\n\n\n            )rawliteral\");\n        response(res, file_html);\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(\"/upload_spiffs\", LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        handleFileUploadAndRedirect(req, res, \"/\", StorageType::SPIFFS_TYPE);\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(\"/upload_sd\", LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        handleFileUploadAndRedirect(req, res, \"\", StorageType::SD_TYPE);\n    }));\n    \n    context->getNetwork()->addUrlNotFound(new ResourceNode(\"\", LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        \n        String _path = String(req->getRequestString().c_str());//request->urlDecode(request->url());\n        Serial.println(_path);\n        String content_type = \"\";\n        \n        StorageType _storageType = storageType;\n        if(req->getParams()->isQueryParameterSet(\"storage_type\"))\n        {\n            _storageType = EBPFile::getStorageType(getQueryParameterString(req, \"storage_type\"));\n        }\n\n        bool file_in_storage = false;\n        if (_storageType == StorageType::SD_TYPE)\n        {\n            if(context->getSD()->exists(_path)) file_in_storage = true;\n        }\n        else\n        {\n            if(context->getLittleFS()->exists(_path)) file_in_storage = true;\n        }\n\n        if(req->getParams()->isQueryParameterSet(\"content_type\")) {\n            content_type = getQueryParameterString(req, \"content_type\");\n        }\n\n        if (file_in_storage)\n        {\n            DownloadFile(res, _path, content_type, storageType);\n        }\n        else\n        {\n            response(res, PAGE_NOT_FOUND_MESSAGE);\n        }\n        \n    }));\n}\n\nString FileApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString FileApis::callFunction(String functionName, std::map<String, String> parameters) {\n    StorageType _storageType = EBPFile::getStorageType(parameters[\"storage_type\"]);\n\n    if (functionName == \"handleBrowseFolder\") {\n        return handleBrowseFolder(parameters[\"path\"], parameters[\"offset\"].toInt(), parameters[\"count\"].toInt(), _storageType);\n    } else if (functionName == \"handleOpen\") {\n        return handleOpen(parameters[\"path\"], parameters[\"mod\"], _storageType);\n    } else if (functionName == \"handleDelete\") {\n        return handleDelete(parameters[\"path\"], _storageType);\n    } else if (functionName == \"handleWrite\") {\n        return handleWrite(parameters[\"path\"], parameters[\"content\"], _storageType);\n    } else if (functionName == \"handleFormat\") {\n        return handleFormat(_storageType);\n    } else if (functionName == \"handleRename\") {\n        return handleRename(parameters[\"path\"], parameters[\"new_name\"], _storageType);\n    } else if (functionName == \"handleMove\") {\n        return handleMove(parameters[\"source_path\"], parameters[\"destination_path\"], _storageType);\n    } else if (functionName == \"handleCopy\") {\n        return handleCopy(parameters[\"source_path\"], parameters[\"destination_path\"], _storageType);\n    } else if (functionName == \"handleDuplicate\") {\n        return handleDuplicate(parameters[\"path\"], _storageType);\n    } else {\n        return \"Error: The function doesn't exist\";\n    }\n}\n\nvoid FileApis::handleRoot(HTTPResponse* res)\n{\n    String _path;\n    bool fileExists = false;\n    _path = \"/index.html\";\n    if (storageType == StorageType::SPIFFS_TYPE)\n    {\n        if (context->getLittleFS()->exists(_path))\n        {\n            fileExists = true;\n        }\n    }\n    else if (storageType == StorageType::SD_TYPE)\n    {\n        if (context->getSD()->exists(_path))\n        {\n            fileExists = true;\n        }\n    }\n\n    if (fileExists)\n    {\n        DownloadFile(res, _path, \"text/html\", storageType);\n    }\n    \n    _path = \"/files.html\";\n    if (storageType == StorageType::SPIFFS_TYPE)\n    {\n        if (context->getLittleFS()->exists(_path))\n        {\n            fileExists = true;\n        }\n    }\n    else if (storageType == StorageType::SD_TYPE)\n    {\n        if (context->getSD()->exists(_path))\n        {\n            fileExists = true;\n        }\n    }\n\n    if (fileExists)\n    {\n        DownloadFile(res, _path, \"text/html\", storageType);\n    }\n    else{\n        RedirectUrl(res, \"/files\");\n    }\n}\n\n\nString FileApis::handleBrowseFolder(String path, int offset, int count, StorageType _storageType) {\n    std::vector<FileData> files;\n    if (_storageType == StorageType::SPIFFS_TYPE)\n    {\n        files = context->getLittleFS()->Browse(path);\n    }\n    else if (_storageType == StorageType::SD_TYPE)\n    {\n        files = context->getSD()->Browse(path);\n    }     \n\n    DynamicJsonDocument doc(2048);\n    JsonArray array = doc.to<JsonArray>();\n\n    // Implementing the pagination\n    int currentCount = 0;\n    for(int i = offset; i < files.size() && currentCount < count; i++, currentCount++) {\n        JsonObject obj = array.createNestedObject();\n        obj[\"name\"] = files[i].name;\n        obj[\"is_file\"] = files[i].isFile;\n        obj[\"is_empty\"] = files[i].isEmpty;\n        obj[\"size\"] = files[i].size;        \n    }\n\n    String response;\n    serializeJson(doc, response);\n\n    return response;\n}\n\nString FileApis::handleOpen(String path, String mod, StorageType _storageType) {\n    if (_storageType == StorageType::SPIFFS_TYPE)\n    {\n        return context->getLittleFS()->open(path, mod)->readString();\n    }\n    else if (_storageType == StorageType::SD_TYPE)\n    {\n        return context->getSD()->open(path, mod)->readString();\n    } \n}\n\nString FileApis::handleDelete(String path, StorageType _storageType) {\n    bool success = false;\n    if (_storageType == StorageType::SPIFFS_TYPE)\n    {\n        success = context->getLittleFS()->remove(path);\n    }\n    else if (_storageType == StorageType::SD_TYPE)\n    {\n        success = context->getSD()->remove(path);\n    } \n\n    if (success)\n    {\n        return \"File Deleted Succesfull.\";\n    }else{\n        return \"An error occured while Delete file.\";\n    }    \n}\n\nString FileApis::handleWrite(String path, String content, StorageType _storageType) {\n    if (_storageType == StorageType::SPIFFS_TYPE)\n    {\n        context->getLittleFS()->open(path, \"w\");\n        context->getLittleFS()->print(content);\n    }\n    else if (_storageType == StorageType::SD_TYPE)\n    {\n        context->getSD()->open(path, \"w\");\n        context->getSD()->print(content);\n    } \n    return \"File writed succesfully.\";\n}\n\nString FileApis::handleFormat(StorageType _storageType) {\n    bool success = false;\n    if (_storageType == StorageType::SPIFFS_TYPE)\n    {\n        if(context->getLittleFS()->format())\n        {\n            success = true;\n        }\n    }\n    else if (_storageType == StorageType::SD_TYPE)\n    {\n        if(context->getSD()->format())\n        {\n            success = true;\n        }\n    } \n\n    if (success)\n    {\n        return \"Storage Formated Succesfull\";\n    }else {\n        return \"An error occured while formating\";\n    }\n    \n}\n\nString FileApis::handleRename(String path, String new_name, StorageType _storageType) {\n    bool success = false;\n    if (_storageType == StorageType::SPIFFS_TYPE)\n    {\n        if(context->getLittleFS()->rename(path, new_name))\n        {\n            success = true;\n        }\n    }\n    else if (_storageType == StorageType::SD_TYPE)\n    {\n        if(context->getSD()->rename(path, new_name))\n        {\n            success = true;\n        }\n    } \n\n    if (success)\n    {\n        return \"File renamed Succesfull\";\n    }else {\n        return \"An error occured while renaming file\";\n    }\n}\n\nString FileApis::handleMove(String source_path, String destination_path, StorageType _storageType) {\n    bool success = false;\n    if (_storageType == StorageType::SPIFFS_TYPE)\n    {\n        if (context->getLittleFS()->open(source_path, \"w\"))\n        {\n            if(context->getLittleFS()->move(destination_path))\n            {\n                success = true;\n            }\n        }\n    }\n    else if (_storageType == StorageType::SD_TYPE)\n    {\n        if (context->getSD()->open(source_path, \"w\"))\n        {\n            if(context->getSD()->move(destination_path))\n            {\n                success = true;\n            }\n        }\n    } \n\n    if (success)\n    {\n        return \"File moved Succesfull\";\n    }else {\n        return \"An error occured while moving file\";\n    }\n}\n\nString FileApis::handleCopy(String source_path, String destination_path, StorageType _storageType) {\n    bool success = false;\n    if (_storageType == StorageType::SPIFFS_TYPE)\n    {\n        if (context->getLittleFS()->open(source_path, \"w\"))\n        {\n            if(context->getLittleFS()->copy(destination_path))\n            {\n                success = true;\n            }\n        }\n    }\n    else if (_storageType == StorageType::SD_TYPE)\n    {\n        if (context->getSD()->open(source_path, \"w\"))\n        {\n            if(context->getSD()->copy(destination_path))\n            {\n                success = true;\n            }\n        }\n    } \n\n    if (success)\n    {\n        return \"File copied Succesfull\";\n    }else {\n        return \"An error occured while copying file\";\n    }\n}\n\nString FileApis::handleDuplicate(String path, StorageType _storageType) {\n    bool success = false;\n    if (_storageType == StorageType::SPIFFS_TYPE)\n    {\n        if (context->getLittleFS()->open(path, \"w\"))\n        {\n            if(context->getLittleFS()->duplicate())\n            {\n                success = true;\n            }\n        }\n    }\n    else if (_storageType == StorageType::SD_TYPE)\n    {\n        if (context->getSD()->open(path, \"w\"))\n        {\n            if(context->getSD()->duplicate())\n            {\n                success = true;\n            }\n        }\n    } \n\n    if (success)\n    {\n        return \"File moved Succesfull\";\n    }else {\n        return \"An error occured while renaming file\";\n    } \n}\n\nString FileApis::handleMkDir(String path, StorageType _storageType) {\n    bool success = false;\n    if (_storageType == StorageType::SPIFFS_TYPE)\n    {\n        if (LittleFS.mkdir(path))\n        {\n            success = true;\n        }\n    }\n    else if (_storageType == StorageType::SD_TYPE)\n    {\n        if (SD.mkdir(path))\n        {\n            success = true;            \n        }\n    } \n\n    if (success)\n    {\n        return \"Folder Created Succesfully\";\n    }\n    else\n    {\n        return \"Error Ocured While Creating Folder.\";\n    } \n}\n\nvoid FileApis::handleFileUploadAndRedirect(HTTPRequest *req, HTTPResponse *res, String path, StorageType storageType_path) {\n  // Check if it's a POST request\n  if (req->getMethod() == \"POST\") {\n    // Use the HTTPMultipartBodyParser to parse the uploaded file\n    HTTPBodyParser *parser = new HTTPMultipartBodyParser(req);\n\n    while (parser->nextField()) {\n      std::string name = parser->getFieldName();\n      std::string filename = parser->getFieldFilename();\n\n      // Check if the field is a file\n      if (name == \"data\") {\n        // Check file name validity and all that, but we skip that.\n        std::string pathname = std::string(path.c_str()) + filename;\n        File file;\n        if (storageType_path == StorageType::SD_TYPE)\n        {\n            file = SD.open(pathname.c_str(), \"w\");\n        }\n        else\n        {\n            file = LittleFS.open(pathname.c_str(), \"w\");\n        }\n        \n        size_t fileLength = 0;\n\n        // Write the file content\n        while (!parser->endOfField()) {\n          byte buf[512];\n          size_t readLength = parser->read(buf, 512);\n          file.write(buf, readLength);\n          fileLength += readLength;\n        }\n\n        file.close();\n        delete parser;\n\n        // Redirect to \"/files\" after successful file upload\n        RedirectUrl(res, \"/files\");\n        return;\n      }\n    }\n\n    // If no file field found, send an error response\n    res->setStatusCode(400);\n    res->setStatusText(\"Bad Request\");\n    res->println(\"400 Bad Request - No file uploaded\");\n  } else {\n    // If it's not a POST request, send an error response\n    res->setStatusCode(405);\n    res->setStatusText(\"Method Not Allowed\");\n    res->println(\"405 Method Not Allowed - Only POST requests are allowed\");\n  }\n}\n\n\n\n#endif // FILE_API_H\n\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\LogApi.h",
        "content": ""
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\SSIDApis.h",
        "content": "#ifndef SSIDApis_h\n#define SSIDApis_h\n\n\n#include \"../../Database/Controllers/WiFiConroller.h\"\n#include <ArduinoJson.h>\n#include \"ApiInterface.h\"\n#include \"../../Context.h\"\n#include \"SystemPermissions.h\"\n\nclass SSIDApis : public ApiInterface{\nprivate:\npublic:\n    std::string class_path = \"/ssid\";\n    WiFiController* wifiController;\n    Context* context;\n\n    SSIDApis(Context* context, bool add_apis);\n    String getClassPath() override;\n\n  String callFunction(String functionName, std::map<String, String> parameters) override;\n  String handleCreate(String ssid, String password);\n  String handleUpdate(int id, String ssid, String password);\n  String handleDelete(int id);\n  String handleGet(String query);\n  String handleGetById(int id);\n  String handleGetAll();\n};\n\nSSIDApis::SSIDApis(Context* cntxt, bool add_apis): context(cntxt) {\n  wifiController = new WiFiController(context, storageType);\n\n  if (!add_apis) return;\n\n  context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n      if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n      \n      if (!req->getParams()->isQueryParameterSet(\"SSID\") || !req->getParams()->isQueryParameterSet(\"Password\"))\n      {\n          response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n          return;\n      }\n      \n      std::string ssid;\n      req->getParams()->getQueryParameter(\"SSID\", ssid);\n      std::string password;\n      req->getParams()->getQueryParameter(\"Password\", password);\n\n      response(res, handleCreate(String(ssid.c_str()), String(password.c_str())));\n  }));\n\n  // Update Endpoint\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_UPDATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"SSID\") || !req->getParams()->isQueryParameterSet(\"Password\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        std::string ssid;\n        req->getParams()->getQueryParameter(\"SSID\", ssid);\n        std::string password;\n        req->getParams()->getQueryParameter(\"Password\", password);\n\n        response(res, handleUpdate(String(id.c_str()).toInt(), String(ssid.c_str()), String(password.c_str())));\n    }));\n\n    // Delete Endpoint\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_DELETE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n\n        response(res, handleDelete(String(id.c_str()).toInt()));\n    }));\n\n    // Get All Endpoint\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_GET) == AuthorizationResults::SUCCESFULL){return;}\n        response(res, handleGetAll());\n    }));\n\n    // Get By ID Endpoint\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n\n        response(res, handleGetById(String(id.c_str()).toInt()));\n    }));\n\n    // Get Endpoint\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SSID_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string query;\n        req->getParams()->getQueryParameter(\"query\", query);\n\n        response(res, handleGet(String(query.c_str())));\n    }));\n}\n\nString SSIDApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\n\nString SSIDApis::callFunction(String functionName, std::map<String, String> parameters) {\n  if (functionName == \"handleCreate\") {\n      handleCreate(parameters[\"ssid\"], parameters[\"password\"]);\n      return \"OK\";\n  } else if (functionName == \"handleUpdate\") {\n      handleUpdate(parameters[\"id\"].toInt(), parameters[\"ssid\"], parameters[\"password\"]);\n      return \"OK\";\n  } else if (functionName == \"handleDelete\") {\n      handleDelete(parameters[\"id\"].toInt());\n      return \"OK\";\n  } else if (functionName == \"handleGet\") {\n      return handleGet(parameters[\"query\"]);\n  } else if (functionName == \"handleGetById\") {\n      return handleGetById(parameters[\"id\"].toInt());\n  } else if (functionName == \"handleGetAll\") {\n      return handleGetAll();\n  } else {\n      return \"Error: The function doesn't exist\";\n  }\n}\n\nString SSIDApis::handleCreate(String ssid, String password) {\n    WiFiEntity *wifiEntity = new WiFiEntity(ssid, password);\n    int id = wifiController->Add(*wifiEntity);\n    if (id != -1)\n    {\n        return String(id);\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\n\nString SSIDApis::handleUpdate(int id, String ssid, String password) {\n    WiFiEntity* wifiEntity = new WiFiEntity(id, ssid, password); \n    if(wifiController->Update(*wifiEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\n\nString SSIDApis::handleDelete(int id) {\n    if(wifiController->Delete(id)) return DELETE_SUCCESFULL_MESSAGE;\n    return DELETE_FAILED_MESSAGE;\n}\n\nString SSIDApis::handleGet(String query) {\n    \n    std::vector<WiFiEntity> wifiEntities = wifiController->Get(query);\n    String result = \"[\";\n    for (size_t i = 0; i < wifiEntities.size(); i++) {\n        result = result + wifiEntities.at(i).toString();\n    }\n    result = result + \"]\";\n    return result;\n}\n\nString SSIDApis::handleGetById(int id) {\n    WiFiEntity wifiEntity = wifiController->GetById(id);\n    if (wifiEntity.id == -1) {\n        return \"No entity\";\n    } else {\n        return wifiEntity.toJson();\n    }\n}\n\nString SSIDApis::handleGetAll() {\n    return wifiController->GetAllJson();\n}\n\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\SystemConfigApis.h",
        "content": "\n#ifndef SystemConfigApis_h\n#define SystemConfigApis_h\n\n\n#include \"../../Database/Controllers/SystemConfigController.h\"\n#include <ArduinoJson.h>\n#include \"../../Context.h\"\n#include \"ApiInterface.h\"\n#include \"../../Config/System/DefaultSystemConfigs.h\"\n#include \"SystemPermissions.h\"\n\nclass SystemConfigAPis : public ApiInterface\n{\nprivate:\npublic:\n    std::string class_path = \"/systemConfig\";\n    SystemConfigController* systemConfigController;\n    Context* context;\n\n    SystemConfigAPis(Context* context, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    String handleCreate(String key, String value);\n    String handleUpdate(int id, String key, String value);\n    String handleSubmit(String key, String value);\n    String handleDelete(int id);\n    String handleGet(String query);\n    String handleGetById(int id);\n    String handleGetAll();\n};\n\nSystemConfigAPis::SystemConfigAPis(Context* cntxt, bool add_apis): context(cntxt)\n{\n    systemConfigController = new SystemConfigController(context, storageType);\n\n    if (!add_apis) return;\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SYSTEMCONFIG_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"key\") || !req->getParams()->isQueryParameterSet(\"value\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        std::string key;\n        std::string value;\n        req->getParams()->getQueryParameter(\"key\", key);\n        req->getParams()->getQueryParameter(\"value\", value);\n\n        response(res, handleCreate(String(key.c_str()), String(value.c_str())));\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SYSTEMCONFIG_UPDATE) == AuthorizationResults::SUCCESFULL){return;}\n\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"key\") || !req->getParams()->isQueryParameterSet(\"value\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        std::string key;\n        std::string value;\n        req->getParams()->getQueryParameter(\"id\", id);\n        req->getParams()->getQueryParameter(\"key\", key);\n        req->getParams()->getQueryParameter(\"value\", value);\n\n        response(res, handleUpdate(String(id.c_str()).toInt(), String(key.c_str()), String(value.c_str())));\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/submit\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SYSTEMCONFIG_UPDATE) == AuthorizationResults::SUCCESFULL){return;}\n\n        if (!req->getParams()->isQueryParameterSet(\"key\") || !req->getParams()->isQueryParameterSet(\"value\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string key;\n        std::string value;\n        req->getParams()->getQueryParameter(\"key\", key);\n        req->getParams()->getQueryParameter(\"value\", value);\n\n        response(res, handleSubmit(String(key.c_str()), String(value.c_str())));\n    }));\n    \n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SYSTEMCONFIG_DELETE) == AuthorizationResults::SUCCESFULL){return;}\n\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n\n        response(res, handleDelete(String(id.c_str()).toInt()));\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SYSTEMCONFIG_GET) == AuthorizationResults::SUCCESFULL){return;}\n\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        std::string query;\n        req->getParams()->getQueryParameter(\"query\", query);\n\n        response(res, handleGet(String(query.c_str())));    \n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SYSTEMCONFIG_GET) == AuthorizationResults::SUCCESFULL){return;}\n\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n\n        response(res, handleGetById(String(id.c_str()).toInt()));\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        Serial.println(\"in api /getAll\");\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SYSTEMCONFIG_GET) == AuthorizationResults::SUCCESFULL){return;}\n        Serial.println(\"after authorization\");\n        response(res, handleGetAll());\n        Serial.println(\"after response\");\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getSystemConfigs\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SYSTEMCONFIG_GET) == AuthorizationResults::SUCCESFULL){return;}\n        response(res, DefaultSystemConfigs::jsonString);\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getConfigsJson\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, SystemPermissions::SYSTEMCONFIG_GET) == AuthorizationResults::SUCCESFULL){return;}\n        response(res, DefaultSystemConfigs::jsonString);\n    }));\n}\n\nString SystemConfigAPis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\n\nString SystemConfigAPis::callFunction(String functionName, std::map<String, String> parameters)\n{\n    if (functionName == \"handleCreate\") {\n        handleCreate(parameters[\"key\"], parameters[\"value\"]);\n        return \"OK\";\n    } else if (functionName == \"handleUpdate\") {\n        handleUpdate(parameters[\"id\"].toInt(), parameters[\"key\"], parameters[\"value\"]);\n        return \"OK\";\n    } else if (functionName == \"handleSubmit\") {\n        handleSubmit(parameters[\"key\"], parameters[\"value\"]);\n        return \"OK\";\n    } else if (functionName == \"handleDelete\") {\n        handleDelete(parameters[\"id\"].toInt());\n        return \"OK\";\n    } else if (functionName == \"handleGet\") {\n        return handleGet(parameters[\"query\"]);\n    } else if (functionName == \"handleGetById\") {\n        return handleGetById(parameters[\"id\"].toInt());\n    } else if (functionName == \"handleGetAll\") {\n        return handleGetAll();\n    } else {\n        return \"Error: The function doesn't exist\";\n    }\n}\nString SystemConfigAPis::handleCreate(String key, String value) {\n    KeyValueEntity *systemConfig = new KeyValueEntity(key, value);\n    int id = systemConfigController->Add(*systemConfig);\n    if (id != -1)\n    {\n        return String(id);\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\n\nString SystemConfigAPis::handleUpdate(int id, String key, String value) {\n    KeyValueEntity* entity = new KeyValueEntity(id, key, value);\n    if(systemConfigController->Update(*entity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\n\nString SystemConfigAPis::handleSubmit(String key, String value) {\n    std::vector<KeyValueEntity> systemConfigEntities = systemConfigController->Get(KeyValueEntity::COLUMN_KEY + \"=\" + key);\n    if (systemConfigEntities.size() > 0)\n    {\n        KeyValueEntity* entity = new KeyValueEntity(systemConfigEntities.at(0).id, key, value);\n        if(systemConfigController->Update(*entity)) return UPDATE_SUCCESFULL_MESSAGE;\n        else return UPDATE_FAILED_MESSAGE;\n    }\n    else\n    {\n        KeyValueEntity *systemConfig = new KeyValueEntity(key, value);\n        int id = systemConfigController->Add(*systemConfig);\n        if (id != -1) return String(id);        \n        return CREATE_FAILED_MESSAGE;\n    }\n}\n\nString SystemConfigAPis::handleDelete(int id) {\n    if(systemConfigController->Delete(id)) return DELETE_SUCCESFULL_MESSAGE;\n    return DELETE_FAILED_MESSAGE;\n}\n\nString SystemConfigAPis::handleGetAll() {\n    return systemConfigController->GetAllJson();\n}\n\nString SystemConfigAPis::handleGet(String query) {\n    std::vector<KeyValueEntity> systemConfigEntities = systemConfigController->Get(query);\n    String result = \"[\";\n    for (size_t i = 0; i < systemConfigEntities.size(); i++)\n    {\n        result = result + systemConfigEntities.at(i).toString();\n    }\n    result = result + \"]\";\n    return result;\n}\n\nString SystemConfigAPis::handleGetById(int id) {\n    KeyValueEntity systemConfig = systemConfigController->GetById(id);\n\n    if (systemConfig.id == -1)\n    {\n        return \"no entity\";\n    }\n    else\n    {\n        return systemConfig.toJson();\n    }\n}\n\n\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\SystemPermissions.h",
        "content": "#ifndef SYSTEMPERMISSIONS_H\n#define SYSTEMPERMISSIONS_H\n\n#include \"../../Context.h\"\n\nclass SystemPermissions\n{\npublic:\n    // File permissions\n    static const String FILE_CREATE;\n    static const String FILE_UPDATE;\n    static const String FILE_DELETE;\n    static const String FILE_GET;\n\n    // WiFi permissions\n    static const String WIFI_CREATE;\n    static const String WIFI_UPDATE;\n    static const String WIFI_DELETE;\n    static const String WIFI_GET;\n\n    // Log permissions\n    static const String LOG_CREATE;\n    static const String LOG_UPDATE;\n    static const String LOG_DELETE;\n    static const String LOG_GET;\n\n    // SystemConfig permissions\n    static const String SYSTEMCONFIG_CREATE;\n    static const String SYSTEMCONFIG_UPDATE;\n    static const String SYSTEMCONFIG_DELETE;\n    static const String SYSTEMCONFIG_GET;\n\n    // SSID permissions\n    static const String SSID_CREATE;\n    static const String SSID_UPDATE;\n    static const String SSID_DELETE;\n    static const String SSID_GET;\n\n    static void addPermissions(Context* context);\n};\n\nvoid SystemPermissions::addPermissions(Context* context)\n{\n    // File permissions\n    context->getSecurity()->addPermissionForAdmin(FILE_CREATE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(FILE_UPDATE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(FILE_DELETE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(FILE_GET, \"SystemApis Permissions\");\n\n    // WiFi permissions\n    context->getSecurity()->addPermissionForAdmin(WIFI_CREATE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(WIFI_UPDATE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(WIFI_DELETE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(WIFI_GET, \"SystemApis Permissions\");\n\n    // Log permissions\n    context->getSecurity()->addPermissionForAdmin(LOG_CREATE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(LOG_UPDATE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(LOG_DELETE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(LOG_GET, \"SystemApis Permissions\");\n\n    // SystemConfig permissions\n    context->getSecurity()->addPermissionForAdmin(SYSTEMCONFIG_CREATE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(SYSTEMCONFIG_UPDATE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(SYSTEMCONFIG_DELETE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(SYSTEMCONFIG_GET, \"SystemApis Permissions\");\n\n    // SSID permissions\n    context->getSecurity()->addPermissionForAdmin(SSID_CREATE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(SSID_UPDATE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(SSID_DELETE, \"SystemApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(SSID_GET, \"SystemApis Permissions\");\n}\n\n// Define the static constants\nconst String SystemPermissions::FILE_CREATE = \"file_create\";\nconst String SystemPermissions::FILE_UPDATE = \"file_update\";\nconst String SystemPermissions::FILE_DELETE = \"file_delete\";\nconst String SystemPermissions::FILE_GET = \"file_get\";\n\nconst String SystemPermissions::WIFI_CREATE = \"wifi_create\";\nconst String SystemPermissions::WIFI_UPDATE = \"wifi_update\";\nconst String SystemPermissions::WIFI_DELETE = \"wifi_delete\";\nconst String SystemPermissions::WIFI_GET = \"wifi_get\";\n\nconst String SystemPermissions::LOG_CREATE = \"log_create\";\nconst String SystemPermissions::LOG_UPDATE = \"log_update\";\nconst String SystemPermissions::LOG_DELETE = \"log_delete\";\nconst String SystemPermissions::LOG_GET = \"log_get\";\n\nconst String SystemPermissions::SYSTEMCONFIG_CREATE = \"systemconfig_create\";\nconst String SystemPermissions::SYSTEMCONFIG_UPDATE = \"systemconfig_update\";\nconst String SystemPermissions::SYSTEMCONFIG_DELETE = \"systemconfig_delete\";\nconst String SystemPermissions::SYSTEMCONFIG_GET = \"systemconfig_get\";\n\nconst String SystemPermissions::SSID_CREATE = \"ssid_create\";\nconst String SystemPermissions::SSID_UPDATE = \"ssid_update\";\nconst String SystemPermissions::SSID_DELETE = \"ssid_delete\";\nconst String SystemPermissions::SSID_GET = \"ssid_get\";\n\n#endif // SYSTEMPERMISSIONS_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\WiFiApis.h",
        "content": "#ifndef WiFiApis_h\n#define WiFiApis_h\n\n#include \"ApiInterface.h\"\n#include \"../../Context.h\"\n#include \"../../Database/Controllers/WiFiConroller.h\"\nclass WiFiApis : public ApiInterface{\nprivate:\n    String ssidInfosToJson(const std::vector<SSIDInfo>& SSIDInfos);\npublic:\n    std::string class_path = \"/wifi\";\n    Context* context;\n\n    WiFiApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n\n    bool removeSSID(String ssid);\n    void restartESP();\n    void disconnectWiFi();\n    bool connectWiFi(String ssid, String password);\n    void addSSID(String ssid, String password);\n    String getAllSSIDs();\n};\n\nWiFiApis::WiFiApis(Context* cntxt, bool add_apis): context(cntxt)\n{\n    if (!add_apis) return;\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/forget_wifi\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        String ssid = getQueryParameterString(req, \"ssid\");\n        removeSSID(ssid);\n        response(res, 200, \"text/html\", \"Succesfull\");\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/restart\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        restartESP();\n        response(res, 200, \"text/html\",  \"Succesfull\");\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/disconnect_wifi\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        disconnectWiFi();\n        response(res, 200, \"text/html\",  \"Succesfull\");\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/connect_wifi\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        String ssid = getQueryParameterString(req, \"ssid\");\n        String password = getQueryParameterString(req, \"password\");\n        if (connectWiFi(ssid, password))\n        {\n            response(res, 200, \"text/html\", \"Succesfull\");\n        }\n        else{\n            response(res, 400, \"text/html\",  \"Failed\");\n\n        }\n        \n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/add_ssid\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        String ssid = getQueryParameterString(req, \"ssid\");\n        String password = getQueryParameterString(req, \"password\");\n        addSSID(ssid, password);\n        response(res, 200, \"text/html\",  \"true\");\n    }));\n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get_all_ssids\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        Serial.println(\"befor getAllSSIDs\");\n        \n        String output = getAllSSIDs();\n        response(res, 200, \"text/json\",  output);\n    }));\n}\n\nString WiFiApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString WiFiApis::callFunction(String functionName, std::map<String, String> parameters)\n{\n    if (functionName == \"removeSSID\") {\n        bool result = removeSSID(parameters[\"ssid\"]);\n        return result ? \"OK\" : \"Error\";\n    } else if (functionName == \"restartESP\") {\n        restartESP();\n        return \"OK\";\n    } else if (functionName == \"disconnectWiFi\") {\n        disconnectWiFi();\n        return \"OK\";\n    } else if (functionName == \"connectWiFi\") {\n        bool result = connectWiFi(parameters[\"ssid\"], parameters[\"password\"]);\n        return result ? \"OK\" : \"Error\";\n    } else if (functionName == \"addSSID\") {\n        addSSID(parameters[\"ssid\"], parameters[\"password\"]);\n        return \"OK\";\n    } else if (functionName == \"getAllSSIDs\") {\n        return getAllSSIDs();\n    } else {\n        return \"Error: The function doesn't exist\";\n    }\n}\n\nbool WiFiApis::removeSSID(String ssid)\n{\n    context->getNetwork()->getWiFiManager()->RemoveSSID(ssid);\n\n    return true;\n}\n\nvoid WiFiApis::restartESP()\n{\n    ESP.restart();\n}\n\nvoid WiFiApis::disconnectWiFi()\n{\n    #if defined(ESP8266)\n    WiFi.disconnect(false);\n    #else\n    WiFi.disconnect(false,false);\n    #endif\n}\n\nbool WiFiApis::connectWiFi(String ssid, String password)\n{\n    WiFiController* wifiController = new WiFiController(context, storageType);\n    std::vector<WiFiEntity> wifiEntities = wifiController->GetAll();\n    bool in_db = false;\n    for (size_t i = 0; i < wifiEntities.size(); i++)\n    {\n        if (wifiEntities.at(i).SSID == ssid)\n        {\n            password = wifiEntities.at(i).Password;\n            in_db = true;\n        }            \n    }\n    \n    WiFi.begin(ssid.c_str(),password.c_str());\n    if(WiFi.status())\n    {\n        if(in_db == false)\n        {\n            context->getNetwork()->getWiFiManager()->AddSSID(ssid,password);\n        }\n    }\n    else{\n        return false;\n    }\n    return true;\n}\n\n\nvoid WiFiApis::addSSID(String ssid, String password)\n{\n    context->getNetwork()->getWiFiManager()->AddSSID(ssid, password);\n}\n\nString WiFiApis::getAllSSIDs()\n{\n    Serial.println(\"getAllSSIDs-1\");\n    std::vector<SSIDInfo> SSIDInfos;\n    Serial.println(\"getAllSSIDs-2\");\n    context->getNetwork()->getWiFiManager()->GetAvailableSSIDs(SSIDInfos);\n    Serial.println(\"getAllSSIDs-3\");\n    String ssid_lists_json = ssidInfosToJson(SSIDInfos);\n    Serial.println(\"getAllSSIDs-4\");\n    return ssid_lists_json;\n}\n\nString WiFiApis::ssidInfosToJson(const std::vector<SSIDInfo>& SSIDInfos) {\n    String json = \"[\";\n    for (size_t i = 0; i < SSIDInfos.size(); i++) {\n        json += \"{\\\"SSID\\\":\\\"\" + SSIDInfos.at(i).SSID + \"\\\",\\\"WiFiStrength\\\":\" + String(SSIDInfos.at(i).WiFiStrength) + \",\\\"isSaved\\\":\" + String(SSIDInfos.at(i).isSaved) + \"}\";\n        if (i < SSIDInfos.size() - 1) {\n            json += \",\";\n        }\n    }\n    json += \"]\";\n    return json;\n}\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Authorization\\AccountActivityLogApis.h",
        "content": "#ifndef ACCOUNTACTIVITYLOGAPIS_h\n#define ACCOUNTACTIVITYLOGAPIS_h\n\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Security/AccountActivityLogController.h\"\n#include \"../../../Security/AuthorizationPermissions.h\"\n\nclass AccountActivityLogApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    AccountActivityLogController* accountactivitylogController;\n    std::string class_path = \"/accountactivitylog\";\n\npublic:\n    AccountActivityLogApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(int UserId, String Activity, EBPDateTime Timestamp);\n    String handleupdate(int id, int UserId, String Activity, EBPDateTime Timestamp);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nAccountActivityLogApis::AccountActivityLogApis(Context* cntxt, bool add_apis): context(cntxt) {\n    accountactivitylogController = new AccountActivityLogController(context, storageType);\n    \n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ACCOUNTACTIVITYLOG_CREATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"UserId\") || !req->getParams()->isQueryParameterSet(\"Activity\") || !req->getParams()->isQueryParameterSet(\"Timestamp\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string UserId;\n        req->getParams()->getQueryParameter(\"UserId\", UserId);\n    std::string Activity;\n        req->getParams()->getQueryParameter(\"Activity\", Activity);\n    std::string Timestamp;\n        req->getParams()->getQueryParameter(\"Timestamp\", Timestamp);\n\n        response(res, handlecreate(String(UserId.c_str()).toInt(), String(Activity.c_str()), String(Timestamp.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ACCOUNTACTIVITYLOG_UPDATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"UserId\") || !req->getParams()->isQueryParameterSet(\"Activity\") || !req->getParams()->isQueryParameterSet(\"Timestamp\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        std::string UserId;\n        req->getParams()->getQueryParameter(\"UserId\", UserId);\n    std::string Activity;\n        req->getParams()->getQueryParameter(\"Activity\", Activity);\n    std::string Timestamp;\n        req->getParams()->getQueryParameter(\"Timestamp\", Timestamp);\n        \n        response(res, handleupdate(String(id.c_str()).toInt(), String(UserId.c_str()).toInt(), String(Activity.c_str()), String(Timestamp.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ACCOUNTACTIVITYLOG_DELETE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handledelete(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ACCOUNTACTIVITYLOG_GET)){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ACCOUNTACTIVITYLOG_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handlegetById(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ACCOUNTACTIVITYLOG_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string query;\n        req->getParams()->getQueryParameter(\"query\", query);\n        \n        response(res, handleget(String(query.c_str())));\n    }));\n}\n\nString AccountActivityLogApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString AccountActivityLogApis::handlecreate(int UserId, String Activity, EBPDateTime Timestamp) {\n    AccountActivityLogEntity* accountactivitylogEntity = new AccountActivityLogEntity(UserId, Activity, Timestamp);\n    int id = accountactivitylogController->Add(*accountactivitylogEntity);\n    if (id != -1)\n    {\n        return String(id);\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString AccountActivityLogApis::handleupdate(int id, int UserId, String Activity, EBPDateTime Timestamp) {\n    AccountActivityLogEntity* accountactivitylogEntity = new AccountActivityLogEntity(id, UserId, Activity, Timestamp);\n    \n    if (accountactivitylogController->Update(*accountactivitylogEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString AccountActivityLogApis::handledelete(int id) {\n    \n    if (accountactivitylogController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString AccountActivityLogApis::handlegetAll() {\n    return accountactivitylogController->GetAllJson();\n}\nString AccountActivityLogApis::handlegetById(int id) {\n    return accountactivitylogController->GetById(id).toJson();\n}\nString AccountActivityLogApis::handleget(String query) {\n    return accountactivitylogController->GetJson(query);\n}\n\nString AccountActivityLogApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"UserId\"].toInt(), parameters[\"Activity\"], parameters[\"Timestamp\"]);\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"UserId\"].toInt(), parameters[\"Activity\"], parameters[\"Timestamp\"]);\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //ACCOUNTACTIVITYLOGApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Authorization\\AccountLockoutApis.h",
        "content": "#ifndef ACCOUNTLOCKOUTAPIS_h\n#define ACCOUNTLOCKOUTAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Security/AccountLockoutController.h\"\n#include \"../../../Security/AuthorizationPermissions.h\"\n\nclass AccountLockoutApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    AccountLockoutController* accountlockoutController;\n    std::string class_path = \"/accountlockout\";\n\npublic:\n    AccountLockoutApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(int UserId, EBPDateTime LockoutStartTime, EBPDateTime LockoutEndTime);\n    String handleupdate(int id, int UserId, EBPDateTime LockoutStartTime, EBPDateTime LockoutEndTime);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nAccountLockoutApis::AccountLockoutApis(Context* cntxt, bool add_apis): context(cntxt) {\n    accountlockoutController = new AccountLockoutController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ACCOUNTLOCKOUT_CREATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"UserId\") || !req->getParams()->isQueryParameterSet(\"LockoutStartTime\") || !req->getParams()->isQueryParameterSet(\"LockoutEndTime\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string UserId;\n        req->getParams()->getQueryParameter(\"UserId\", UserId);\n    std::string LockoutStartTime;\n        req->getParams()->getQueryParameter(\"LockoutStartTime\", LockoutStartTime);\n    std::string LockoutEndTime;\n        req->getParams()->getQueryParameter(\"LockoutEndTime\", LockoutEndTime);\n\n        response(res, handlecreate(String(UserId.c_str()).toInt(), String(LockoutStartTime.c_str()), String(LockoutEndTime.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ACCOUNTLOCKOUT_UPDATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"UserId\") || !req->getParams()->isQueryParameterSet(\"LockoutStartTime\") || !req->getParams()->isQueryParameterSet(\"LockoutEndTime\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        std::string UserId;\n        req->getParams()->getQueryParameter(\"UserId\", UserId);\n    std::string LockoutStartTime;\n        req->getParams()->getQueryParameter(\"LockoutStartTime\", LockoutStartTime);\n    std::string LockoutEndTime;\n        req->getParams()->getQueryParameter(\"LockoutEndTime\", LockoutEndTime);\n        \n        response(res, handleupdate(String(id.c_str()).toInt(), String(UserId.c_str()).toInt(), String(LockoutStartTime.c_str()), String(LockoutEndTime.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ACCOUNTLOCKOUT_DELETE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handledelete(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ACCOUNTLOCKOUT_GET)){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ACCOUNTLOCKOUT_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handlegetById(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ACCOUNTLOCKOUT_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string query;\n        req->getParams()->getQueryParameter(\"query\", query);\n        \n        response(res, handleget(String(query.c_str())));\n    }));\n}\n\nString AccountLockoutApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString AccountLockoutApis::handlecreate(int UserId, EBPDateTime LockoutStartTime, EBPDateTime LockoutEndTime) {\n    AccountLockoutEntity* accountlockoutEntity = new AccountLockoutEntity(UserId, LockoutStartTime, LockoutEndTime);\n    int id = accountlockoutController->Add(*accountlockoutEntity);\n    if (id != -1)\n    {\n        return String(id);\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString AccountLockoutApis::handleupdate(int id, int UserId, EBPDateTime LockoutStartTime, EBPDateTime LockoutEndTime) {\n    AccountLockoutEntity* accountlockoutEntity = new AccountLockoutEntity(id, UserId, LockoutStartTime, LockoutEndTime);\n    \n    if (accountlockoutController->Update(*accountlockoutEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString AccountLockoutApis::handledelete(int id) {\n    \n    if (accountlockoutController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString AccountLockoutApis::handlegetAll() {\n    return accountlockoutController->GetAllJson();\n}\nString AccountLockoutApis::handlegetById(int id) {\n    return accountlockoutController->GetById(id).toJson();\n}\nString AccountLockoutApis::handleget(String query) {\n    return accountlockoutController->GetJson(query);\n}\n\nString AccountLockoutApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"UserId\"].toInt(), parameters[\"LockoutStartTime\"], parameters[\"LockoutEndTime\"]);\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"UserId\"].toInt(), parameters[\"LockoutStartTime\"], parameters[\"LockoutEndTime\"]);\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //ACCOUNTLOCKOUTApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Authorization\\AuthorizationApis.h",
        "content": "#ifndef AUTHORIZATIONAPIS_H\n#define AUTHORIZATIONAPIS_H\n\n#include \"../../../Security/AuthorizationPermissions.h\"\n#include \"UserApis.h\"\n#include \"RoleApis.h\"\n#include \"PermissionApis.h\"\n#include \"RolePermissionApis.h\"\n#include \"UserResetPassApis.h\"\n#include \"SecurityQuestionApis.h\"\n#include \"SecurityQuestionTitleApis.h\"\n#include \"LoginAttemptApis.h\"\n#include \"AccountLockoutApis.h\"\n#include \"TwoFactorAuthApis.h\"\n#include \"AccountActivityLogApis.h\"\n\n\nvoid createAuthorizationApis(Context* context)\n{\n    std::vector<ApiInterface*> apis = std::vector<ApiInterface*>();\n    \n    UserApis* userApis = new UserApis(context, true);\n    apis.push_back(userApis);\n    \n    RoleApis* roleApis = new RoleApis(context, true);\n    apis.push_back(roleApis);\n    \n    PermissionApis* permissionApis = new PermissionApis(context, true);\n    apis.push_back(permissionApis);\n    \n    RolePermissionApis* rolepermissionApis = new RolePermissionApis(context, true);\n    apis.push_back(rolepermissionApis);\n    \n    UserResetPassApis* userresetpassApis = new UserResetPassApis(context, true);\n    apis.push_back(userresetpassApis);\n    \n    SecurityQuestionApis* securityquestionApis = new SecurityQuestionApis(context, true);\n    apis.push_back(securityquestionApis);\n    \n    SecurityQuestionTitleApis* securityquestiontitleApis = new SecurityQuestionTitleApis(context, true);\n    apis.push_back(securityquestiontitleApis);\n    \n    LoginAttemptApis* loginattemptApis = new LoginAttemptApis(context, true);\n    apis.push_back(loginattemptApis);\n    \n    AccountLockoutApis* accountlockoutApis = new AccountLockoutApis(context, true);\n    apis.push_back(accountlockoutApis);\n    \n    TwoFactorAuthApis* twofactorauthApis = new TwoFactorAuthApis(context, true);\n    apis.push_back(twofactorauthApis);\n    \n    AccountActivityLogApis* accountactivitylogApis = new AccountActivityLogApis(context, true);\n    apis.push_back(accountactivitylogApis);\n    \n\n    context->getNetwork()->addApis(apis);\n}\n\n#endif //AUTHORIZATIONAPIS_H\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Authorization\\LoginAttemptApis.h",
        "content": "#ifndef LOGINATTEMPTAPIS_h\n#define LOGINATTEMPTAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Security/LoginAttemptController.h\"\n#include \"../../../Security/AuthorizationPermissions.h\"\n\nclass LoginAttemptApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    LoginAttemptController* loginattemptController;\n    std::string class_path = \"/loginattempt\";\n\npublic:\n    LoginAttemptApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(int UserId, EBPDateTime Timestamp);\n    String handleupdate(int id, int UserId, EBPDateTime Timestamp);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nLoginAttemptApis::LoginAttemptApis(Context* cntxt, bool add_apis): context(cntxt) {\n    loginattemptController = new LoginAttemptController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::LOGINATTEMPT_CREATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"UserId\") || !req->getParams()->isQueryParameterSet(\"Timestamp\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string UserId;\n        req->getParams()->getQueryParameter(\"UserId\", UserId);\n    std::string Timestamp;\n        req->getParams()->getQueryParameter(\"Timestamp\", Timestamp);\n\n        response(res, handlecreate(String(UserId.c_str()).toInt(), String(Timestamp.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::LOGINATTEMPT_UPDATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"UserId\") || !req->getParams()->isQueryParameterSet(\"Timestamp\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        std::string UserId;\n        req->getParams()->getQueryParameter(\"UserId\", UserId);\n    std::string Timestamp;\n        req->getParams()->getQueryParameter(\"Timestamp\", Timestamp);\n        \n        response(res, handleupdate(String(id.c_str()).toInt(), String(UserId.c_str()).toInt(), String(Timestamp.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::LOGINATTEMPT_DELETE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handledelete(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::LOGINATTEMPT_GET)){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::LOGINATTEMPT_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handlegetById(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::LOGINATTEMPT_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string query;\n        req->getParams()->getQueryParameter(\"query\", query);\n        \n        response(res, handleget(String(query.c_str())));\n    }));\n}\n\nString LoginAttemptApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString LoginAttemptApis::handlecreate(int UserId, EBPDateTime Timestamp) {\n    LoginAttemptEntity* loginattemptEntity = new LoginAttemptEntity(UserId, Timestamp);\n    int id = loginattemptController->Add(*loginattemptEntity);\n    if (id != -1)\n    {\n        return String(id);\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString LoginAttemptApis::handleupdate(int id, int UserId, EBPDateTime Timestamp) {\n    LoginAttemptEntity* loginattemptEntity = new LoginAttemptEntity(id, UserId, Timestamp);\n    \n    if (loginattemptController->Update(*loginattemptEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString LoginAttemptApis::handledelete(int id) {\n    \n    if (loginattemptController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString LoginAttemptApis::handlegetAll() {\n    return loginattemptController->GetAllJson();\n}\nString LoginAttemptApis::handlegetById(int id) {\n    return loginattemptController->GetById(id).toJson();\n}\nString LoginAttemptApis::handleget(String query) {\n    return loginattemptController->GetJson(query);\n}\n\nString LoginAttemptApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"UserId\"].toInt(), parameters[\"Timestamp\"]);\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"UserId\"].toInt(), parameters[\"Timestamp\"]);\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //LOGINATTEMPTApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Authorization\\PermissionApis.h",
        "content": "#ifndef PERMISSIONAPIS_h\n#define PERMISSIONAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Security/PermissionController.h\"\n#include \"../../../Security/AuthorizationPermissions.h\"\n\nclass PermissionApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    PermissionController* permissionController;\n    std::string class_path = \"/permission\";\n\npublic:\n    PermissionApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(String PermissionName, String PermissionGroup);\n    String handleupdate(int id, String PermissionName, String PermissionGroup);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nPermissionApis::PermissionApis(Context* cntxt, bool add_apis): context(cntxt) {\n    permissionController = new PermissionController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::PERMISSION_CREATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"PermissionName\") || !req->getParams()->isQueryParameterSet(\"PermissionGroup\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string PermissionName;\n        req->getParams()->getQueryParameter(\"PermissionName\", PermissionName);\n    std::string PermissionGroup;\n        req->getParams()->getQueryParameter(\"PermissionGroup\", PermissionGroup);\n\n        response(res, handlecreate(String(PermissionName.c_str()), String(PermissionGroup.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::PERMISSION_UPDATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"PermissionName\") || !req->getParams()->isQueryParameterSet(\"PermissionGroup\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        std::string PermissionName;\n        req->getParams()->getQueryParameter(\"PermissionName\", PermissionName);\n    std::string PermissionGroup;\n        req->getParams()->getQueryParameter(\"PermissionGroup\", PermissionGroup);\n        \n        response(res, handleupdate(String(id.c_str()).toInt(), String(PermissionName.c_str()), String(PermissionGroup.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::PERMISSION_DELETE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handledelete(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::PERMISSION_GET)){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::PERMISSION_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handlegetById(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::PERMISSION_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string query;\n        req->getParams()->getQueryParameter(\"query\", query);\n        \n        response(res, handleget(String(query.c_str())));\n    }));\n}\n\nString PermissionApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString PermissionApis::handlecreate(String PermissionName, String PermissionGroup) {\n    PermissionEntity* permissionEntity = new PermissionEntity(PermissionName, PermissionGroup);\n    int id = permissionController->Add(*permissionEntity);\n    if (id != -1)\n    {\n        return String(id);\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString PermissionApis::handleupdate(int id, String PermissionName, String PermissionGroup) {\n    PermissionEntity* permissionEntity = new PermissionEntity(id, PermissionName, PermissionGroup);\n    \n    if (permissionController->Update(*permissionEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString PermissionApis::handledelete(int id) {\n    \n    if (permissionController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString PermissionApis::handlegetAll() {\n    return permissionController->GetAllJson();\n}\nString PermissionApis::handlegetById(int id) {\n    return permissionController->GetById(id).toJson();\n}\nString PermissionApis::handleget(String query) {\n    return permissionController->GetJson(query);\n}\n\nString PermissionApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"PermissionName\"], parameters[\"PermissionGroup\"]);\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"PermissionName\"], parameters[\"PermissionGroup\"]);\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //PERMISSIONApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Authorization\\RoleApis.h",
        "content": "#ifndef ROLEAPIS_h\n#define ROLEAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Security/RoleController.h\"\n#include \"../../../Security/AuthorizationPermissions.h\"\n\nclass RoleApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    RoleController* roleController;\n    std::string class_path = \"/role\";\n\npublic:\n    RoleApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(String RoleName);\n    String handleupdate(int id, String RoleName);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nRoleApis::RoleApis(Context* cntxt, bool add_apis): context(cntxt) {\n    roleController = new RoleController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ROLE_CREATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"RoleName\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string RoleName;\n        req->getParams()->getQueryParameter(\"RoleName\", RoleName);\n\n        response(res, handlecreate(String(RoleName.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ROLE_UPDATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"RoleName\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        std::string RoleName;\n        req->getParams()->getQueryParameter(\"RoleName\", RoleName);\n        \n        response(res, handleupdate(String(id.c_str()).toInt(), String(RoleName.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ROLE_DELETE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handledelete(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ROLE_GET)){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ROLE_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handlegetById(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ROLE_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string query;\n        req->getParams()->getQueryParameter(\"query\", query);\n        \n        response(res, handleget(String(query.c_str())));\n    }));\n}\n\nString RoleApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString RoleApis::handlecreate(String RoleName) {\n    RoleEntity* roleEntity = new RoleEntity(RoleName);\n    int id = roleController->Add(*roleEntity);\n    if (id != -1)\n    {\n        return String(id);\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString RoleApis::handleupdate(int id, String RoleName) {\n    RoleEntity* roleEntity = new RoleEntity(id, RoleName);\n    \n    if (roleController->Update(*roleEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString RoleApis::handledelete(int id) {\n    \n    if (roleController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString RoleApis::handlegetAll() {\n    return roleController->GetAllJson();\n}\nString RoleApis::handlegetById(int id) {\n    return roleController->GetById(id).toJson();\n}\nString RoleApis::handleget(String query) {\n    return roleController->GetJson(query);\n}\n\nString RoleApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"RoleName\"]);\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"RoleName\"]);\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //ROLEApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Authorization\\RolePermissionApis.h",
        "content": "#ifndef ROLEPERMISSIONAPIS_h\n#define ROLEPERMISSIONAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Security/RolePermissionController.h\"\n#include \"../../../Security/AuthorizationPermissions.h\"\n\nclass RolePermissionApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    RolePermissionController* rolepermissionController;\n    std::string class_path = \"/rolepermission\";\n\npublic:\n    RolePermissionApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(int RoleId, int PermissionId);\n    String handleupdate(int id, int RoleId, int PermissionId);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nRolePermissionApis::RolePermissionApis(Context* cntxt, bool add_apis): context(cntxt) {\n    rolepermissionController = new RolePermissionController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ROLEPERMISSION_CREATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"RoleId\") || !req->getParams()->isQueryParameterSet(\"PermissionId\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string RoleId;\n        req->getParams()->getQueryParameter(\"RoleId\", RoleId);\n    std::string PermissionId;\n        req->getParams()->getQueryParameter(\"PermissionId\", PermissionId);\n\n        response(res, handlecreate(String(RoleId.c_str()).toInt(), String(PermissionId.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ROLEPERMISSION_UPDATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"RoleId\") || !req->getParams()->isQueryParameterSet(\"PermissionId\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        std::string RoleId;\n        req->getParams()->getQueryParameter(\"RoleId\", RoleId);\n    std::string PermissionId;\n        req->getParams()->getQueryParameter(\"PermissionId\", PermissionId);\n        \n        response(res, handleupdate(String(id.c_str()).toInt(), String(RoleId.c_str()).toInt(), String(PermissionId.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ROLEPERMISSION_DELETE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handledelete(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ROLEPERMISSION_GET)){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ROLEPERMISSION_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handlegetById(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::ROLEPERMISSION_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string query;\n        req->getParams()->getQueryParameter(\"query\", query);\n        \n        response(res, handleget(String(query.c_str())));\n    }));\n}\n\nString RolePermissionApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString RolePermissionApis::handlecreate(int RoleId, int PermissionId) {\n    RolePermissionEntity* rolepermissionEntity = new RolePermissionEntity(RoleId, PermissionId);\n    int id = rolepermissionController->Add(*rolepermissionEntity);\n    if (id != -1)\n    {\n        return String(id);\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString RolePermissionApis::handleupdate(int id, int RoleId, int PermissionId) {\n    RolePermissionEntity* rolepermissionEntity = new RolePermissionEntity(id, RoleId, PermissionId);\n    \n    if (rolepermissionController->Update(*rolepermissionEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString RolePermissionApis::handledelete(int id) {\n    \n    if (rolepermissionController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString RolePermissionApis::handlegetAll() {\n    return rolepermissionController->GetAllJson();\n}\nString RolePermissionApis::handlegetById(int id) {\n    return rolepermissionController->GetById(id).toJson();\n}\nString RolePermissionApis::handleget(String query) {\n    return rolepermissionController->GetJson(query);\n}\n\nString RolePermissionApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"RoleId\"].toInt(), parameters[\"PermissionId\"].toInt());\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"RoleId\"].toInt(), parameters[\"PermissionId\"].toInt());\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //ROLEPERMISSIONApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Authorization\\SecurityQuestionApis.h",
        "content": "#ifndef SECURITYQUESTIONAPIS_h\n#define SECURITYQUESTIONAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Security/SecurityQuestionController.h\"\n#include \"../../../Security/AuthorizationPermissions.h\"\n\nclass SecurityQuestionApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    SecurityQuestionController* securityquestionController;\n    std::string class_path = \"/securityquestion\";\n\npublic:\n    SecurityQuestionApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(int UserId, String SecurityQuestionTitleId, String Answer);\n    String handleupdate(int id, int UserId, String SecurityQuestionTitleId, String Answer);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nSecurityQuestionApis::SecurityQuestionApis(Context* cntxt, bool add_apis): context(cntxt) {\n    securityquestionController = new SecurityQuestionController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::SECURITYQUESTION_CREATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"UserId\") || !req->getParams()->isQueryParameterSet(\"SecurityQuestionTitleId\") || !req->getParams()->isQueryParameterSet(\"Answer\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string UserId;\n        req->getParams()->getQueryParameter(\"UserId\", UserId);\n    std::string SecurityQuestionTitleId;\n        req->getParams()->getQueryParameter(\"SecurityQuestionTitleId\", SecurityQuestionTitleId);\n    std::string Answer;\n        req->getParams()->getQueryParameter(\"Answer\", Answer);\n\n        response(res, handlecreate(String(UserId.c_str()).toInt(), String(SecurityQuestionTitleId.c_str()), String(Answer.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::SECURITYQUESTION_UPDATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"UserId\") || !req->getParams()->isQueryParameterSet(\"SecurityQuestionTitleId\") || !req->getParams()->isQueryParameterSet(\"Answer\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        std::string UserId;\n        req->getParams()->getQueryParameter(\"UserId\", UserId);\n    std::string SecurityQuestionTitleId;\n        req->getParams()->getQueryParameter(\"SecurityQuestionTitleId\", SecurityQuestionTitleId);\n    std::string Answer;\n        req->getParams()->getQueryParameter(\"Answer\", Answer);\n        \n        response(res, handleupdate(String(id.c_str()).toInt(), String(UserId.c_str()).toInt(), String(SecurityQuestionTitleId.c_str()), String(Answer.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::SECURITYQUESTION_DELETE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handledelete(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::SECURITYQUESTION_GET)){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::SECURITYQUESTION_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handlegetById(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::SECURITYQUESTION_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string query;\n        req->getParams()->getQueryParameter(\"query\", query);\n        \n        response(res, handleget(String(query.c_str())));\n    }));\n}\n\nString SecurityQuestionApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString SecurityQuestionApis::handlecreate(int UserId, String SecurityQuestionTitleId, String Answer) {\n    SecurityQuestionEntity* securityquestionEntity = new SecurityQuestionEntity(UserId, SecurityQuestionTitleId, Answer);\n    int id = securityquestionController->Add(*securityquestionEntity);\n    if (id != -1)\n    {\n        return String(id);\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString SecurityQuestionApis::handleupdate(int id, int UserId, String SecurityQuestionTitleId, String Answer) {\n    SecurityQuestionEntity* securityquestionEntity = new SecurityQuestionEntity(id, UserId, SecurityQuestionTitleId, Answer);\n    \n    if (securityquestionController->Update(*securityquestionEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString SecurityQuestionApis::handledelete(int id) {\n    \n    if (securityquestionController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString SecurityQuestionApis::handlegetAll() {\n    return securityquestionController->GetAllJson();\n}\nString SecurityQuestionApis::handlegetById(int id) {\n    return securityquestionController->GetById(id).toJson();\n}\nString SecurityQuestionApis::handleget(String query) {\n    return securityquestionController->GetJson(query);\n}\n\nString SecurityQuestionApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"UserId\"].toInt(), parameters[\"SecurityQuestionTitleId\"], parameters[\"Answer\"]);\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"UserId\"].toInt(), parameters[\"SecurityQuestionTitleId\"], parameters[\"Answer\"]);\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //SECURITYQUESTIONApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Authorization\\SecurityQuestionTitleApis.h",
        "content": "#ifndef SECURITYQUESTIONTITLEAPIS_h\n#define SECURITYQUESTIONTITLEAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Security/SecurityQuestionTitleController.h\"\n#include \"../../../Security/AuthorizationPermissions.h\"\n\nclass SecurityQuestionTitleApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    SecurityQuestionTitleController* securityquestiontitleController;\n    std::string class_path = \"/securityquestiontitle\";\n\npublic:\n    SecurityQuestionTitleApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(String QuestionTitle);\n    String handleupdate(int id, String QuestionTitle);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nSecurityQuestionTitleApis::SecurityQuestionTitleApis(Context* cntxt, bool add_apis): context(cntxt) {\n    securityquestiontitleController = new SecurityQuestionTitleController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::SECURITYQUESTIONTITLE_CREATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"QuestionTitle\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string QuestionTitle;\n        req->getParams()->getQueryParameter(\"QuestionTitle\", QuestionTitle);\n\n        response(res, handlecreate(String(QuestionTitle.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::SECURITYQUESTIONTITLE_UPDATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"QuestionTitle\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        std::string QuestionTitle;\n        req->getParams()->getQueryParameter(\"QuestionTitle\", QuestionTitle);\n        \n        response(res, handleupdate(String(id.c_str()).toInt(), String(QuestionTitle.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::SECURITYQUESTIONTITLE_DELETE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handledelete(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::SECURITYQUESTIONTITLE_GET)){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::SECURITYQUESTIONTITLE_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handlegetById(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::SECURITYQUESTIONTITLE_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string query;\n        req->getParams()->getQueryParameter(\"query\", query);\n        \n        response(res, handleget(String(query.c_str())));\n    }));\n}\n\nString SecurityQuestionTitleApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString SecurityQuestionTitleApis::handlecreate(String QuestionTitle) {\n    SecurityQuestionTitleEntity* securityquestiontitleEntity = new SecurityQuestionTitleEntity(QuestionTitle);\n    int id = securityquestiontitleController->Add(*securityquestiontitleEntity);\n    if (id != -1)\n    {\n        return String(id);\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString SecurityQuestionTitleApis::handleupdate(int id, String QuestionTitle) {\n    SecurityQuestionTitleEntity* securityquestiontitleEntity = new SecurityQuestionTitleEntity(id, QuestionTitle);\n    \n    if (securityquestiontitleController->Update(*securityquestiontitleEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString SecurityQuestionTitleApis::handledelete(int id) {\n    \n    if (securityquestiontitleController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString SecurityQuestionTitleApis::handlegetAll() {\n    return securityquestiontitleController->GetAllJson();\n}\nString SecurityQuestionTitleApis::handlegetById(int id) {\n    return securityquestiontitleController->GetById(id).toJson();\n}\nString SecurityQuestionTitleApis::handleget(String query) {\n    return securityquestiontitleController->GetJson(query);\n}\n\nString SecurityQuestionTitleApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"QuestionTitle\"]);\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"QuestionTitle\"]);\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //SECURITYQUESTIONTITLEApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Authorization\\TwoFactorAuthApis.h",
        "content": "#ifndef TWOFACTORAUTHAPIS_h\n#define TWOFACTORAUTHAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Security/TwoFactorAuthController.h\"\n#include \"../../../Security/AuthorizationPermissions.h\"\n\nclass TwoFactorAuthApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    TwoFactorAuthController* twofactorauthController;\n    std::string class_path = \"/twofactorauth\";\n\npublic:\n    TwoFactorAuthApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(int UserId, String OtpCode, EBPDateTime ExpiryTime);\n    String handleupdate(int id, int UserId, String OtpCode, EBPDateTime ExpiryTime);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nTwoFactorAuthApis::TwoFactorAuthApis(Context* cntxt, bool add_apis): context(cntxt) {\n    twofactorauthController = new TwoFactorAuthController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::TWOFACTORAUTH_CREATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"UserId\") || !req->getParams()->isQueryParameterSet(\"OtpCode\") || !req->getParams()->isQueryParameterSet(\"ExpiryTime\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string UserId;\n        req->getParams()->getQueryParameter(\"UserId\", UserId);\n    std::string OtpCode;\n        req->getParams()->getQueryParameter(\"OtpCode\", OtpCode);\n    std::string ExpiryTime;\n        req->getParams()->getQueryParameter(\"ExpiryTime\", ExpiryTime);\n\n        response(res, handlecreate(String(UserId.c_str()).toInt(), String(OtpCode.c_str()), String(ExpiryTime.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::TWOFACTORAUTH_UPDATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"UserId\") || !req->getParams()->isQueryParameterSet(\"OtpCode\") || !req->getParams()->isQueryParameterSet(\"ExpiryTime\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        std::string UserId;\n        req->getParams()->getQueryParameter(\"UserId\", UserId);\n    std::string OtpCode;\n        req->getParams()->getQueryParameter(\"OtpCode\", OtpCode);\n    std::string ExpiryTime;\n        req->getParams()->getQueryParameter(\"ExpiryTime\", ExpiryTime);\n        \n        response(res, handleupdate(String(id.c_str()).toInt(), String(UserId.c_str()).toInt(), String(OtpCode.c_str()), String(ExpiryTime.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::TWOFACTORAUTH_DELETE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handledelete(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::TWOFACTORAUTH_GET)){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::TWOFACTORAUTH_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handlegetById(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::TWOFACTORAUTH_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string query;\n        req->getParams()->getQueryParameter(\"query\", query);\n        \n        response(res, handleget(String(query.c_str())));\n    }));\n}\n\nString TwoFactorAuthApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString TwoFactorAuthApis::handlecreate(int UserId, String OtpCode, EBPDateTime ExpiryTime) {\n    TwoFactorAuthEntity* twofactorauthEntity = new TwoFactorAuthEntity(UserId, OtpCode, ExpiryTime);\n    int id = twofactorauthController->Add(*twofactorauthEntity);\n    if (id != -1)\n    {\n        return String(id);\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString TwoFactorAuthApis::handleupdate(int id, int UserId, String OtpCode, EBPDateTime ExpiryTime) {\n    TwoFactorAuthEntity* twofactorauthEntity = new TwoFactorAuthEntity(id, UserId, OtpCode, ExpiryTime);\n    \n    if (twofactorauthController->Update(*twofactorauthEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString TwoFactorAuthApis::handledelete(int id) {\n    \n    if (twofactorauthController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString TwoFactorAuthApis::handlegetAll() {\n    return twofactorauthController->GetAllJson();\n}\nString TwoFactorAuthApis::handlegetById(int id) {\n    return twofactorauthController->GetById(id).toJson();\n}\nString TwoFactorAuthApis::handleget(String query) {\n    return twofactorauthController->GetJson(query);\n}\n\nString TwoFactorAuthApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"UserId\"].toInt(), parameters[\"OtpCode\"], parameters[\"ExpiryTime\"]);\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"UserId\"].toInt(), parameters[\"OtpCode\"], parameters[\"ExpiryTime\"]);\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //TWOFACTORAUTHApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Authorization\\UserApis.h",
        "content": "#ifndef USERAPIS_h\n#define USERAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Security/UserController.h\"\n#include \"../../../Security/AuthorizationPermissions.h\"\n\nclass UserApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    UserController* userController;\n    std::string class_path = \"/user\";\n\npublic:\n    UserApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(String Username, String Password, String Email, String PhoneNumber, int RoleId, bool TwoFactorAuth, String ApiKey, String Token, EBPDateTime TokenExpiryTime);\n    String handleupdate(int id, String Username, String Password, String Email, String PhoneNumber, int RoleId, bool TwoFactorAuth, String ApiKey, String Token, EBPDateTime TokenExpiryTime);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nUserApis::UserApis(Context* cntxt, bool add_apis): context(cntxt) {\n    userController = new UserController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::USER_CREATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"Username\") || !req->getParams()->isQueryParameterSet(\"Password\") || !req->getParams()->isQueryParameterSet(\"Email\") || !req->getParams()->isQueryParameterSet(\"PhoneNumber\") || !req->getParams()->isQueryParameterSet(\"RoleId\") || !req->getParams()->isQueryParameterSet(\"TwoFactorAuth\") || !req->getParams()->isQueryParameterSet(\"ApiKey\") || !req->getParams()->isQueryParameterSet(\"Token\") || !req->getParams()->isQueryParameterSet(\"TokenExpiryTime\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string Username;\n        req->getParams()->getQueryParameter(\"Username\", Username);\n    std::string Password;\n        req->getParams()->getQueryParameter(\"Password\", Password);\n    std::string Email;\n        req->getParams()->getQueryParameter(\"Email\", Email);\n    std::string PhoneNumber;\n        req->getParams()->getQueryParameter(\"PhoneNumber\", PhoneNumber);\n    std::string RoleId;\n        req->getParams()->getQueryParameter(\"RoleId\", RoleId);\n    std::string TwoFactorAuth;\n        req->getParams()->getQueryParameter(\"TwoFactorAuth\", TwoFactorAuth);\n    std::string ApiKey;\n        req->getParams()->getQueryParameter(\"ApiKey\", ApiKey);\n    std::string Token;\n        req->getParams()->getQueryParameter(\"Token\", Token);\n    std::string TokenExpiryTime;\n        req->getParams()->getQueryParameter(\"TokenExpiryTime\", TokenExpiryTime);\n\n        response(res, handlecreate(String(Username.c_str()), String(Password.c_str()), String(Email.c_str()), String(PhoneNumber.c_str()), String(RoleId.c_str()).toInt(), String(TwoFactorAuth.c_str()).toInt(), String(ApiKey.c_str()), String(Token.c_str()), String(TokenExpiryTime.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::USER_UPDATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"Username\") || !req->getParams()->isQueryParameterSet(\"Password\") || !req->getParams()->isQueryParameterSet(\"Email\") || !req->getParams()->isQueryParameterSet(\"PhoneNumber\") || !req->getParams()->isQueryParameterSet(\"RoleId\") || !req->getParams()->isQueryParameterSet(\"TwoFactorAuth\") || !req->getParams()->isQueryParameterSet(\"ApiKey\") || !req->getParams()->isQueryParameterSet(\"Token\") || !req->getParams()->isQueryParameterSet(\"TokenExpiryTime\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        std::string Username;\n        req->getParams()->getQueryParameter(\"Username\", Username);\n    std::string Password;\n        req->getParams()->getQueryParameter(\"Password\", Password);\n    std::string Email;\n        req->getParams()->getQueryParameter(\"Email\", Email);\n    std::string PhoneNumber;\n        req->getParams()->getQueryParameter(\"PhoneNumber\", PhoneNumber);\n    std::string RoleId;\n        req->getParams()->getQueryParameter(\"RoleId\", RoleId);\n    std::string TwoFactorAuth;\n        req->getParams()->getQueryParameter(\"TwoFactorAuth\", TwoFactorAuth);\n    std::string ApiKey;\n        req->getParams()->getQueryParameter(\"ApiKey\", ApiKey);\n    std::string Token;\n        req->getParams()->getQueryParameter(\"Token\", Token);\n    std::string TokenExpiryTime;\n        req->getParams()->getQueryParameter(\"TokenExpiryTime\", TokenExpiryTime);\n        \n        response(res, handleupdate(String(id.c_str()).toInt(), String(Username.c_str()), String(Password.c_str()), String(Email.c_str()), String(PhoneNumber.c_str()), String(RoleId.c_str()).toInt(), String(TwoFactorAuth.c_str()).toInt(), String(ApiKey.c_str()), String(Token.c_str()), String(TokenExpiryTime.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::USER_DELETE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handledelete(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::USER_GET)){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::USER_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handlegetById(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::USER_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string query;\n        req->getParams()->getQueryParameter(\"query\", query);\n        \n        response(res, handleget(String(query.c_str())));\n    }));\n}\n\nString UserApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString UserApis::handlecreate(String Username, String Password, String Email, String PhoneNumber, int RoleId, bool TwoFactorAuth, String ApiKey, String Token, EBPDateTime TokenExpiryTime) {\n    UserEntity* userEntity = new UserEntity(Username, Password, Email, PhoneNumber, RoleId, TwoFactorAuth, ApiKey, Token, TokenExpiryTime);\n    int id = userController->Add(*userEntity);\n    if (id != -1)\n    {\n        return String(id);\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString UserApis::handleupdate(int id, String Username, String Password, String Email, String PhoneNumber, int RoleId, bool TwoFactorAuth, String ApiKey, String Token, EBPDateTime TokenExpiryTime) {\n    UserEntity* userEntity = new UserEntity(id, Username, Password, Email, PhoneNumber, RoleId, TwoFactorAuth, ApiKey, Token, TokenExpiryTime);\n    \n    if (userController->Update(*userEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString UserApis::handledelete(int id) {\n    \n    if (userController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString UserApis::handlegetAll() {\n    return userController->GetAllJson();\n}\nString UserApis::handlegetById(int id) {\n    return userController->GetById(id).toJson();\n}\nString UserApis::handleget(String query) {\n    return userController->GetJson(query);\n}\n\nString UserApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"Username\"], parameters[\"Password\"], parameters[\"Email\"], parameters[\"PhoneNumber\"], parameters[\"RoleId\"].toInt(), parameters[\"TwoFactorAuth\"].toInt(), parameters[\"ApiKey\"], parameters[\"Token\"], parameters[\"TokenExpiryTime\"]);\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"Username\"], parameters[\"Password\"], parameters[\"Email\"], parameters[\"PhoneNumber\"], parameters[\"RoleId\"].toInt(), parameters[\"TwoFactorAuth\"].toInt(), parameters[\"ApiKey\"], parameters[\"Token\"], parameters[\"TokenExpiryTime\"]);\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //USERApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Authorization\\UserResetPassApis.h",
        "content": "#ifndef USERRESETPASSAPIS_h\n#define USERRESETPASSAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Security/UserResetPassController.h\"\n#include \"../../../Security/AuthorizationPermissions.h\"\n\nclass UserResetPassApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    UserResetPassController* userresetpassController;\n    std::string class_path = \"/userresetpass\";\n\npublic:\n    UserResetPassApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(int UserId, String ResetToken, EBPDateTime ExpiryTime);\n    String handleupdate(int id, int UserId, String ResetToken, EBPDateTime ExpiryTime);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nUserResetPassApis::UserResetPassApis(Context* cntxt, bool add_apis): context(cntxt) {\n    userresetpassController = new UserResetPassController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::USERRESETPASS_CREATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"UserId\") || !req->getParams()->isQueryParameterSet(\"ResetToken\") || !req->getParams()->isQueryParameterSet(\"ExpiryTime\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string UserId;\n        req->getParams()->getQueryParameter(\"UserId\", UserId);\n    std::string ResetToken;\n        req->getParams()->getQueryParameter(\"ResetToken\", ResetToken);\n    std::string ExpiryTime;\n        req->getParams()->getQueryParameter(\"ExpiryTime\", ExpiryTime);\n\n        response(res, handlecreate(String(UserId.c_str()).toInt(), String(ResetToken.c_str()), String(ExpiryTime.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::USERRESETPASS_UPDATE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"UserId\") || !req->getParams()->isQueryParameterSet(\"ResetToken\") || !req->getParams()->isQueryParameterSet(\"ExpiryTime\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        std::string UserId;\n        req->getParams()->getQueryParameter(\"UserId\", UserId);\n    std::string ResetToken;\n        req->getParams()->getQueryParameter(\"ResetToken\", ResetToken);\n    std::string ExpiryTime;\n        req->getParams()->getQueryParameter(\"ExpiryTime\", ExpiryTime);\n        \n        response(res, handleupdate(String(id.c_str()).toInt(), String(UserId.c_str()).toInt(), String(ResetToken.c_str()), String(ExpiryTime.c_str())));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::USERRESETPASS_DELETE)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handledelete(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::USERRESETPASS_GET)){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::USERRESETPASS_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string id;\n        req->getParams()->getQueryParameter(\"id\", id);\n        \n        response(res, handlegetById(String(id.c_str()).toInt()));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, AuthorizationPermissions::USERRESETPASS_GET)){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        std::string query;\n        req->getParams()->getQueryParameter(\"query\", query);\n        \n        response(res, handleget(String(query.c_str())));\n    }));\n}\n\nString UserResetPassApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString UserResetPassApis::handlecreate(int UserId, String ResetToken, EBPDateTime ExpiryTime) {\n    UserResetPassEntity* userresetpassEntity = new UserResetPassEntity(UserId, ResetToken, ExpiryTime);\n    int id = userresetpassController->Add(*userresetpassEntity);\n    if (id != -1)\n    {\n        return String(id);\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString UserResetPassApis::handleupdate(int id, int UserId, String ResetToken, EBPDateTime ExpiryTime) {\n    UserResetPassEntity* userresetpassEntity = new UserResetPassEntity(id, UserId, ResetToken, ExpiryTime);\n    \n    if (userresetpassController->Update(*userresetpassEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString UserResetPassApis::handledelete(int id) {\n    \n    if (userresetpassController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString UserResetPassApis::handlegetAll() {\n    return userresetpassController->GetAllJson();\n}\nString UserResetPassApis::handlegetById(int id) {\n    return userresetpassController->GetById(id).toJson();\n}\nString UserResetPassApis::handleget(String query) {\n    return userresetpassController->GetJson(query);\n}\n\nString UserResetPassApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"UserId\"].toInt(), parameters[\"ResetToken\"], parameters[\"ExpiryTime\"]);\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"UserId\"].toInt(), parameters[\"ResetToken\"], parameters[\"ExpiryTime\"]);\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //USERRESETPASSApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Modules\\AddModulesApis.h",
        "content": "\n#ifndef ADDMODULESAPIS_H\n#define ADDMODULESAPIS_H\n\n#include \"ModulePermissions.h\"\n#include \"ButtonApis.h\"\n#include \"ModuleApis.h\"\n#include \"RelayApis.h\"\n#include \"LCDApis.h\"\n#include \"DHTApis.h\"\n#include \"PhotoresistorApis.h\"\n#include \"RGBApis.h\"\n#include \"SoilMoistureApis.h\"\n\n\nvoid createModulesApis(Context* context)\n{\n    std::vector<ApiInterface*> apis = std::vector<ApiInterface*>();\n\n    \n    ButtonApis* buttonApis = new ButtonApis(context, true);\n    apis.push_back(buttonApis);\n    \n    ModuleApis* moduleApis = new ModuleApis(context, true);\n    apis.push_back(moduleApis);\n    \n    RelayApis* relayApis = new RelayApis(context, true);\n    apis.push_back(relayApis);\n    \n    LCDApis* lcdApis = new LCDApis(context, true);\n    apis.push_back(lcdApis);\n    \n    DHTApis* dhtApis = new DHTApis(context, true);\n    apis.push_back(dhtApis);\n    \n    PhotoresistorApis* photoresistorApis = new PhotoresistorApis(context, true);\n    apis.push_back(photoresistorApis);\n    \n    RGBApis* rgbApis = new RGBApis(context, true);\n    apis.push_back(rgbApis);\n    \n    SoilMoistureApis* soilmoistureApis = new SoilMoistureApis(context, true);\n    apis.push_back(soilmoistureApis);\n    \n\n    context->getNetwork()->addApis(apis);\n}\n\n#endif //APIS_H\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Modules\\ButtonApis.h",
        "content": "#ifndef BUTTONAPIS_h\n#define BUTTONAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Modules/ButtonController.h\"\n#include \"ModulePermissions.h\"\n\nclass ButtonApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    ButtonController* buttonController;\n    std::string class_path = \"/button\";\n\npublic:\n    ButtonApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(int ModuleId, String ButtonType, bool ActiveHigh, bool PullupActive, int DebounceDelay);\n    String handleupdate(int id, int ModuleId, String ButtonType, bool ActiveHigh, bool PullupActive, int DebounceDelay);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nButtonApis::ButtonApis(Context* cntxt, bool add_apis): context(cntxt) {\n    buttonController = new ButtonController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::BUTTON_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"ModuleId\") || !req->getParams()->isQueryParameterSet(\"ButtonType\") || !req->getParams()->isQueryParameterSet(\"ActiveHigh\") || !req->getParams()->isQueryParameterSet(\"PullupActive\") || !req->getParams()->isQueryParameterSet(\"DebounceDelay\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        int ModuleId = getQueryParameterint(req, \"ModuleId\");\n    String ButtonType = getQueryParameterString(req, \"ButtonType\");\n    bool ActiveHigh = boolean(getQueryParameterString(req, \"ActiveHigh\"));\n    bool PullupActive = boolean(getQueryParameterString(req, \"PullupActive\"));\n    int DebounceDelay = getQueryParameterint(req, \"DebounceDelay\");\n\n        response(res, handlecreate(ModuleId, ButtonType, ActiveHigh, PullupActive, DebounceDelay));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::BUTTON_UPDATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"ModuleId\") || !req->getParams()->isQueryParameterSet(\"ButtonType\") || !req->getParams()->isQueryParameterSet(\"ActiveHigh\") || !req->getParams()->isQueryParameterSet(\"PullupActive\") || !req->getParams()->isQueryParameterSet(\"DebounceDelay\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        int ModuleId = getQueryParameterint(req, \"ModuleId\");\n    String ButtonType = getQueryParameterString(req, \"ButtonType\");\n    bool ActiveHigh = boolean(getQueryParameterString(req, \"ActiveHigh\"));\n    bool PullupActive = boolean(getQueryParameterString(req, \"PullupActive\"));\n    int DebounceDelay = getQueryParameterint(req, \"DebounceDelay\");\n        \n        response(res, handleupdate(id, ModuleId, ButtonType, ActiveHigh, PullupActive, DebounceDelay));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::BUTTON_DELETE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handledelete(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::BUTTON_GET) == AuthorizationResults::SUCCESFULL){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::BUTTON_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handlegetById(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::BUTTON_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        String query = getQueryParameterString(req, \"query\");\n        \n        response(res, handleget(query));\n    }));\n}\n\nString ButtonApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString ButtonApis::handlecreate(int ModuleId, String ButtonType, bool ActiveHigh, bool PullupActive, int DebounceDelay) {\n    ButtonEntity* buttonEntity = new ButtonEntity(ModuleId, ButtonType, ActiveHigh, PullupActive, DebounceDelay);\n    int id = buttonController->Add(*buttonEntity);\n    if (id != -1)\n    {\n        return CREATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString ButtonApis::handleupdate(int id, int ModuleId, String ButtonType, bool ActiveHigh, bool PullupActive, int DebounceDelay) {\n    ButtonEntity* buttonEntity = new ButtonEntity(id, ModuleId, ButtonType, ActiveHigh, PullupActive, DebounceDelay);\n    \n    if (buttonController->Update(*buttonEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString ButtonApis::handledelete(int id) {\n    \n    if (buttonController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString ButtonApis::handlegetAll() {\n    return buttonController->GetAllJson();\n}\nString ButtonApis::handlegetById(int id) {\n    return buttonController->GetById(id).toJson();\n}\nString ButtonApis::handleget(String query) {\n    return buttonController->GetJson(query);\n}\n\nString ButtonApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"ModuleId\"].toInt(), parameters[\"ButtonType\"], parameters[\"ActiveHigh\"].toInt(), parameters[\"PullupActive\"].toInt(), parameters[\"DebounceDelay\"].toInt());\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"ModuleId\"].toInt(), parameters[\"ButtonType\"], parameters[\"ActiveHigh\"].toInt(), parameters[\"PullupActive\"].toInt(), parameters[\"DebounceDelay\"].toInt());\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //BUTTONApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Modules\\DHTApis.h",
        "content": "#ifndef DHTAPIS_h\n#define DHTAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Modules/DHTController.h\"\n#include \"ModulePermissions.h\"\n\nclass DHTApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    DHTController* dhtController;\n    std::string class_path = \"/dht\";\n\npublic:\n    DHTApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(String Type, int DryTreshold, int WetTreshold, int CoolTreshold, int HotTreshold);\n    String handleupdate(int id, String Type, int DryTreshold, int WetTreshold, int CoolTreshold, int HotTreshold);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nDHTApis::DHTApis(Context* cntxt, bool add_apis): context(cntxt) {\n    dhtController = new DHTController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::DHT_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"Type\") || !req->getParams()->isQueryParameterSet(\"DryTreshold\") || !req->getParams()->isQueryParameterSet(\"WetTreshold\") || !req->getParams()->isQueryParameterSet(\"CoolTreshold\") || !req->getParams()->isQueryParameterSet(\"HotTreshold\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        String Type = getQueryParameterString(req, \"Type\");\n    int DryTreshold = getQueryParameterint(req, \"DryTreshold\");\n    int WetTreshold = getQueryParameterint(req, \"WetTreshold\");\n    int CoolTreshold = getQueryParameterint(req, \"CoolTreshold\");\n    int HotTreshold = getQueryParameterint(req, \"HotTreshold\");\n\n        response(res, handlecreate(Type, DryTreshold, WetTreshold, CoolTreshold, HotTreshold));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::DHT_UPDATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"Type\") || !req->getParams()->isQueryParameterSet(\"DryTreshold\") || !req->getParams()->isQueryParameterSet(\"WetTreshold\") || !req->getParams()->isQueryParameterSet(\"CoolTreshold\") || !req->getParams()->isQueryParameterSet(\"HotTreshold\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        String Type = getQueryParameterString(req, \"Type\");\n    int DryTreshold = getQueryParameterint(req, \"DryTreshold\");\n    int WetTreshold = getQueryParameterint(req, \"WetTreshold\");\n    int CoolTreshold = getQueryParameterint(req, \"CoolTreshold\");\n    int HotTreshold = getQueryParameterint(req, \"HotTreshold\");\n        \n        response(res, handleupdate(id, Type, DryTreshold, WetTreshold, CoolTreshold, HotTreshold));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::DHT_DELETE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handledelete(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::DHT_GET) == AuthorizationResults::SUCCESFULL){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::DHT_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handlegetById(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::DHT_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        String query = getQueryParameterString(req, \"query\");\n        \n        response(res, handleget(query));\n    }));\n}\n\nString DHTApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString DHTApis::handlecreate(String Type, int DryTreshold, int WetTreshold, int CoolTreshold, int HotTreshold) {\n    DHTEntity* dhtEntity = new DHTEntity(Type, DryTreshold, WetTreshold, CoolTreshold, HotTreshold);\n    int id = dhtController->Add(*dhtEntity);\n    if (id != -1)\n    {\n        return CREATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString DHTApis::handleupdate(int id, String Type, int DryTreshold, int WetTreshold, int CoolTreshold, int HotTreshold) {\n    DHTEntity* dhtEntity = new DHTEntity(id, Type, DryTreshold, WetTreshold, CoolTreshold, HotTreshold);\n    \n    if (dhtController->Update(*dhtEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString DHTApis::handledelete(int id) {\n    \n    if (dhtController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString DHTApis::handlegetAll() {\n    return dhtController->GetAllJson();\n}\nString DHTApis::handlegetById(int id) {\n    return dhtController->GetById(id).toJson();\n}\nString DHTApis::handleget(String query) {\n    return dhtController->GetJson(query);\n}\n\nString DHTApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"Type\"], parameters[\"DryTreshold\"].toInt(), parameters[\"WetTreshold\"].toInt(), parameters[\"CoolTreshold\"].toInt(), parameters[\"HotTreshold\"].toInt());\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"Type\"], parameters[\"DryTreshold\"].toInt(), parameters[\"WetTreshold\"].toInt(), parameters[\"CoolTreshold\"].toInt(), parameters[\"HotTreshold\"].toInt());\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //DHTApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Modules\\LCDApis.h",
        "content": "#ifndef LCDAPIS_h\n#define LCDAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Modules/LCDController.h\"\n#include \"ModulePermissions.h\"\n\nclass LCDApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    LCDController* lcdController;\n    std::string class_path = \"/lcd\";\n\npublic:\n    LCDApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(int ModuleId, int Address, int Rows, int Cols, String Type);\n    String handleupdate(int id, int ModuleId, int Address, int Rows, int Cols, String Type);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nLCDApis::LCDApis(Context* cntxt, bool add_apis): context(cntxt) {\n    lcdController = new LCDController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::LCD_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"ModuleId\") || !req->getParams()->isQueryParameterSet(\"Address\") || !req->getParams()->isQueryParameterSet(\"Rows\") || !req->getParams()->isQueryParameterSet(\"Cols\") || !req->getParams()->isQueryParameterSet(\"Type\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        int ModuleId = getQueryParameterint(req, \"ModuleId\");\n    int Address = getQueryParameterint(req, \"Address\");\n    int Rows = getQueryParameterint(req, \"Rows\");\n    int Cols = getQueryParameterint(req, \"Cols\");\n    String Type = getQueryParameterString(req, \"Type\");\n\n        response(res, handlecreate(ModuleId, Address, Rows, Cols, Type));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::LCD_UPDATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"ModuleId\") || !req->getParams()->isQueryParameterSet(\"Address\") || !req->getParams()->isQueryParameterSet(\"Rows\") || !req->getParams()->isQueryParameterSet(\"Cols\") || !req->getParams()->isQueryParameterSet(\"Type\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        int ModuleId = getQueryParameterint(req, \"ModuleId\");\n    int Address = getQueryParameterint(req, \"Address\");\n    int Rows = getQueryParameterint(req, \"Rows\");\n    int Cols = getQueryParameterint(req, \"Cols\");\n    String Type = getQueryParameterString(req, \"Type\");\n        \n        response(res, handleupdate(id, ModuleId, Address, Rows, Cols, Type));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::LCD_DELETE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handledelete(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::LCD_GET) == AuthorizationResults::SUCCESFULL){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::LCD_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handlegetById(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::LCD_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        String query = getQueryParameterString(req, \"query\");\n        \n        response(res, handleget(query));\n    }));\n}\n\nString LCDApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString LCDApis::handlecreate(int ModuleId, int Address, int Rows, int Cols, String Type) {\n    LCDEntity* lcdEntity = new LCDEntity(ModuleId, Address, Rows, Cols, Type);\n    int id = lcdController->Add(*lcdEntity);\n    if (id != -1)\n    {\n        return CREATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString LCDApis::handleupdate(int id, int ModuleId, int Address, int Rows, int Cols, String Type) {\n    LCDEntity* lcdEntity = new LCDEntity(id, ModuleId, Address, Rows, Cols, Type);\n    \n    if (lcdController->Update(*lcdEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString LCDApis::handledelete(int id) {\n    \n    if (lcdController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString LCDApis::handlegetAll() {\n    return lcdController->GetAllJson();\n}\nString LCDApis::handlegetById(int id) {\n    return lcdController->GetById(id).toJson();\n}\nString LCDApis::handleget(String query) {\n    return lcdController->GetJson(query);\n}\n\nString LCDApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"ModuleId\"].toInt(), parameters[\"Address\"].toInt(), parameters[\"Rows\"].toInt(), parameters[\"Cols\"].toInt(), parameters[\"Type\"]);\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"ModuleId\"].toInt(), parameters[\"Address\"].toInt(), parameters[\"Rows\"].toInt(), parameters[\"Cols\"].toInt(), parameters[\"Type\"]);\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //LCDApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Modules\\ModuleApis.h",
        "content": "#ifndef MODULEAPIS_h\n#define MODULEAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Modules/ModulesController.h\"\n#include \"ModulePermissions.h\"\n\nclass ModuleApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    ModulesController* moduleController;\n    std::string class_path = \"/module\";\n\npublic:\n    ModuleApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(String Name, String ModuleType, String ConnectionType, int NodeId, int PinNumber);\n    String handleupdate(int id, String Name, String ModuleType, String ConnectionType, int NodeId, int PinNumber);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nModuleApis::ModuleApis(Context* cntxt, bool add_apis): context(cntxt) {\n    moduleController = new ModulesController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::MODULE_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"Name\") || !req->getParams()->isQueryParameterSet(\"ModuleType\") || !req->getParams()->isQueryParameterSet(\"ConnectionType\") || !req->getParams()->isQueryParameterSet(\"NodeId\") || !req->getParams()->isQueryParameterSet(\"PinNumber\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        String Name = getQueryParameterString(req, \"Name\");\n    String ModuleType = getQueryParameterString(req, \"ModuleType\");\n    String ConnectionType = getQueryParameterString(req, \"ConnectionType\");\n    int NodeId = getQueryParameterint(req, \"NodeId\");\n    int PinNumber = getQueryParameterint(req, \"PinNumber\");\n\n        response(res, handlecreate(Name, ModuleType, ConnectionType, NodeId, PinNumber));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::MODULE_UPDATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"Name\") || !req->getParams()->isQueryParameterSet(\"ModuleType\") || !req->getParams()->isQueryParameterSet(\"ConnectionType\") || !req->getParams()->isQueryParameterSet(\"NodeId\") || !req->getParams()->isQueryParameterSet(\"PinNumber\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        String Name = getQueryParameterString(req, \"Name\");\n    String ModuleType = getQueryParameterString(req, \"ModuleType\");\n    String ConnectionType = getQueryParameterString(req, \"ConnectionType\");\n    int NodeId = getQueryParameterint(req, \"NodeId\");\n    int PinNumber = getQueryParameterint(req, \"PinNumber\");\n        \n        response(res, handleupdate(id, Name, ModuleType, ConnectionType, NodeId, PinNumber));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::MODULE_DELETE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handledelete(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::MODULE_GET) == AuthorizationResults::SUCCESFULL){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::MODULE_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handlegetById(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::MODULE_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        String query = getQueryParameterString(req, \"query\");\n        \n        response(res, handleget(query));\n    }));\n}\n\nString ModuleApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString ModuleApis::handlecreate(String Name, String ModuleType, String ConnectionType, int NodeId, int PinNumber) {\n    ModuleEntity* moduleEntity = new ModuleEntity(Name, ModuleType, ConnectionType, NodeId, PinNumber);\n    int id = moduleController->Add(*moduleEntity);\n    if (id != -1)\n    {\n        return CREATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString ModuleApis::handleupdate(int id, String Name, String ModuleType, String ConnectionType, int NodeId, int PinNumber) {\n    ModuleEntity* moduleEntity = new ModuleEntity(id, Name, ModuleType, ConnectionType, NodeId, PinNumber);\n    \n    if (moduleController->Update(*moduleEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString ModuleApis::handledelete(int id) {\n    \n    if (moduleController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString ModuleApis::handlegetAll() {\n    return moduleController->GetAllJson();\n}\nString ModuleApis::handlegetById(int id) {\n    return moduleController->GetById(id).toJson();\n}\nString ModuleApis::handleget(String query) {\n    return moduleController->GetJson(query);\n}\n\nString ModuleApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"Name\"], parameters[\"ModuleType\"], parameters[\"ConnectionType\"], parameters[\"NodeId\"].toInt(), parameters[\"PinNumber\"].toInt());\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"Name\"], parameters[\"ModuleType\"], parameters[\"ConnectionType\"], parameters[\"NodeId\"].toInt(), parameters[\"PinNumber\"].toInt());\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //MODULEApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Modules\\ModulePermissions.h",
        "content": "#ifndef MODULEPERMISSIONS_H\n#define MODULEPERMISSIONS_H\n\n#include \"../../../Context.h\"\n\nclass ModulePermissions\n{\npublic:\n    static const String BUTTON_CREATE;\n    static const String BUTTON_UPDATE;\n    static const String BUTTON_DELETE;\n    static const String BUTTON_GET;\n    static const String MODULE_CREATE;\n    static const String MODULE_UPDATE;\n    static const String MODULE_DELETE;\n    static const String MODULE_GET;\n    static const String RELAY_CREATE;\n    static const String RELAY_UPDATE;\n    static const String RELAY_DELETE;\n    static const String RELAY_GET;\n    static const String LCD_CREATE;\n    static const String LCD_UPDATE;\n    static const String LCD_DELETE;\n    static const String LCD_GET;\n    static const String DHT_CREATE;\n    static const String DHT_UPDATE;\n    static const String DHT_DELETE;\n    static const String DHT_GET;\n    static const String PHOTORESISTOR_CREATE;\n    static const String PHOTORESISTOR_UPDATE;\n    static const String PHOTORESISTOR_DELETE;\n    static const String PHOTORESISTOR_GET;\n    static const String RGB_CREATE;\n    static const String RGB_UPDATE;\n    static const String RGB_DELETE;\n    static const String RGB_GET;\n    static const String SOILMOISTURE_CREATE;\n    static const String SOILMOISTURE_UPDATE;\n    static const String SOILMOISTURE_DELETE;\n    static const String SOILMOISTURE_GET;\n\n\n    static void addPermissions(Context* context);\n};\n\nvoid ModulePermissions::addPermissions(Context* context)\n{\n    context->getSecurity()->addPermissionForAdmin(BUTTON_CREATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(BUTTON_UPDATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(BUTTON_DELETE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(BUTTON_GET, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(MODULE_CREATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(MODULE_UPDATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(MODULE_DELETE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(MODULE_GET, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(RELAY_CREATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(RELAY_UPDATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(RELAY_DELETE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(RELAY_GET, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(LCD_CREATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(LCD_UPDATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(LCD_DELETE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(LCD_GET, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(DHT_CREATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(DHT_UPDATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(DHT_DELETE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(DHT_GET, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(PHOTORESISTOR_CREATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(PHOTORESISTOR_UPDATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(PHOTORESISTOR_DELETE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(PHOTORESISTOR_GET, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(RGB_CREATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(RGB_UPDATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(RGB_DELETE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(RGB_GET, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(SOILMOISTURE_CREATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(SOILMOISTURE_UPDATE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(SOILMOISTURE_DELETE, \"ModuleApis Permissions\");\n    context->getSecurity()->addPermissionForAdmin(SOILMOISTURE_GET, \"ModuleApis Permissions\");\n\n}\n\nconst String ModulePermissions::BUTTON_CREATE = \"button_create\";\nconst String ModulePermissions::BUTTON_UPDATE = \"button_update\";\nconst String ModulePermissions::BUTTON_DELETE = \"button_delete\";\nconst String ModulePermissions::BUTTON_GET = \"button_get\";\nconst String ModulePermissions::MODULE_CREATE = \"module_create\";\nconst String ModulePermissions::MODULE_UPDATE = \"module_update\";\nconst String ModulePermissions::MODULE_DELETE = \"module_delete\";\nconst String ModulePermissions::MODULE_GET = \"module_get\";\nconst String ModulePermissions::RELAY_CREATE = \"relay_create\";\nconst String ModulePermissions::RELAY_UPDATE = \"relay_update\";\nconst String ModulePermissions::RELAY_DELETE = \"relay_delete\";\nconst String ModulePermissions::RELAY_GET = \"relay_get\";\nconst String ModulePermissions::LCD_CREATE = \"lcd_create\";\nconst String ModulePermissions::LCD_UPDATE = \"lcd_update\";\nconst String ModulePermissions::LCD_DELETE = \"lcd_delete\";\nconst String ModulePermissions::LCD_GET = \"lcd_get\";\nconst String ModulePermissions::DHT_CREATE = \"dht_create\";\nconst String ModulePermissions::DHT_UPDATE = \"dht_update\";\nconst String ModulePermissions::DHT_DELETE = \"dht_delete\";\nconst String ModulePermissions::DHT_GET = \"dht_get\";\nconst String ModulePermissions::PHOTORESISTOR_CREATE = \"photoresistor_create\";\nconst String ModulePermissions::PHOTORESISTOR_UPDATE = \"photoresistor_update\";\nconst String ModulePermissions::PHOTORESISTOR_DELETE = \"photoresistor_delete\";\nconst String ModulePermissions::PHOTORESISTOR_GET = \"photoresistor_get\";\nconst String ModulePermissions::RGB_CREATE = \"rgb_create\";\nconst String ModulePermissions::RGB_UPDATE = \"rgb_update\";\nconst String ModulePermissions::RGB_DELETE = \"rgb_delete\";\nconst String ModulePermissions::RGB_GET = \"rgb_get\";\nconst String ModulePermissions::SOILMOISTURE_CREATE = \"soilmoisture_create\";\nconst String ModulePermissions::SOILMOISTURE_UPDATE = \"soilmoisture_update\";\nconst String ModulePermissions::SOILMOISTURE_DELETE = \"soilmoisture_delete\";\nconst String ModulePermissions::SOILMOISTURE_GET = \"soilmoisture_get\";\n\n\n#endif // PERMISSIONS_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Modules\\PhotoresistorApis.h",
        "content": "#ifndef PHOTORESISTORAPIS_h\n#define PHOTORESISTORAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Modules/PhotoresistorController.h\"\n#include \"ModulePermissions.h\"\n\nclass PhotoresistorApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    PhotoresistorController* photoresistorController;\n    std::string class_path = \"/photoresistor\";\n\npublic:\n    PhotoresistorApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(int LowTreshold, int HighTreshold);\n    String handleupdate(int id, int LowTreshold, int HighTreshold);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nPhotoresistorApis::PhotoresistorApis(Context* cntxt, bool add_apis): context(cntxt) {\n    photoresistorController = new PhotoresistorController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::PHOTORESISTOR_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"LowTreshold\") || !req->getParams()->isQueryParameterSet(\"HighTreshold\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        int LowTreshold = getQueryParameterint(req, \"LowTreshold\");\n    int HighTreshold = getQueryParameterint(req, \"HighTreshold\");\n\n        response(res, handlecreate(LowTreshold, HighTreshold));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::PHOTORESISTOR_UPDATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"LowTreshold\") || !req->getParams()->isQueryParameterSet(\"HighTreshold\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        int LowTreshold = getQueryParameterint(req, \"LowTreshold\");\n    int HighTreshold = getQueryParameterint(req, \"HighTreshold\");\n        \n        response(res, handleupdate(id, LowTreshold, HighTreshold));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::PHOTORESISTOR_DELETE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handledelete(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::PHOTORESISTOR_GET) == AuthorizationResults::SUCCESFULL){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::PHOTORESISTOR_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handlegetById(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::PHOTORESISTOR_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        String query = getQueryParameterString(req, \"query\");\n        \n        response(res, handleget(query));\n    }));\n}\n\nString PhotoresistorApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString PhotoresistorApis::handlecreate(int LowTreshold, int HighTreshold) {\n    PhotoresistorEntity* photoresistorEntity = new PhotoresistorEntity(LowTreshold, HighTreshold);\n    int id = photoresistorController->Add(*photoresistorEntity);\n    if (id != -1)\n    {\n        return CREATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString PhotoresistorApis::handleupdate(int id, int LowTreshold, int HighTreshold) {\n    PhotoresistorEntity* photoresistorEntity = new PhotoresistorEntity(id, LowTreshold, HighTreshold);\n    \n    if (photoresistorController->Update(*photoresistorEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString PhotoresistorApis::handledelete(int id) {\n    \n    if (photoresistorController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString PhotoresistorApis::handlegetAll() {\n    return photoresistorController->GetAllJson();\n}\nString PhotoresistorApis::handlegetById(int id) {\n    return photoresistorController->GetById(id).toJson();\n}\nString PhotoresistorApis::handleget(String query) {\n    return photoresistorController->GetJson(query);\n}\n\nString PhotoresistorApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"LowTreshold\"].toInt(), parameters[\"HighTreshold\"].toInt());\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"LowTreshold\"].toInt(), parameters[\"HighTreshold\"].toInt());\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //PHOTORESISTORApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Modules\\RelayApis.h",
        "content": "#ifndef RELAYAPIS_h\n#define RELAYAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Modules/RelayController.h\"\n#include \"ModulePermissions.h\"\n\nclass RelayApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    RelayController* relayController;\n    std::string class_path = \"/relay\";\n\npublic:\n    RelayApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(int ModuleId, bool NormallyOpen);\n    String handleupdate(int id, int ModuleId, bool NormallyOpen);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nRelayApis::RelayApis(Context* cntxt, bool add_apis): context(cntxt) {\n    relayController = new RelayController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::RELAY_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"ModuleId\") || !req->getParams()->isQueryParameterSet(\"NormallyOpen\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        int ModuleId = getQueryParameterint(req, \"ModuleId\");\n    bool NormallyOpen = boolean(getQueryParameterString(req, \"NormallyOpen\"));\n\n        response(res, handlecreate(ModuleId, NormallyOpen));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::RELAY_UPDATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"ModuleId\") || !req->getParams()->isQueryParameterSet(\"NormallyOpen\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        int ModuleId = getQueryParameterint(req, \"ModuleId\");\n    bool NormallyOpen = boolean(getQueryParameterString(req, \"NormallyOpen\"));\n        \n        response(res, handleupdate(id, ModuleId, NormallyOpen));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::RELAY_DELETE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handledelete(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::RELAY_GET) == AuthorizationResults::SUCCESFULL){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::RELAY_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handlegetById(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::RELAY_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        String query = getQueryParameterString(req, \"query\");\n        \n        response(res, handleget(query));\n    }));\n}\n\nString RelayApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString RelayApis::handlecreate(int ModuleId, bool NormallyOpen) {\n    RelayEntity* relayEntity = new RelayEntity(ModuleId, NormallyOpen);\n    int id = relayController->Add(*relayEntity);\n    if (id != -1)\n    {\n        return CREATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString RelayApis::handleupdate(int id, int ModuleId, bool NormallyOpen) {\n    RelayEntity* relayEntity = new RelayEntity(id, ModuleId, NormallyOpen);\n    \n    if (relayController->Update(*relayEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString RelayApis::handledelete(int id) {\n    \n    if (relayController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString RelayApis::handlegetAll() {\n    return relayController->GetAllJson();\n}\nString RelayApis::handlegetById(int id) {\n    return relayController->GetById(id).toJson();\n}\nString RelayApis::handleget(String query) {\n    return relayController->GetJson(query);\n}\n\nString RelayApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"ModuleId\"].toInt(), parameters[\"NormallyOpen\"].toInt());\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"ModuleId\"].toInt(), parameters[\"NormallyOpen\"].toInt());\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //RELAYApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Modules\\RGBApis.h",
        "content": "#ifndef RGBAPIS_h\n#define RGBAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Modules/RGBController.h\"\n#include \"ModulePermissions.h\"\n\nclass RGBApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    RGBController* rgbController;\n    std::string class_path = \"/rgb\";\n\npublic:\n    RGBApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(String Type, int Rpin, int Gpin, int Bpin);\n    String handleupdate(int id, String Type, int Rpin, int Gpin, int Bpin);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nRGBApis::RGBApis(Context* cntxt, bool add_apis): context(cntxt) {\n    rgbController = new RGBController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::RGB_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"Type\") || !req->getParams()->isQueryParameterSet(\"Rpin\") || !req->getParams()->isQueryParameterSet(\"Gpin\") || !req->getParams()->isQueryParameterSet(\"Bpin\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        String Type = getQueryParameterString(req, \"Type\");\n    int Rpin = getQueryParameterint(req, \"Rpin\");\n    int Gpin = getQueryParameterint(req, \"Gpin\");\n    int Bpin = getQueryParameterint(req, \"Bpin\");\n\n        response(res, handlecreate(Type, Rpin, Gpin, Bpin));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::RGB_UPDATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"Type\") || !req->getParams()->isQueryParameterSet(\"Rpin\") || !req->getParams()->isQueryParameterSet(\"Gpin\") || !req->getParams()->isQueryParameterSet(\"Bpin\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        String Type = getQueryParameterString(req, \"Type\");\n    int Rpin = getQueryParameterint(req, \"Rpin\");\n    int Gpin = getQueryParameterint(req, \"Gpin\");\n    int Bpin = getQueryParameterint(req, \"Bpin\");\n        \n        response(res, handleupdate(id, Type, Rpin, Gpin, Bpin));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::RGB_DELETE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handledelete(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::RGB_GET) == AuthorizationResults::SUCCESFULL){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::RGB_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handlegetById(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::RGB_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        String query = getQueryParameterString(req, \"query\");\n        \n        response(res, handleget(query));\n    }));\n}\n\nString RGBApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString RGBApis::handlecreate(String Type, int Rpin, int Gpin, int Bpin) {\n    RGBEntity* rgbEntity = new RGBEntity(Type, Rpin, Gpin, Bpin);\n    int id = rgbController->Add(*rgbEntity);\n    if (id != -1)\n    {\n        return CREATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString RGBApis::handleupdate(int id, String Type, int Rpin, int Gpin, int Bpin) {\n    RGBEntity* rgbEntity = new RGBEntity(id, Type, Rpin, Gpin, Bpin);\n    \n    if (rgbController->Update(*rgbEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString RGBApis::handledelete(int id) {\n    \n    if (rgbController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString RGBApis::handlegetAll() {\n    return rgbController->GetAllJson();\n}\nString RGBApis::handlegetById(int id) {\n    return rgbController->GetById(id).toJson();\n}\nString RGBApis::handleget(String query) {\n    return rgbController->GetJson(query);\n}\n\nString RGBApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"Type\"], parameters[\"Rpin\"].toInt(), parameters[\"Gpin\"].toInt(), parameters[\"Bpin\"].toInt());\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"Type\"], parameters[\"Rpin\"].toInt(), parameters[\"Gpin\"].toInt(), parameters[\"Bpin\"].toInt());\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //RGBApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\apis\\Modules\\SoilMoistureApis.h",
        "content": "#ifndef SOILMOISTUREAPIS_h\n#define SOILMOISTUREAPIS_h\n\n#include \"../../../Context.h\"\n#include \"../../../Database/Controllers/Modules/SoilMoistureController.h\"\n#include \"ModulePermissions.h\"\n\nclass SoilMoistureApis : public ApiInterface\n{\nprivate:\n    Context* context;\n    SoilMoistureController* soilmoistureController;\n    std::string class_path = \"/soilmoisture\";\n\npublic:\n    SoilMoistureApis(Context* cntxt, bool add_apis);\n    String getClassPath() override;\n\n    String callFunction(String functionName, std::map<String, String> parameters) override;\n    \n    String handlecreate(int DryTreshold, int WetTreshold, String Type);\n    String handleupdate(int id, int DryTreshold, int WetTreshold, String Type);\n    String handledelete(int id);\n    String handlegetAll();\n    String handlegetById(int id);\n    String handleget(String query);\n};\n\nSoilMoistureApis::SoilMoistureApis(Context* cntxt, bool add_apis): context(cntxt) {\n    soilmoistureController = new SoilMoistureController(context, storageType);\n\n    if (!add_apis) return;    \n\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/create\"), LambdaResourceNode::REQUEST_METHOD_POST, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::SOILMOISTURE_CREATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"DryTreshold\") || !req->getParams()->isQueryParameterSet(\"WetTreshold\") || !req->getParams()->isQueryParameterSet(\"Type\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        int DryTreshold = getQueryParameterint(req, \"DryTreshold\");\n    int WetTreshold = getQueryParameterint(req, \"WetTreshold\");\n    String Type = getQueryParameterString(req, \"Type\");\n\n        response(res, handlecreate(DryTreshold, WetTreshold, Type));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/update\"), LambdaResourceNode::REQUEST_METHOD_PUT, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::SOILMOISTURE_UPDATE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\") || !req->getParams()->isQueryParameterSet(\"DryTreshold\") || !req->getParams()->isQueryParameterSet(\"WetTreshold\") || !req->getParams()->isQueryParameterSet(\"Type\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        int DryTreshold = getQueryParameterint(req, \"DryTreshold\");\n    int WetTreshold = getQueryParameterint(req, \"WetTreshold\");\n    String Type = getQueryParameterString(req, \"Type\");\n        \n        response(res, handleupdate(id, DryTreshold, WetTreshold, Type));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/delete\"), LambdaResourceNode::REQUEST_METHOD_DELETE, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::SOILMOISTURE_DELETE) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n        \n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handledelete(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getAll\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::SOILMOISTURE_GET) == AuthorizationResults::SUCCESFULL){return;}\n        response(res, handlegetAll());\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/getById\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::SOILMOISTURE_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"id\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        int id = getQueryParameterint(req, \"id\");\n        \n        response(res, handlegetById(id));\n    }));\n    context->getNetwork()->addApi(new ResourceNode(std::string(class_path + \"/get\"), LambdaResourceNode::REQUEST_METHOD_GET, [&](HTTPRequest * req, HTTPResponse * res) {\n        if (!context->getSecurity()->checkAuthentication(req, res, ModulePermissions::SOILMOISTURE_GET) == AuthorizationResults::SUCCESFULL){return;}\n        if (!req->getParams()->isQueryParameterSet(\"query\"))\n        {\n            response(res, 400, MISSING_INPUT_PARAMS_MESSAGE);\n            return;\n        }\n\n        String query = getQueryParameterString(req, \"query\");\n        \n        response(res, handleget(query));\n    }));\n}\n\nString SoilMoistureApis::getClassPath()\n{\n    return String(class_path.c_str());\n}\n\nString SoilMoistureApis::handlecreate(int DryTreshold, int WetTreshold, String Type) {\n    SoilMoistureEntity* soilmoistureEntity = new SoilMoistureEntity(DryTreshold, WetTreshold, Type);\n    int id = soilmoistureController->Add(*soilmoistureEntity);\n    if (id != -1)\n    {\n        return CREATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return CREATE_FAILED_MESSAGE;\n}\nString SoilMoistureApis::handleupdate(int id, int DryTreshold, int WetTreshold, String Type) {\n    SoilMoistureEntity* soilmoistureEntity = new SoilMoistureEntity(id, DryTreshold, WetTreshold, Type);\n    \n    if (soilmoistureController->Update(*soilmoistureEntity))\n    {\n        return UPDATE_SUCCESFULL_MESSAGE;\n    }\n    \n    return UPDATE_FAILED_MESSAGE;\n}\nString SoilMoistureApis::handledelete(int id) {\n    \n    if (soilmoistureController->Delete(id))\n    {\n        return DELETE_SUCCESFULL_MESSAGE;\n    }\n    \n    return DELETE_FAILED_MESSAGE;\n}\nString SoilMoistureApis::handlegetAll() {\n    return soilmoistureController->GetAllJson();\n}\nString SoilMoistureApis::handlegetById(int id) {\n    return soilmoistureController->GetById(id).toJson();\n}\nString SoilMoistureApis::handleget(String query) {\n    return soilmoistureController->GetJson(query);\n}\n\nString SoilMoistureApis::callFunction(String functionName, std::map<String, String> parameters) {\n    \n    if (functionName == \"handlecreate\") {\n        return handlecreate(parameters[\"DryTreshold\"].toInt(), parameters[\"WetTreshold\"].toInt(), parameters[\"Type\"]);\n    }\n    if (functionName == \"handleupdate\") {\n        return handleupdate(parameters[\"id\"].toInt(), parameters[\"DryTreshold\"].toInt(), parameters[\"WetTreshold\"].toInt(), parameters[\"Type\"]);\n    }\n    if (functionName == \"handledelete\") {\n        return handledelete(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handlegetAll\") {\n        return handlegetAll();\n    }\n    if (functionName == \"handlegetById\") {\n        return handlegetById(parameters[\"id\"].toInt());\n    }\n    if (functionName == \"handleget\") {\n        return handleget(parameters[\"query\"]);\n    }\n    return String(NO_FUNCTION_MESSAGE + functionName);\n}\n\n#endif //SOILMOISTUREApis_h\n\n    "
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\MeshNetwork\\IMeshNetworkManager.h",
        "content": "#ifndef IMESHNETWORKMANAGER_H\n#define IMESHNETWORKMANAGER_H\n#include \"Message.h\"\n#include \"Receive.h\"\n// #include \"painlessMesh.h\"\n\ntypedef std::function<void(Message)> ResponseCallback;\nclass IMeshNetworkManager\n{\npublic:\n    // virtual painlessMesh* getMesh() = 0;\n    virtual Receive* getReceive() = 0;\n    virtual void setReceive(Receive* receive) = 0;\n    virtual void initialize() = 0;\n    virtual void loop() = 0;\n    // virtual void broadcastMessage(Message message, ResponseCallback callback) = 0;\n    virtual void setResponseMessage(Message response) = 0;\n    virtual Message* getResponseMessage() = 0;\n};\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\MeshNetwork\\MeshNetworkManager.h",
        "content": "#ifndef MESHNETWORKMANAGER_H\n#define MESHNETWORKMANAGER_H\n\n// #include \"painlessMesh.h\"\n#include \"../../Context.h\"\n#include \"../../Config/System/SystemConfigKeys.h\"\n#include \"Message.h\"\n#include \"Receive.h\"\n#include \"IMeshNetworkManager.h\"\nclass MeshNetworkManager : public IMeshNetworkManager\n{\nprivate:\n    const char*   MESH_PREFIX = \"whateverYouLike\";\n    const char*   MESH_PASSWORD = \"somethingSneaky\";\n    const uint16_t   MESH_PORT =  5555;\n    const char* HOSTNAME = \"HTTP_BRIDGE\";\n    Context context;\n    int32_t start_millis;\n    bool initialized;\n    Message responseMessage;\n    // typedef void (*ResponseCallback)(Message);\n    // ResponseCallback responseCallback;\n    // painlessMesh mesh;\n    Receive receive;\npublic:\n    // static MeshNetworkManager* MeshManagerinstance;  // Static pointer to the class MeshManagerinstance\n\n    MeshNetworkManager(Context &context);\n    void initialize() override;\n    static void receivedCallback(const uint32_t &from, const String &msg );\n    void loop() override;\n    // void broadcastMessage(Message message, ResponseCallback callback) override;\n    void setResponseMessage(Message response) override;\n    Message* getResponseMessage() override;\n    // painlessMesh* getMesh() override;\n    Receive* getReceive() override;\n    void setReceive(Receive* receive) override;\n};\n\n// MeshNetworkManager* MeshNetworkManager::MeshManagerinstance = nullptr;\n\nMeshNetworkManager::MeshNetworkManager(Context &context): context(context)\n{\n    // MeshManagerinstance = this;  // Set the static pointer to this MeshManagerinstance\n    initialized = false;\n}\nvoid MeshNetworkManager::initialize()\n{\n    // mesh.setDebugMsgTypes( ERROR | STARTUP | CONNECTION );\n    // mesh.init( MESH_PREFIX, MESH_PASSWORD, MESH_PORT );\n    // mesh.onReceive(&receivedCallback);\n    // mesh.setHostname(HOSTNAME);\n\n    // String meshRootStr = context.getConfig()->get(SystemConfigKey::MESH_ROOT);\n    // bool meshRoot = (meshRootStr == \"true\");\n    // mesh.setRoot(meshRoot);\n    // mesh.setContainsRoot(true);\n    // start_millis = millis();\n    // initialized = true;\n}\n\nvoid MeshNetworkManager::receivedCallback(const uint32_t &from, const String &msg ) {\n    // Message message;\n    // message.fromString(msg);\n    // painlessMesh& mesh = MeshManagerinstance->mesh;  // Use the static pointer to access the mesh\n    // Receive& receive = MeshManagerinstance->receive;  // Use the static pointer to access the receive\n    // if (message.nodeId == mesh.getNodeId() || message.nodeId == 0)\n    // {\n    //     if(message.responseMessage.length() > 0)\n    //     {\n    //         MeshManagerinstance->setResponseMessage(message);\n    //         if (MeshManagerinstance->responseCallback) {\n    //             MeshManagerinstance->responseCallback(message);  // Call the callback with the response\n    //         }\n    //         return;\n    //     }        \n    //     Message responseMessage;\n    //     responseMessage.responseMessage = receive.receiveMessage(msg);\n    //     MeshManagerinstance->broadcastMessage(responseMessage, nullptr);\n    // }\n\n    // Serial.printf(\"bridge: Received from %u msg=%s\\n\", from, msg.c_str());\n}\n\nvoid MeshNetworkManager::setResponseMessage(Message response)\n{\n    responseMessage = response;\n}\n\nMessage* MeshNetworkManager::getResponseMessage()\n{\n    Message rm = responseMessage;\n    responseMessage.responseMessage = \"\";\n    return &rm;\n}\n\nvoid MeshNetworkManager::loop()\n{\n\n    // if (context.getConfig()->get(SystemConfigKey::WIFI_MODE_MESH) != \"true\")\n    // {\n    //     return;\n    // }\n    // if (!initialized)\n    // {\n    //     context.getErrorHandler()->handleError(\"MeshNetwork is not initialized\");\n    //     return;\n    // }\n    \n    // // mesh.update();\n    // if (millis() - start_millis > 5000)\n    // {\n    // start_millis = millis();\n    // Serial.print(\"My AP IP is \");\n    // Serial.print(IPAddress(mesh.getAPIP()).toString());\n    // Serial.print(\" and Station IP is \");\n    // Serial.println(IPAddress(mesh.getStationIP()).toString());\n    // }\n\n}\n\n// void MeshNetworkManager::broadcastMessage(Message message, ResponseCallback callback) {\n//     String messageString = message.toString();\n//     mesh.sendBroadcast(messageString);\n//     responseCallback = callback;  // Save the callback for later\n// }\n\n// painlessMesh* MeshNetworkManager::getMesh()\n// {\n//     return &mesh;\n// }\n\nReceive* MeshNetworkManager::getReceive()\n{\n    return &receive;\n}\n\nvoid MeshNetworkManager::setReceive(Receive* receive)\n{\n    receive = receive;\n}\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\MeshNetwork\\Message.h",
        "content": "#ifndef MESSAGE_H\n#define MESSAGE_H\n// Message.h\n#include <Arduino.h>\n#include <map>\n\nclass Message {\npublic:\n    uint32_t nodeId;\n    String className;\n    String functionName;\n    std::map<String, String> parameters;\n    String responseMessage;\n\n    String toString() {\n        if (responseMessage.length() > 0)\n        {\n            String queryString = nodeId + \"/response=\" + responseMessage;\n            return queryString;\n        }\n        \n        String queryString = nodeId + \"/\" + className + \"/\" + functionName + \"?\";\n        for (auto const& pair : parameters) {\n            queryString += pair.first + \"=\" + pair.second + \"&\";\n        }\n        // Remove the last \"&\"\n        queryString = queryString.substring(0, queryString.length() - 1);\n        return queryString;\n    }\n\n    void fromString(String queryString) {\n        int firstSlash = queryString.indexOf('/');\n        int responseStart = queryString.indexOf(\"response=\", firstSlash + 1);\n        if (responseStart != -1)\n        {\n            responseMessage = queryString.substring(responseStart + 9);\n            return;\n        }\n        \n        int secondSlash = queryString.indexOf('/', firstSlash + 1);\n        int questionMark = queryString.indexOf('?');\n\n        nodeId = queryString.substring(0, firstSlash).toInt();\n        className = queryString.substring(firstSlash + 1, secondSlash);\n        functionName = queryString.substring(secondSlash + 1, questionMark);\n\n        String parametersString = queryString.substring(questionMark + 1);\n        int nextAmpersand;\n        do {\n            nextAmpersand = parametersString.indexOf('&');\n            String parameterPair = parametersString.substring(0, nextAmpersand);\n            int equalsSign = parameterPair.indexOf('=');\n            String parameterName = parameterPair.substring(0, equalsSign);\n            String parameterValue = parameterPair.substring(equalsSign + 1);\n            parameters[parameterName] = parameterValue;\n            parametersString = parametersString.substring(nextAmpersand + 1);\n        } while (nextAmpersand != -1);\n    }\n};\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\MeshNetwork\\Receive.h",
        "content": "#ifndef RECEIVE_H\n#define RECEIVE_H\n// Receive.h\n#include <map>\n#include \"Message.h\"\n#include \"../apis/ApiInterface.h\"\n\nclass Receive {\nprivate:\n    std::map<String, ApiInterface*> classes;\n\npublic:\n    void registerClass(String className, ApiInterface* classInstance) {\n        classes[className] = classInstance;\n    }\n\n    String receiveMessage(String messageString) {\n        Message message;\n        message.fromString(messageString);\n\n        if (classes.count(message.className) > 0) {\n            // The class exists\n            ApiInterface* classInstance = classes[message.className];\n            return classInstance->callFunction(message.functionName, message.parameters);\n        } else {\n            // The class doesn't exist\n            return \"Error: The class doesn't exist\";\n        }\n    }\n};\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\WiFi\\IWiFiManager.h",
        "content": "#ifndef IWiFiManager_h\n#define IWiFiManager_h\n\n// \n#if defined(ESP8266)\n#include <ESP8266WiFi.h>\n#else\n#include <WiFi.h>\n#endif\n\n#include <ArduinoJson.h>\n#include <vector>\n#include \"../../Database/Entities/WiFiEntity.h\"\n\nstruct SSIDInfo {\n  String SSID;               // wifi SSID\n  String WiFiPassword;       // wifi password\n  int WebServerPortHttp;     // http port number for web admin\n  int WiFiStrength;          // wifi strength \n  bool isSaved;\n};\n\nclass IWiFiManager\n{\n  public:\n    virtual void WiFiConnect() = 0;\n    virtual void AddSSID(String SSID, String password) = 0;\n    virtual void RemoveSSID(String SSID) = 0;\n    virtual void GetAvailableSSIDs(std::vector<SSIDInfo> &SSIDInfos) = 0;\n    virtual void loop() = 0;\n    virtual void configWifiMode() = 0;\n    virtual void displayNetworkInfo() = 0;\n    virtual void configureAccessPointMode() = 0;\n    virtual void configureStationMode() = 0;\n    virtual void connectToAvailableNetwork(std::vector<WiFiEntity>& wifiEntities) = 0;\n    virtual void connectToNetwork(WiFiEntity& wifiEntity) = 0;\n    virtual void waitForConnection() = 0;\n    virtual String getConnectedWifi() = 0;\n};\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\NetworkManager\\WiFi\\WiFiManager.h",
        "content": "#ifndef WiFiManager_h\n#define WiFiManager_h\n\n\n#include \"../../context.h\"\n#include \"../../Config/System/SystemConfigKeys.h\"\n#include \"../../Database/Controllers/WiFiConroller.h\"\n#include \"IWiFiManager.h\"\n\nclass WiFiManager : public IWiFiManager\n{\nprivate:\n    uint8_t BUILTIN_LED_PIN = 2;\n    const String WIFI_FILE = \"/WiFi.db\";\n    String DEFAULT_AP = \"ESPBoilerplate\";\n    String DEFAULT_PASSWORD = \"12345678\";\n    void blinkLED(int times, int delayMs);\n\npublic:\n    WiFiManager(Context*context);\n    void WiFiConnect() override;\n    void AddSSID(String SSID, String password) override;\n    void RemoveSSID(String SSID) override;\n    void GetAvailableSSIDs(std::vector<SSIDInfo> &SSIDInfos) override;\n    void loop() override;\n    void configWifiMode() override;\n    void displayNetworkInfo() override;\n    void configureAccessPointMode() override;\n    void configureStationMode() override;\n    void connectToAvailableNetwork(std::vector<WiFiEntity>& wifiEntities) override;\n    void connectToNetwork(WiFiEntity& wifiEntity) override;\n    void waitForConnection() override;\n    String getConnectedWifi() override;\n\n    const int default_WebServerPortHttp = 80;\n    Context* context;\n};\n\nWiFiManager::WiFiManager(Context*cntxt)\n{\n  context = cntxt;\n  pinMode(BUILTIN_LED_PIN, OUTPUT);\n}\n\nvoid WiFiManager::loop()\n{\n\n}\n\nvoid WiFiManager::WiFiConnect() \n{\n  configWifiMode();\n  displayNetworkInfo();\n}\n\nvoid WiFiManager::configWifiMode()\n{\n\n}\n\nvoid WiFiManager::configureAccessPointMode()\n{\n    Serial.println(\"here: 0311\");\n  // WiFi.mode(WIFI_STA);\n    Serial.println(context->getConfig()->getSystemConfig()->get(SystemConfigKey::AP_SSID).c_str());\n    Serial.println(context->getConfig()->getSystemConfig()->get(SystemConfigKey::AP_PASSWORD).c_str());\n    Serial.println(context->getConfig()->getSystemConfig()->get(SystemConfigKey::CHANNEL).toInt());\n    Serial.println(context->getConfig()->getSystemConfig()->get(SystemConfigKey::SSID_HIDDEN).toInt());\n    Serial.println(context->getConfig()->getSystemConfig()->get(SystemConfigKey::MAX_CONNECTION).toInt());\n\n  WiFi.softAP(context->getConfig()->getSystemConfig()->get(SystemConfigKey::AP_SSID).c_str(),\n              context->getConfig()->getSystemConfig()->get(SystemConfigKey::AP_PASSWORD).c_str(), \n              context->getConfig()->getSystemConfig()->get(SystemConfigKey::CHANNEL).toInt(), \n              context->getConfig()->getSystemConfig()->get(SystemConfigKey::SSID_HIDDEN).toInt(), \n              context->getConfig()->getSystemConfig()->get(SystemConfigKey::MAX_CONNECTION).toInt());\n    \n    Serial.println(\"here I got Erorr and reset : Brownout detector was triggered\");\n  \n  Serial.println(\"\\n\\nAccess Point Information ...\");\n  Serial.println(\"----------------------\");\n  Serial.print(\"      AP SSID: \\\"\"); Serial.print(WiFi.softAPSSID()); Serial.println(\"\\\"\");\n  Serial.print(\"      AP IP: \\\"\"); Serial.print(WiFi.softAPIP()); Serial.println(\"\\\"\");\n}\n\nvoid WiFiManager::configureStationMode()\n{\n  WiFiController* wiFiController = new WiFiController(context, storageType);\n  std::vector<WiFiEntity> wifiEntities = wiFiController->GetAll();\n  if (wifiEntities.size() > 0)\n  {\n    connectToAvailableNetwork(wifiEntities);\n  }\n}\n\nvoid WiFiManager::connectToAvailableNetwork(std::vector<WiFiEntity>& wifiEntities)\n{\n  int n = WiFi.scanNetworks();\n  if (n == 0) \n  {\n    Serial.println(\"No Networks Found to Connect\");\n  } \n  else \n  {\n    for (int i = 0; i < n; ++i) \n    {\n      for (size_t j = 0; j < wifiEntities.size(); j++)\n      {\n        if(WiFi.SSID(i) == wifiEntities.at(j).getSSID())\n        {\n          connectToNetwork(wifiEntities.at(j));\n          return;\n        }\n      }\n    }\n    Serial.println(\"No Netowrk found in List.\");\n  } \n}\n\nvoid WiFiManager::connectToNetwork(WiFiEntity& wifiEntity)\n{\n  SSIDInfo ssidInfo;\n  ssidInfo.SSID = wifiEntity.getSSID();\n  ssidInfo.WiFiPassword = wifiEntity.getPassword();\n  ssidInfo.WebServerPortHttp = default_WebServerPortHttp;\n\n  Serial.print(\"\\nConnecting to Wifi \");\n  Serial.print(ssidInfo.SSID);\n  Serial.print(\" : \");\n  \n  WiFi.begin(ssidInfo.SSID.c_str(), ssidInfo.WiFiPassword.c_str());\n  \n  waitForConnection();\n  \n  WiFi.setSleep(false);\n  \n  Serial.println(\"\\n\\nNetwork SSID Infourmation:\");\n  Serial.println(\"----------------------\");\n  Serial.print(\"         SSID: \"); Serial.println(WiFi.SSID());\n  Serial.print(\"Wifi Strength: \"); Serial.print(WiFi.RSSI()); Serial.println(\" dBm\");\n\n  blinkLED(10, 100);\n  digitalWrite(BUILTIN_LED_PIN, LOW);\n}\n\nvoid WiFiManager::waitForConnection()\n{\n  int start_millis = millis();\n  bool led_on = false;\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(400);\n    // digitalWrite(BUILTIN_LED_PIN, led_on ? HIGH : LOW);\n    led_on = !led_on;\n    Serial.print(\".\");\n\n    if (millis() - start_millis > 120000)\n    {\n      context->getConfig()->getSystemConfig()->set(SystemConfigKey::WIFI_MODE_AP, \"true\");\n      context->getConfig()->getSystemConfig()->set(SystemConfigKey::WIFI_MODE_WIFI, \"false\");\n      #if defined(ESP32)\n      ESP.restart();\n      #endif\n    }\n  }\n}\n\nvoid WiFiManager::blinkLED(int times, int delayMs)\n{\n  bool led_on = false;\n  for(int i = 0; i < times; i++)\n  {\n    digitalWrite(BUILTIN_LED_PIN, led_on ? HIGH : LOW);\n    led_on = !led_on;\n    delay(delayMs);\n  }\n}\n\nvoid WiFiManager::displayNetworkInfo()\n{\n  Serial.print(\" Wifi Status: \"); Serial.println(WiFi.status());\n  Serial.print(\" MAC: \"); Serial.println(WiFi.macAddress());\n  Serial.print(\" IP: \"); Serial.println(WiFi.localIP());\n  Serial.print(\" Subnet: \"); Serial.println(WiFi.subnetMask());\n  Serial.print(\" Gateway: \"); Serial.println(WiFi.gatewayIP());\n  Serial.print(\" DNS 1: \"); Serial.println(WiFi.dnsIP(0));\n  Serial.print(\" DNS 2: \"); Serial.println(WiFi.dnsIP(1));\n  Serial.print(\" DNS 3: \"); Serial.println(WiFi.dnsIP(2));\n  Serial.println(\"\\nConfiguring Webserver ...\");\n}\n\nvoid WiFiManager::AddSSID(String SSID, String password)\n{\n  WiFiController* wiFiController = new WiFiController(context, storageType);\n  WiFiEntity* wifiEntity = new WiFiEntity(SSID, password);\n  wiFiController->Add(*wifiEntity);\n}\n\nvoid WiFiManager::RemoveSSID(String SSID)\n{\n  WiFiController* wiFiController = new WiFiController(context, storageType);\n  std::vector<WiFiEntity> wifiEntities = wiFiController->Get(WiFiEntity::COLUMN_SSID + \" = \" + SSID);\n  if (wifiEntities.size() > 0)\n  {\n    WiFiEntity wifiEntity = wifiEntities.at(0);\n    wiFiController->Delete(wifiEntity.id);\n  }\n  \n}\n\nvoid WiFiManager::GetAvailableSSIDs(std::vector<SSIDInfo> &SSIDInfos)\n{\n  int n = WiFi.scanNetworks();\n  WiFiController* wiFiController = new WiFiController(context, storageType);\n  std::vector<WiFiEntity> wifiEntities = wiFiController->GetAll();\n  if (n == 0) \n  {\n    Serial.println(\"No Networks Found to Connect\");\n  } \n  else \n  {\n    for (int i = 0; i < n; ++i) \n    {\n      SSIDInfo SSIDInfo;\n      SSIDInfo.SSID = WiFi.SSID(i);\n      SSIDInfo.WiFiStrength = WiFi.RSSI(i);\n      SSIDInfo.isSaved = false;\n\n      for (size_t j = 0; j < wifiEntities.size(); j++)\n      {\n        if(WiFi.SSID(i) == wifiEntities.at(j).getSSID())\n        {\n          SSIDInfo.isSaved = true;\n        }\n      }        \n      SSIDInfos.push_back(SSIDInfo); \n    }\n    Serial.println(\"No Netowrk found in List.\");\n  }\n}\n\nString WiFiManager::getConnectedWifi()\n{\n  return WiFi.SSID();\n}\n#endif"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Security\\AuthorizationPermissions.h",
        "content": "#ifndef AUTHORIZATIONPERMISSIONS_H\n#define AUTHORIZATIONPERMISSIONS_H\n\nclass AuthorizationPermissions\n{\npublic:\n    static const String USER_CREATE;\n    static const String USER_UPDATE;\n    static const String USER_DELETE;\n    static const String USER_GET;\n    static const String ROLE_CREATE;\n    static const String ROLE_UPDATE;\n    static const String ROLE_DELETE;\n    static const String ROLE_GET;\n    static const String PERMISSION_CREATE;\n    static const String PERMISSION_UPDATE;\n    static const String PERMISSION_DELETE;\n    static const String PERMISSION_GET;\n    static const String ROLEPERMISSION_CREATE;\n    static const String ROLEPERMISSION_UPDATE;\n    static const String ROLEPERMISSION_DELETE;\n    static const String ROLEPERMISSION_GET;\n    static const String USERRESETPASS_CREATE;\n    static const String USERRESETPASS_UPDATE;\n    static const String USERRESETPASS_DELETE;\n    static const String USERRESETPASS_GET;\n    static const String SECURITYQUESTION_CREATE;\n    static const String SECURITYQUESTION_UPDATE;\n    static const String SECURITYQUESTION_DELETE;\n    static const String SECURITYQUESTION_GET;\n    static const String SECURITYQUESTIONTITLE_CREATE;\n    static const String SECURITYQUESTIONTITLE_UPDATE;\n    static const String SECURITYQUESTIONTITLE_DELETE;\n    static const String SECURITYQUESTIONTITLE_GET;\n    static const String LOGINATTEMPT_CREATE;\n    static const String LOGINATTEMPT_UPDATE;\n    static const String LOGINATTEMPT_DELETE;\n    static const String LOGINATTEMPT_GET;\n    static const String ACCOUNTLOCKOUT_CREATE;\n    static const String ACCOUNTLOCKOUT_UPDATE;\n    static const String ACCOUNTLOCKOUT_DELETE;\n    static const String ACCOUNTLOCKOUT_GET;\n    static const String TWOFACTORAUTH_CREATE;\n    static const String TWOFACTORAUTH_UPDATE;\n    static const String TWOFACTORAUTH_DELETE;\n    static const String TWOFACTORAUTH_GET;\n    static const String ACCOUNTACTIVITYLOG_CREATE;\n    static const String ACCOUNTACTIVITYLOG_UPDATE;\n    static const String ACCOUNTACTIVITYLOG_DELETE;\n    static const String ACCOUNTACTIVITYLOG_GET;\n    static const String AUTHENTICATION_LOGIN;\n    static const String AUTHENTICATION_PASSWORDRESET;\n    static const String AUTHENTICATION_PASSWORDRESETCONFIRM;\n    static const String AUTHENTICATION_TWOFACTORAUTH;\n    static const String AUTHENTICATION_TWOFACTORAUTHCONFIRM;\n    static const String AUTHENTICATION_ACCOUNTLOCK;\n    static const String AUTHENTICATION_ACCOUNTUNLOCK;\n    static const String AUTHENTICATION_SECURITYQUESTIONANSWER;\n    static const String AUTHENTICATION_CONFIG_CREATE;\n    static const String AUTHENTICATION_CONFIG_UPDATE;\n    static const String AUTHENTICATION_CONFIG_SUBMIT;\n    static const String AUTHENTICATION_CONFIG_DELETE;\n    static const String AUTHENTICATION_CONFIG_GET;\n    static const String SYSTEM_CONFIG_CREATE;\n    static const String SYSTEM_CONFIG_UPDATE;\n    static const String SYSTEM_CONFIG_SUBMIT;\n    static const String SYSTEM_CONFIG_DELETE;\n    static const String SYSTEM_CONFIG_GET;\n    static const String TESTREQUESTS_ADDDATA;\n    static const String TESTREQUESTS_GETDATA;\n    static const String TESTREQUESTS_PUBLICREQUEST;\n\n    static const String GetData;\n    static const String AddData;\n};\n\nconst String AuthorizationPermissions::USER_CREATE = \"user_create\";\nconst String AuthorizationPermissions::USER_UPDATE = \"user_update\";\nconst String AuthorizationPermissions::USER_DELETE = \"user_delete\";\nconst String AuthorizationPermissions::USER_GET = \"user_get\";\nconst String AuthorizationPermissions::ROLE_CREATE = \"role_create\";\nconst String AuthorizationPermissions::ROLE_UPDATE = \"role_update\";\nconst String AuthorizationPermissions::ROLE_DELETE = \"role_delete\";\nconst String AuthorizationPermissions::ROLE_GET = \"role_get\";\nconst String AuthorizationPermissions::PERMISSION_CREATE = \"permission_create\";\nconst String AuthorizationPermissions::PERMISSION_UPDATE = \"permission_update\";\nconst String AuthorizationPermissions::PERMISSION_DELETE = \"permission_delete\";\nconst String AuthorizationPermissions::PERMISSION_GET = \"permission_get\";\nconst String AuthorizationPermissions::ROLEPERMISSION_CREATE = \"rolepermission_create\";\nconst String AuthorizationPermissions::ROLEPERMISSION_UPDATE = \"rolepermission_update\";\nconst String AuthorizationPermissions::ROLEPERMISSION_DELETE = \"rolepermission_delete\";\nconst String AuthorizationPermissions::ROLEPERMISSION_GET = \"rolepermission_get\";\nconst String AuthorizationPermissions::USERRESETPASS_CREATE = \"userresetpass_create\";\nconst String AuthorizationPermissions::USERRESETPASS_UPDATE = \"userresetpass_update\";\nconst String AuthorizationPermissions::USERRESETPASS_DELETE = \"userresetpass_delete\";\nconst String AuthorizationPermissions::USERRESETPASS_GET = \"userresetpass_get\";\nconst String AuthorizationPermissions::SECURITYQUESTION_CREATE = \"securityquestion_create\";\nconst String AuthorizationPermissions::SECURITYQUESTION_UPDATE = \"securityquestion_update\";\nconst String AuthorizationPermissions::SECURITYQUESTION_DELETE = \"securityquestion_delete\";\nconst String AuthorizationPermissions::SECURITYQUESTION_GET = \"securityquestion_get\";\nconst String AuthorizationPermissions::SECURITYQUESTIONTITLE_CREATE = \"securityquestiontitle_create\";\nconst String AuthorizationPermissions::SECURITYQUESTIONTITLE_UPDATE = \"securityquestiontitle_update\";\nconst String AuthorizationPermissions::SECURITYQUESTIONTITLE_DELETE = \"securityquestiontitle_delete\";\nconst String AuthorizationPermissions::SECURITYQUESTIONTITLE_GET = \"securityquestiontitle_get\";\nconst String AuthorizationPermissions::LOGINATTEMPT_CREATE = \"loginattempt_create\";\nconst String AuthorizationPermissions::LOGINATTEMPT_UPDATE = \"loginattempt_update\";\nconst String AuthorizationPermissions::LOGINATTEMPT_DELETE = \"loginattempt_delete\";\nconst String AuthorizationPermissions::LOGINATTEMPT_GET = \"loginattempt_get\";\nconst String AuthorizationPermissions::ACCOUNTLOCKOUT_CREATE = \"accountlockout_create\";\nconst String AuthorizationPermissions::ACCOUNTLOCKOUT_UPDATE = \"accountlockout_update\";\nconst String AuthorizationPermissions::ACCOUNTLOCKOUT_DELETE = \"accountlockout_delete\";\nconst String AuthorizationPermissions::ACCOUNTLOCKOUT_GET = \"accountlockout_get\";\nconst String AuthorizationPermissions::TWOFACTORAUTH_CREATE = \"twofactorauth_create\";\nconst String AuthorizationPermissions::TWOFACTORAUTH_UPDATE = \"twofactorauth_update\";\nconst String AuthorizationPermissions::TWOFACTORAUTH_DELETE = \"twofactorauth_delete\";\nconst String AuthorizationPermissions::TWOFACTORAUTH_GET = \"twofactorauth_get\";\nconst String AuthorizationPermissions::ACCOUNTACTIVITYLOG_CREATE = \"accountactivitylog_create\";\nconst String AuthorizationPermissions::ACCOUNTACTIVITYLOG_UPDATE = \"accountactivitylog_update\";\nconst String AuthorizationPermissions::ACCOUNTACTIVITYLOG_DELETE = \"accountactivitylog_delete\";\nconst String AuthorizationPermissions::ACCOUNTACTIVITYLOG_GET = \"accountactivitylog_get\";\nconst String AuthorizationPermissions::AUTHENTICATION_LOGIN = \"authentication_login\";\nconst String AuthorizationPermissions::AUTHENTICATION_PASSWORDRESET = \"authentication_passwordreset\";\nconst String AuthorizationPermissions::AUTHENTICATION_PASSWORDRESETCONFIRM = \"authentication_passwordresetconfirm\";\nconst String AuthorizationPermissions::AUTHENTICATION_TWOFACTORAUTH = \"authentication_twofactorauth\";\nconst String AuthorizationPermissions::AUTHENTICATION_TWOFACTORAUTHCONFIRM = \"authentication_twofactorauthconfirm\";\nconst String AuthorizationPermissions::AUTHENTICATION_ACCOUNTLOCK = \"authentication_accountlock\";\nconst String AuthorizationPermissions::AUTHENTICATION_ACCOUNTUNLOCK = \"authentication_accountunlock\";\nconst String AuthorizationPermissions::AUTHENTICATION_CONFIG_CREATE = \"authentication_config_create\";\nconst String AuthorizationPermissions::AUTHENTICATION_CONFIG_UPDATE = \"authentication_config_update\";\nconst String AuthorizationPermissions::AUTHENTICATION_CONFIG_SUBMIT = \"authentication_config_submit\";\nconst String AuthorizationPermissions::AUTHENTICATION_CONFIG_DELETE = \"authentication_config_delete\";\nconst String AuthorizationPermissions::AUTHENTICATION_CONFIG_GET = \"authentication_config_get\";\nconst String AuthorizationPermissions::SYSTEM_CONFIG_CREATE = \"system_config_create\";\nconst String AuthorizationPermissions::SYSTEM_CONFIG_UPDATE = \"system_config_update\";\nconst String AuthorizationPermissions::SYSTEM_CONFIG_SUBMIT = \"system_config_submit\";\nconst String AuthorizationPermissions::SYSTEM_CONFIG_DELETE = \"system_config_delete\";\nconst String AuthorizationPermissions::SYSTEM_CONFIG_GET = \"system_config_get\";\nconst String AuthorizationPermissions::AUTHENTICATION_SECURITYQUESTIONANSWER = \"authentication_securityquestionanswer\";\nconst String AuthorizationPermissions::TESTREQUESTS_ADDDATA = \"testrequests_adddata\";\nconst String AuthorizationPermissions::TESTREQUESTS_GETDATA = \"testrequests_getdata\";\nconst String AuthorizationPermissions::TESTREQUESTS_PUBLICREQUEST = \"testrequests_publicrequest\";\n\nconst String AuthorizationPermissions::GetData = \"get_data\";\nconst String AuthorizationPermissions::AddData = \"add_data\";\n\n#endif // AUTHORIZATIONPERMISSIONS_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Security\\HMACAuth.h",
        "content": "#ifndef HMACAuth_h\n#define HMACAuth_h\n\n#include \"mbedtls/md.h\"\n#include \"mbedtls/base64.h\"\n\nclass HMACAuth {\npublic:\n    HMACAuth();\n    HMACAuth(const char *key);\n    void updateHash(const char *data);\n    String finalizeHash();\n\nprivate:\n    mbedtls_md_context_t ctx;\n    mbedtls_md_type_t md_type = MBEDTLS_MD_SHA256;\n\n    void initHash(const char *key);\n};\n\n\nHMACAuth::HMACAuth() {\n}\n\nHMACAuth::HMACAuth(const char *key) {\n    initHash(key);\n}\n\nvoid HMACAuth::initHash(const char *key) {\n    const size_t keyLength = strlen(key);\n    mbedtls_md_init(&ctx);\n    mbedtls_md_setup(&ctx, mbedtls_md_info_from_type(md_type), 1);\n    mbedtls_md_hmac_starts(&ctx, (const unsigned char *) key, keyLength);\n}\n\nvoid HMACAuth::updateHash(const char *data) {\n    const size_t dataLength = strlen(data);\n    mbedtls_md_hmac_update(&ctx, (const unsigned char *) data, dataLength);\n}\n\nString HMACAuth::finalizeHash() {\n    byte output_HMAC[32];\n    unsigned char output[65];\n    size_t outlen;\n\n    mbedtls_md_hmac_finish(&ctx, output_HMAC);\n    mbedtls_md_free(&ctx);\n    \n    mbedtls_base64_encode(output, 64, &outlen, (unsigned char *)output_HMAC, sizeof(output_HMAC));\n    output[outlen] = 0;\n    \n    return String((const char*)output);\n}\n#endif\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Security\\ISecurity.h",
        "content": "#ifndef ISECURITY_H\n#define ISECURITY_H\n\n#include \"AuthorizationPermissions.h\"\n#include \"LoginResult.h\"\n#include <HTTPS_Server_Generic.h>\n#include <base64.h>\n#include \"../NetworkManager/apis/ApiInterface.h\"\n\nenum AuthorizationResults{\n    SUCCESFULL,\n    AUTH_HEADER_MISSING,\n    INVALID_AUTHORIZATION_FORMAT,\n    INVALID_TOKEN,\n    USER_NOT_EXISTS,\n    USER_NO_PERMISSION,\n    ERROR\n};\nclass ISecurity {\npublic:\n    virtual void update() = 0;\n    virtual void initialize() = 0;\n    virtual LoginResult login(String username, String password) = 0;\n    virtual LoginResult logout(String username) = 0;\n    virtual bool checkTwoFactorSecurityOtpCode(String username, String otpCode) = 0;\n    virtual bool checkUserPermission(String username, String permission) = 0;\n    virtual LoginResult getUserNameFromToken(String token) = 0;\n    virtual AuthorizationResults checkAuthentication(HTTPRequest * req, HTTPResponse * res, String permission) = 0;\n    virtual void addPermissionForAdmin(String title, String group) = 0;\n};\n\n#endif // ISECURITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Security\\LoginResult.h",
        "content": "#ifndef LOGINRESULT_H\n#define LOGINRESULT_H\n\nenum LoginResults\n{\n    AdminUser,\n    Succesfull,\n    NeedTwoFactorAuthentication,\n    UsernameNotExists,\n    PasswordIsIncorrect,\n    WrongUserNameOrPassword,\n    UserIsLocked,\n    TowManyAttempts,\n    WrongOTPCode,\n    TwoFactorAuthenticationOtpCodeSent,\n    TwoFactorAuthenticationOtpCodeNotSent,\n    LogoutSuccessfull,\n    LogoutUnSuccessfull,\n    TokenNotSaved,\n};\n\nclass LoginResult\n{\nprivate:\n    \npublic:\n    LoginResult();\n    LoginResult(bool succesfull, LoginResults result);\n    ~LoginResult();\n    String getMessage();\n    bool Succesfull;\n    LoginResults Result;\n    String Message;\n\n};\n\nLoginResult::LoginResult()\n{\n\n}\n\nLoginResult::LoginResult(bool succesfull, LoginResults result): Succesfull(succesfull), Result(result), Message(\"\")\n{\n\n}\n\nLoginResult::~LoginResult()\n{\n}\n\nString LoginResult::getMessage()\n{\n    if (Message != \"\")\n    {\n        return Message;\n    }\n    else\n    {\n        switch(Result)\n        {\n            case LoginResults::Succesfull:\n                return \"Login successful.\";\n            case LoginResults::NeedTwoFactorAuthentication:\n                return \"Two-factor authentication required.\";\n            case LoginResults::UsernameNotExists:\n                return \"Username does not exist.\";\n            case LoginResults::PasswordIsIncorrect:\n                return \"Password is incorrect.\";\n            case LoginResults::WrongUserNameOrPassword:\n                return \"Wrong username or password.\";\n            case LoginResults::UserIsLocked:\n                return \"User account is locked.\";\n            case LoginResults::TowManyAttempts:\n                return \"Too many login attempts.\";\n            case LoginResults::WrongOTPCode:\n                return \"OTP code is incorrect.\";\n            case LoginResults::TwoFactorAuthenticationOtpCodeSent:\n                return \"OTP code for two-factor authentication has been sent.\";\n            case LoginResults::TwoFactorAuthenticationOtpCodeNotSent:\n                return \"Failed to send OTP code for two-factor authentication.\";\n            case LoginResults::LogoutSuccessfull:\n                return \"Logout successful.\";\n            case LoginResults::LogoutUnSuccessfull:\n                return \"Logout unsuccessful.\";\n            case LoginResults::TokenNotSaved:\n                return \"Failed to save token.\";\n            default:\n                return \"Unknown result.\";\n        }\n    }\n}\n\n#endif //LOGINRESULT_H"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Security\\Security.h",
        "content": "#ifndef SECURITY_H\n#define SECURITY_H\n\n#include \"ISecurity.h\"\n#include \"../Context.h\"\n#include \"HMACAuth.h\"\n#include \"LoginResult.h\"\n#include \"../Config/Security/DefaultSecurityConfigs.h\"\n#include \"../Config/Security/SecurityConfigKeys.h\"\n#include \"../Database/Controllers/Security/UserController.h\"\n#include \"../Database/Controllers/Security/PermissionController.h\"\n#include \"../Database/Controllers/Security/RolePermissionController.h\"\n#include \"../Database/Controllers/Security/RoleController.h\"\n\nclass Security : public ISecurity {\nprivate:\n    Context* context;\n    LoginResult isLoginAllowed(UserEntity* user, String password);\n    bool sendTwoFactorSecurityOtpCode(String username);\n    LoginResult createUniqueToken(UserEntity* user);\n    void addPermission(int role_id, String title, String group);\n    LoginResult generateJWT(UserEntity user);\n    bool validateJWT(String jwt);\n    int sysAdmin_role_id;\n    int admin_role_id;\n    char *key;\n    HMACAuth auth;\n    const char *pin = \"6577\";\n    const char *timestamp = \"1156\";\n    const char *SECRET_KEY = \"1111111\";\n\n\n\npublic:\n    Security(Context* context);\n    \n    void initialize() override;\n    void update() override;\n    LoginResult login(String username, String password) override;\n    LoginResult logout(String username) override;\n    bool checkTwoFactorSecurityOtpCode(String username, String otpCode) override;\n    bool checkUserPermission(String username, String permission) override;\n    LoginResult getUserNameFromToken(String token) override;\n    AuthorizationResults checkAuthentication(HTTPRequest * req, HTTPResponse * res, String permission) override;\n    void addPermissionForAdmin(String title, String group) override;\n};\n\nSecurity::Security(Context* context)\n    : context(context) {}\n\nvoid Security::initialize() {\n\n    HMACAuth auth(SECRET_KEY);\n\n\n    String sysAdminRole = \"System Admin\";\n    String AdminRole = \"Admin\";\n\n    RoleController* roleController = new RoleController(context, storageType);\n    UserController* userController = new UserController(context, storageType);\n\n    std::vector<RoleEntity> roleEntities = roleController->Get(String(RoleEntity::COLUMN_ROLENAME + \"=\" + sysAdminRole));\n    if (roleEntities.size() == 0)\n    {\n        RoleEntity* role = new RoleEntity(sysAdminRole);\n        sysAdmin_role_id = roleController->Add(*role);\n    }\n    else\n    {\n        sysAdmin_role_id = roleEntities.at(0).id;\n    }\n    \n    roleEntities.clear();\n    roleEntities = roleController->Get(String(RoleEntity::COLUMN_ROLENAME + \"=\" + AdminRole));\n    if (roleEntities.size() == 0)\n    {\n        RoleEntity* role = new RoleEntity(AdminRole);\n        admin_role_id = roleController->Add(*role);\n    }\n    else\n    {\n        admin_role_id = roleEntities.at(0).id;\n    }\n    \n    String sysAdminUserName = \"sysAdmin\";\n    String AdminUserName = \"admin\";\n\n    std::vector<UserEntity> users = userController->Get(String(UserEntity::COLUMN_USERNAME + \"=\" + sysAdminUserName));\n    if (users.size() == 0)\n    {\n        UserEntity* user = new UserEntity(sysAdminUserName, \"sysadmin\", \"\", \"\", sysAdmin_role_id, false, \"\", \"\", EBPDateTime::nullDateTime());\n        userController->Add(*user);        \n    }\n\n    users.clear();\n    users = userController->Get(String(UserEntity::COLUMN_USERNAME + \"=\" + AdminUserName));\n    if (users.size() == 0)\n    {\n        UserEntity* user = new UserEntity(AdminUserName, \"admin\", \"\", \"\", admin_role_id, false, \"\", \"\", EBPDateTime::nullDateTime());\n        userController->Add(*user);        \n    }\n}\n\nvoid Security::update() {\n\n}\n\nLoginResult Security::login(String username, String password)\n{\n    UserController* userController = new UserController(context, storageType);\n    std::vector<UserEntity> users = userController->Get(String(UserEntity::COLUMN_USERNAME + \"=\" + username));\n    if (users.size() > 0)\n    {\n        UserEntity user = users.at(0);\n        LoginResult loginresult = isLoginAllowed(&user, password);\n        if (loginresult.Result == LoginResults::Succesfull)\n        {\n            LoginResult tokenResult = generateJWT(user);\n            user.SetValue(UserEntity::COLUMN_TOKEN, tokenResult.getMessage());\n            userController->Update(user);\n            return tokenResult;\n            // return createUniqueToken(&user);\n        }\n        else if (loginresult.Result == LoginResults::NeedTwoFactorAuthentication)\n        {\n            if (sendTwoFactorSecurityOtpCode(username))\n            {\n                return LoginResult(false, LoginResults::TwoFactorAuthenticationOtpCodeSent);\n            }\n            else{\n                return LoginResult(false, LoginResults::TwoFactorAuthenticationOtpCodeNotSent);\n            }            \n        }\n        else if (loginresult.Result == LoginResults::PasswordIsIncorrect)\n        {\n            return LoginResult(false, LoginResults::WrongUserNameOrPassword);\n        }\n        else if (loginresult.Result == LoginResults::TowManyAttempts)\n        {\n            return loginresult;\n        }\n        else if (loginresult.Result == LoginResults::UserIsLocked)\n        {\n            return loginresult;\n        }        \n    }\n    else{\n        return LoginResult(false, LoginResults::WrongUserNameOrPassword);\n    }\n    return LoginResult(false, LoginResults::WrongUserNameOrPassword);\n}\n\nLoginResult Security::logout(String username)\n{\n    UserController* userController = new UserController(context, storageType);\n    std::vector<UserEntity> users = userController->Get(String(UserEntity::COLUMN_USERNAME + \"=\" + username));\n    if (users.size() > 0)\n    {\n        UserEntity user = users.at(0);\n        user.Token = \"\";\n        if(userController->Update(user))\n        {\n            return LoginResult(true, LoginResults::LogoutSuccessfull);\n        }\n        return LoginResult(false, LoginResults::LogoutUnSuccessfull);\n    }\n    return LoginResult(false, LoginResults::UsernameNotExists);\n}\n\n//check LoginAttepts and AccountLockout\nLoginResult Security::isLoginAllowed(UserEntity* user, String password)\n{\n    if (user->GetValue(UserEntity::COLUMN_PASSWORD) != password)\n    {\n        ///TODO:: add to login attempts\n        return LoginResult(false, LoginResults::PasswordIsIncorrect);\n    }\n    \n    return LoginResult(true, LoginResults::Succesfull);\n}\n\nbool Security::sendTwoFactorSecurityOtpCode(String username)\n{\n    return false;\n}\n\nbool Security::checkTwoFactorSecurityOtpCode(String username, String otpCode)\n{\n    return false;\n}\n\nbool Security::checkUserPermission(String username, String permission)\n{\n    if (username == \"sysAdmin\" || username == \"admin\")\n    {\n        return true;\n    }\n    ///TODO:: check permission for each admin level\n\n    int permissionId;\n    UserEntity user;\n    PermissionController* permissionController = new PermissionController(context, storageType);\n    std::vector<PermissionEntity> permissionEntities = permissionController->Get(String(PermissionEntity::COLUMN_PERMISSIONNAME + \"=\" + permission));\n    UserController* userController = new UserController(context, storageType);\n    \n    std::vector<UserEntity> users = userController->Get(String(UserEntity::COLUMN_USERNAME + \"=\" + username));\n    if (users.size() > 0)\n    {\n        user = users.at(0);\n    }else{\n        return false;\n    }\n\n    if (user.RoleId == 1)\n    {\n        //this is sys admin\n        return true;\n    }\n    \n\n    if (permissionEntities.size()>0)\n    {\n        permissionId = permissionEntities.at(0).id;\n    }else{\n        return false;\n    }\n    RolePermissionController* rolePermissionController = new RolePermissionController(context, storageType);\n    String query = String(RolePermissionEntity::COLUMN_ROLEID + \"=\" + user.GetValue(UserEntity::COLUMN_ROLEID) + \" AND \" + RolePermissionEntity::COLUMN_PERMISSIONID + \"=\" + permissionId);\n    std::vector<RolePermissionEntity> rolePermissionEntities = rolePermissionController->Get(query);\n    \n    if (rolePermissionEntities.size() > 0)\n    {\n        return true;\n    }else{\n        return false;\n    }\n    \n    return false;\n}\n\nLoginResult Security::createUniqueToken(UserEntity* user)\n{\n    String token = \"\";\n    String chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\n    for (int i = 0; i < 16; i++) {\n    char randomChar = chars[random(0, chars.length())];\n    token += randomChar;\n    }\n    \n    UserController* userController = new UserController(context, storageType);\n    EBPDateTime expiryDate = context->getClock()->now();\n    expiryDate.addToDateTime(0,0,context->getConfig()->getSecurityConfig()->get(SecurityConfigKey::TOKEN_ACTIVE_DAY).toInt(),0,0,0);\n    user = new UserEntity(user->id, user->GetValue(UserEntity::COLUMN_USERNAME), user->GetValue(UserEntity::COLUMN_PASSWORD), \n        user->GetValue(UserEntity::COLUMN_EMAIL), user->GetValue(UserEntity::COLUMN_PHONENUMBER), user->GetValue(UserEntity::COLUMN_ROLEID).toInt(), \n        boolean(user->GetValue(UserEntity::COLUMN_TWOFACTORAUTH)), user->GetValue(UserEntity::COLUMN_APIKEY), token, expiryDate);\n    if(userController->Update(*user))\n    {\n        LoginResult result = LoginResult(true, LoginResults::UsernameNotExists);\n        result.Message = token;\n        return result;\n    }\n    return LoginResult(false, LoginResults::TokenNotSaved);\n}\n\nLoginResult Security::getUserNameFromToken(String token)\n{\n    UserController* userController = new UserController(context, storageType);\n    std::vector<UserEntity> users = userController->Get(String(UserEntity::COLUMN_TOKEN + \"=\" + token));\n    if (users.size() > 0)\n    {\n        UserEntity user = users.at(0);\n        LoginResult result;\n        if (user.id == 1)\n        {\n            result = LoginResult(true, LoginResults::AdminUser);\n\n        }\n        else\n        {\n            result = LoginResult(true, LoginResults::Succesfull);\n        }\n        \n        result.Message = user.GetValue(UserEntity::COLUMN_USERNAME);\n        return result;\n    }\n    else{\n        return LoginResult(false, LoginResults::UsernameNotExists);\n    }\n\n}\n\n\nAuthorizationResults Security::checkAuthentication(HTTPRequest * req, HTTPResponse * res, String permission)\n{\n    bool authenticationEnable = context->getConfig()->getSecurityConfig()->get(SecurityConfigKey::AUTHENTICATION_ENABLE) == \"true\" ? true : false;\n    String username = \"\";\n\n    if(authenticationEnable)\n    {\n        Serial.println(\"authenticationEnable\");\n        // Check if the request has an Authorization header with the format \"Bearer <token>\"\n        if(req->getHeader(\"Authorization\").substr(0, 7) != \"Bearer \")\n        {\n            response(res, 400, \"text/html\", \"Authorization Header Missing\");\n            return AuthorizationResults::AUTH_HEADER_MISSING;\n        }\n        String authHeader = String(req->getHeader(\"Authorization\").c_str());\n        if(!authHeader.startsWith(\"Bearer \"))\n        {\n            response(res, 400, \"text/html\", \"Invalid Authorization format\");\n            return AuthorizationResults::INVALID_AUTHORIZATION_FORMAT;\n        }\n        String token = authHeader.substring(7); // Extract JWT token after \"Bearer \"\n        \n        if (!validateJWT(token))\n        {\n            response(res, 400, \"text/html\", \"Invalid token\");\n            return AuthorizationResults::INVALID_TOKEN;\n        }\n        \n\n        LoginResult result = getUserNameFromToken(token); // Assuming this function extracts the username from the JWT payload\n        if (result.Result == LoginResults::AdminUser)\n        {\n            Serial.println(\"is admin\");\n            return AuthorizationResults::SUCCESFULL;\n        }\n        \n        if (result.Result == LoginResults::UsernameNotExists)\n        {\n            response(res, 400, \"text/html\", result.getMessage());\n            return AuthorizationResults::USER_NOT_EXISTS;\n        }            \n        username = result.getMessage();\n        if (!checkUserPermission(username, permission))\n        {\n            response(res, 400, \"text/html\", \"User does not have the required permission\");\n            return AuthorizationResults::USER_NO_PERMISSION;\n        }\n        return AuthorizationResults::SUCCESFULL;\n    }\n    else\n    {\n        Serial.println(\"authentication disabled\");\n        return AuthorizationResults::SUCCESFULL;\n    }\n    response(res, 500, \"text/html\", \"some error happend\");\n    return AuthorizationResults::ERROR;\n}\n\n\nvoid Security::addPermissionForAdmin(String title, String group)\n{\n    addPermission(sysAdmin_role_id, title, group);\n    addPermission(admin_role_id, title, group);\n}\n\nvoid Security::addPermission(int role_id, String title, String group)\n{\n    RolePermissionController* rolePermissionController = new RolePermissionController(context, storageType);\n    PermissionController* permissionController = new PermissionController(context, storageType);\n\n    RolePermissionEntity* rolePermission;\n    PermissionEntity* permission;\n    \n    permission = new PermissionEntity(title, group);\n    int permission_id = permissionController->Add(*permission);\n\n    rolePermission = new RolePermissionEntity(role_id, permission_id);\n\n    rolePermissionController->Add(*rolePermission);\n}\n\nLoginResult Security::generateJWT(UserEntity user) {\n    // Construct the payload string using the provided username\n    String payload = user.GetValue(UserEntity::COLUMN_USERNAME);\n    // For now, let's assume pin is static. You can modify this\n    \n    // Initialize the hash with SECRET_KEY\n    HMACAuth auth(SECRET_KEY);\n    \n    // Update hash with payload and pin\n    auth.updateHash(payload.c_str());\n    auth.updateHash(pin);\n\n    // Finalize and get the hashed and encoded result\n    String jwtResult = auth.finalizeHash();\n    \n    // Assuming you store this result in the user entity or wherever necessary\n    LoginResult loginResult = LoginResult(true, LoginResults::Succesfull);\n    loginResult.Message = jwtResult;\n    \n    return loginResult;\n}\n\nbool Security::validateJWT(String jwtString) {\n    // Decode from Base64\n    return true;\n    unsigned char decodedOutput[65];\n    size_t decodedLength;\n    mbedtls_base64_decode(decodedOutput, sizeof(decodedOutput), &decodedLength, (unsigned char *)jwtString.c_str(), jwtString.length());\n    \n    // Extract payload from decoded value (assuming it's the first part)\n    String payload = String((char *)decodedOutput).substring(0, jwtString.length() - strlen(\"6577\"));  // Adjust as per actual structure\n    \n    // Recompute hash\n    HMACAuth auth(SECRET_KEY);\n\n    auth.updateHash(payload.c_str());\n    auth.updateHash(\"6577\"); // Assuming pin is static\n    String recomputedJWT = auth.finalizeHash();\n    \n    return jwtString == recomputedJWT;\n}\n#endif //SECURITY_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\SheduleManager\\ScheduleManager.h",
        "content": ""
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\SystemMonitor\\ISystemMonitor.h",
        "content": "#ifndef ISYSTEM_MONITOR_H\n#define ISYSTEM_MONITOR_H\n\n#include \"Esp.h\"\n#include \"LittleFS.h\"\n#include \"SD.h\"\n#include \"ArduinoJson.h\"\n\nstruct StorageInfo {\n    size_t totalBytes;\n    size_t usedBytes;\n};\n\nclass ISystemMonitor {\npublic:\n    virtual ~ISystemMonitor() {}\n\n    // CPU info\n    virtual uint8_t getChipCores() = 0;\n    virtual uint8_t getChipRevision() = 0;\n    virtual const char* getChipModel() = 0;\n    virtual const char* getSdkVersion() = 0;\n    virtual uint32_t getFlashChipSize() = 0;\n    virtual uint32_t getFlashChipSpeed() = 0;\n    virtual FlashMode_t getFlashChipMode() = 0;\n    virtual uint64_t getEfuseMac() = 0;\n\n    // RAM info\n    virtual uint32_t getHeapSize() = 0;\n    virtual uint32_t getFreeHeap() = 0;\n    virtual uint32_t getMinFreeHeap() = 0;\n    virtual uint32_t getMaxAllocHeap() = 0;\n\n    // SPIRAM info\n    virtual uint32_t getPsramSize() = 0;\n    virtual uint32_t getFreePsram() = 0;\n    virtual uint32_t getMinFreePsram() = 0;\n    virtual uint32_t getMaxAllocPsram() = 0;\n\n    // Sketch info\n    virtual uint32_t getSketchSize() = 0;\n    virtual uint32_t getFreeSketchSpace() = 0;\n    virtual String getSketchMD5() = 0;\n\n    // File system info\n    virtual StorageInfo getLittleFSInfo() = 0;\n    virtual StorageInfo getSDInfo() = 0;\n\n    // Uptime info\n    virtual unsigned long getUptime() = 0;\n\n    virtual String getSystemMonitorJson() = 0;\n\n};\n\n#endif // ISYSTEM_MONITOR_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\SystemMonitor\\SystemMonitor.h",
        "content": "#ifndef SYSTEM_MONITOR_H\n#define SYSTEM_MONITOR_H\n\n#include \"ISystemMonitor.h\"\n#include \"SD.h\"\n\nclass SystemMonitor : public ISystemMonitor {\npublic:\n    SystemMonitor();\n\n    // CPU info\n    virtual uint8_t getChipCores() override;\n    virtual uint8_t getChipRevision() override;\n    virtual const char* getChipModel() override;\n    virtual const char* getSdkVersion() override;\n    virtual uint32_t getFlashChipSize() override;\n    virtual uint32_t getFlashChipSpeed() override;\n    virtual FlashMode_t getFlashChipMode() override;\n    virtual uint64_t getEfuseMac() override;\n\n    // RAM info\n    virtual uint32_t getHeapSize() override;\n    virtual uint32_t getFreeHeap() override;\n    virtual uint32_t getMinFreeHeap() override;\n    virtual uint32_t getMaxAllocHeap() override;\n\n    // SPIRAM info\n    virtual uint32_t getPsramSize() override;\n    virtual uint32_t getFreePsram() override;\n    virtual uint32_t getMinFreePsram() override;\n    virtual uint32_t getMaxAllocPsram() override;\n\n    // Sketch info\n    virtual uint32_t getSketchSize() override;\n    virtual uint32_t getFreeSketchSpace() override;\n    virtual String getSketchMD5() override;\n\n    // File system info\n    virtual StorageInfo getLittleFSInfo() override;\n    virtual StorageInfo getSDInfo() override;\n\n    // Uptime info\n    virtual unsigned long getUptime() override;\n\n    virtual String getSystemMonitorJson() override;\n\n\nprivate:\n\n};\n\nSystemMonitor::SystemMonitor() {}\n\n// CPU info\nuint8_t SystemMonitor::getChipCores() {\n    return ESP.getCpuFreqMHz();\n}\n\nuint8_t SystemMonitor::getChipRevision() {\n    return ESP.getChipRevision();\n}\n\nconst char* SystemMonitor::getChipModel() {\n    return ESP.getChipModel();\n}\n\nconst char* SystemMonitor::getSdkVersion() {\n    return ESP.getSdkVersion();\n}\n\nuint32_t SystemMonitor::getFlashChipSize() {\n    return ESP.getFlashChipSize();\n}\n\nuint32_t SystemMonitor::getFlashChipSpeed() {\n    return ESP.getFlashChipSpeed();\n}\n\nFlashMode_t SystemMonitor::getFlashChipMode() {\n    return ESP.getFlashChipMode();\n}\n\nuint64_t SystemMonitor::getEfuseMac() {\n    return ESP.getEfuseMac();\n}\n\n// RAM info\nuint32_t SystemMonitor::getHeapSize() {\n    return ESP.getHeapSize();\n}\n\nuint32_t SystemMonitor::getFreeHeap() {\n    return ESP.getFreeHeap();\n}\n\nuint32_t SystemMonitor::getMinFreeHeap() {\n    return ESP.getMinFreeHeap();\n}\n\nuint32_t SystemMonitor::getMaxAllocHeap() {\n    return ESP.getMaxAllocHeap();\n}\n\n// SPIRAM info\nuint32_t SystemMonitor::getPsramSize() {\n    return ESP.getPsramSize();\n}\n\nuint32_t SystemMonitor::getFreePsram() {\n    return ESP.getFreePsram();\n}\n\nuint32_t SystemMonitor::getMinFreePsram() {\n    return ESP.getMinFreePsram();\n}\n\nuint32_t SystemMonitor::getMaxAllocPsram() {\n    return ESP.getMaxAllocPsram();\n}\n\n// Sketch info\nuint32_t SystemMonitor::getSketchSize() {\n    return ESP.getSketchSize();\n}\n\nuint32_t SystemMonitor::getFreeSketchSpace() {\n    return ESP.getFreeSketchSpace();\n}\n\nString SystemMonitor::getSketchMD5() {\n    return ESP.getSketchMD5();\n}\n\nStorageInfo SystemMonitor::getLittleFSInfo() {\n    StorageInfo fs_info;\n    fs_info.totalBytes = LittleFS.totalBytes();\n    fs_info.usedBytes = LittleFS.usedBytes();\n    return fs_info;\n}\n\n\nStorageInfo SystemMonitor::getSDInfo() {\n    StorageInfo fs_info;\n    fs_info.totalBytes = SD.totalBytes();\n    fs_info.usedBytes = SD.usedBytes();\n    return fs_info;\n}\n\n// Uptime info\nunsigned long SystemMonitor::getUptime() {\n    return millis();\n}\n\nString SystemMonitor::getSystemMonitorJson() {\n    DynamicJsonDocument doc(1024);\n\n    // CPU info\n    doc[\"cpu\"][\"cores\"] = getChipCores();\n    doc[\"cpu\"][\"revision\"] = getChipRevision();\n    doc[\"cpu\"][\"model\"] = getChipModel();\n    doc[\"cpu\"][\"sdk_version\"] = getSdkVersion();\n    doc[\"cpu\"][\"flash_chip_size\"] = getFlashChipSize();\n    doc[\"cpu\"][\"flash_chip_speed\"] = getFlashChipSpeed();\n    doc[\"cpu\"][\"flash_chip_mode\"] = getFlashChipMode();\n    doc[\"cpu\"][\"efuse_mac\"] = getEfuseMac();\n\n    // RAM info\n    doc[\"ram\"][\"heap_size\"] = getHeapSize();\n    doc[\"ram\"][\"free_heap\"] = getFreeHeap();\n    doc[\"ram\"][\"min_free_heap\"] = getMinFreeHeap();\n    doc[\"ram\"][\"max_alloc_heap\"] = getMaxAllocHeap();\n\n    // SPIRAM info\n    doc[\"spiram\"][\"psram_size\"] = getPsramSize();\n    doc[\"spiram\"][\"free_psram\"] = getFreePsram();\n    doc[\"spiram\"][\"min_free_psram\"] = getMinFreePsram();\n    doc[\"spiram\"][\"max_alloc_psram\"] = getMaxAllocPsram();\n\n    // Sketch info\n    doc[\"sketch\"][\"size\"] = getSketchSize();\n    doc[\"sketch\"][\"free_space\"] = getFreeSketchSpace();\n    doc[\"sketch\"][\"md5\"] = getSketchMD5();\n\n    // File system info\n    doc[\"spiffs\"][\"total_bytes\"] = getLittleFSInfo().totalBytes;\n    doc[\"spiffs\"][\"used_bytes\"] = getLittleFSInfo().usedBytes;\n    doc[\"sd\"][\"total_bytes\"] = getSDInfo().totalBytes;\n    doc[\"sd\"][\"used_bytes\"] = getSDInfo().usedBytes;\n\n    // Uptime info\n    doc[\"uptime\"] = getUptime();\n\n    String output;\n    serializeJson(doc, output);\n    return output;\n}\n#endif // SYSTEM_MONITOR_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Tests\\EntityControllerTests.h",
        "content": ""
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Tests\\MainControllerTest.h",
        "content": ""
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Tests\\Test.h",
        "content": ""
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Theme\\Theme.h",
        "content": ""
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Validation\\IValidation.h",
        "content": "// IValidation.h\n\n#ifndef IVALIDATION_H\n#define IVALIDATION_H\n\n#include <string>\n\nclass IValidation {\npublic:\n    virtual ~IValidation() {}\n\n    virtual bool validateEmail(const String& email) = 0;\n    virtual bool validateUsername(const String& username) = 0;\n    virtual bool isColumnNameValid(const String& columnName) = 0;\n    // Add more validation methods as needed\n};\n\n#endif // IVALIDATION_H\n"
    },
    {
        "path": "C:\\Users\\AIVWA 1\\Documents\\Arduino\\libraries\\ESPBoilerplate\\src\\Validation\\Validation.h",
        "content": "// Validation.h\n\n#ifndef VALIDATION_H\n#define VALIDATION_H\n\n#include <string>\n#include <regex>\n#include \"IValidation.h\"\n\nclass Validation : public IValidation {\npublic:\n    Validation()\n    {\n        \n    }\n    bool validateEmail(const String& email) override {\n        // Implement email validation logic here.\n        // For example, use a simple regex pattern:\n        // std::regex emailPattern(\"(\\\\w+)(\\\\.|_)?(\\\\w*)@(\\\\w+)(\\\\.(\\\\w+))+\");\n        // return std::regex_match(email, emailPattern);\n        return true;\n    }\n\n    bool validateUsername(const String& username) override {\n        // Implement username validation logic here.\n        // For example, check if the username length is between 3 and 20 characters:\n        return (username.length() >= 3 && username.length() <= 20);\n    }\n\n    bool isColumnNameValid(const String& columnName) override {\n        // Implement column name validation logic here.\n        // For example, check if the column name is \"id\" or \"name\":\n        // return (columnName == \"id\" || columnName == \"name\");\n        return true;\n    }\n\n    // Add more validation methods as needed\n};\n\n#endif // VALIDATION_H\n"
    }
]